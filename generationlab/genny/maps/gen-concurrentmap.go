// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package maps

import "sync"

//genny get maps/concurrentmap.go "Bool=BUILTINS Bool=BUILTINS"

// ConMapBoolBool is a concurrent safe wrapper around a
// map[Bool]Bool.
type ConMapBoolBool struct {
	// M is the underlying map[Bool]Bool.
	M map[bool]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolBool creates a new concurrent safe map storing bool values,
// for bool keys.
func NewConMapBoolBool() *ConMapBoolBool {
	return ToConMapBoolBool(nil)
}

// ToConMapBoolBool creates a new ConMapBoolBool prepopulated
// with the data from the specified map[Bool]Bool.
func ToConMapBoolBool(data map[bool]bool) *ConMapBoolBool {
	if data == nil {
		data = make(map[bool]bool)
	}
	return &ConMapBoolBool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given bool key.
func (cm *ConMapBoolBool) Get(k bool) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolBool) GetOK(k bool) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified bool key.
func (cm *ConMapBoolBool) Set(k bool, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolBool) Delete(k bool) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given bool key.
func (cm *ConMapBoolBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Byte=BUILTINS"

// ConMapBoolByte is a concurrent safe wrapper around a
// map[Bool]Byte.
type ConMapBoolByte struct {
	// M is the underlying map[Bool]Byte.
	M map[bool]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolByte creates a new concurrent safe map storing byte values,
// for bool keys.
func NewConMapBoolByte() *ConMapBoolByte {
	return ToConMapBoolByte(nil)
}

// ToConMapBoolByte creates a new ConMapBoolByte prepopulated
// with the data from the specified map[Bool]Byte.
func ToConMapBoolByte(data map[bool]byte) *ConMapBoolByte {
	if data == nil {
		data = make(map[bool]byte)
	}
	return &ConMapBoolByte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given bool key.
func (cm *ConMapBoolByte) Get(k bool) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolByte) GetOK(k bool) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified bool key.
func (cm *ConMapBoolByte) Set(k bool, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolByte) Delete(k bool) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given bool key.
func (cm *ConMapBoolByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Complex128=BUILTINS"

// ConMapBoolComplex128 is a concurrent safe wrapper around a
// map[Bool]Complex128.
type ConMapBoolComplex128 struct {
	// M is the underlying map[Bool]Complex128.
	M map[bool]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolComplex128 creates a new concurrent safe map storing complex128 values,
// for bool keys.
func NewConMapBoolComplex128() *ConMapBoolComplex128 {
	return ToConMapBoolComplex128(nil)
}

// ToConMapBoolComplex128 creates a new ConMapBoolComplex128 prepopulated
// with the data from the specified map[Bool]Complex128.
func ToConMapBoolComplex128(data map[bool]complex128) *ConMapBoolComplex128 {
	if data == nil {
		data = make(map[bool]complex128)
	}
	return &ConMapBoolComplex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given bool key.
func (cm *ConMapBoolComplex128) Get(k bool) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolComplex128) GetOK(k bool) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified bool key.
func (cm *ConMapBoolComplex128) Set(k bool, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolComplex128) Delete(k bool) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given bool key.
func (cm *ConMapBoolComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Complex64=BUILTINS"

// ConMapBoolComplex64 is a concurrent safe wrapper around a
// map[Bool]Complex64.
type ConMapBoolComplex64 struct {
	// M is the underlying map[Bool]Complex64.
	M map[bool]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolComplex64 creates a new concurrent safe map storing complex64 values,
// for bool keys.
func NewConMapBoolComplex64() *ConMapBoolComplex64 {
	return ToConMapBoolComplex64(nil)
}

// ToConMapBoolComplex64 creates a new ConMapBoolComplex64 prepopulated
// with the data from the specified map[Bool]Complex64.
func ToConMapBoolComplex64(data map[bool]complex64) *ConMapBoolComplex64 {
	if data == nil {
		data = make(map[bool]complex64)
	}
	return &ConMapBoolComplex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given bool key.
func (cm *ConMapBoolComplex64) Get(k bool) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolComplex64) GetOK(k bool) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified bool key.
func (cm *ConMapBoolComplex64) Set(k bool, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolComplex64) Delete(k bool) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given bool key.
func (cm *ConMapBoolComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Error=BUILTINS"

// ConMapBoolError is a concurrent safe wrapper around a
// map[Bool]Error.
type ConMapBoolError struct {
	// M is the underlying map[Bool]Error.
	M map[bool]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolError creates a new concurrent safe map storing error values,
// for bool keys.
func NewConMapBoolError() *ConMapBoolError {
	return ToConMapBoolError(nil)
}

// ToConMapBoolError creates a new ConMapBoolError prepopulated
// with the data from the specified map[Bool]Error.
func ToConMapBoolError(data map[bool]error) *ConMapBoolError {
	if data == nil {
		data = make(map[bool]error)
	}
	return &ConMapBoolError{M: data}
}

//var nilError error

// Get gets the error value for the given bool key.
func (cm *ConMapBoolError) Get(k bool) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolError) GetOK(k bool) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified bool key.
func (cm *ConMapBoolError) Set(k bool, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolError) Delete(k bool) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given bool key.
func (cm *ConMapBoolError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Float32=BUILTINS"

// ConMapBoolFloat32 is a concurrent safe wrapper around a
// map[Bool]Float32.
type ConMapBoolFloat32 struct {
	// M is the underlying map[Bool]Float32.
	M map[bool]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolFloat32 creates a new concurrent safe map storing float32 values,
// for bool keys.
func NewConMapBoolFloat32() *ConMapBoolFloat32 {
	return ToConMapBoolFloat32(nil)
}

// ToConMapBoolFloat32 creates a new ConMapBoolFloat32 prepopulated
// with the data from the specified map[Bool]Float32.
func ToConMapBoolFloat32(data map[bool]float32) *ConMapBoolFloat32 {
	if data == nil {
		data = make(map[bool]float32)
	}
	return &ConMapBoolFloat32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given bool key.
func (cm *ConMapBoolFloat32) Get(k bool) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolFloat32) GetOK(k bool) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified bool key.
func (cm *ConMapBoolFloat32) Set(k bool, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolFloat32) Delete(k bool) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given bool key.
func (cm *ConMapBoolFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Float64=BUILTINS"

// ConMapBoolFloat64 is a concurrent safe wrapper around a
// map[Bool]Float64.
type ConMapBoolFloat64 struct {
	// M is the underlying map[Bool]Float64.
	M map[bool]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolFloat64 creates a new concurrent safe map storing float64 values,
// for bool keys.
func NewConMapBoolFloat64() *ConMapBoolFloat64 {
	return ToConMapBoolFloat64(nil)
}

// ToConMapBoolFloat64 creates a new ConMapBoolFloat64 prepopulated
// with the data from the specified map[Bool]Float64.
func ToConMapBoolFloat64(data map[bool]float64) *ConMapBoolFloat64 {
	if data == nil {
		data = make(map[bool]float64)
	}
	return &ConMapBoolFloat64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given bool key.
func (cm *ConMapBoolFloat64) Get(k bool) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolFloat64) GetOK(k bool) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified bool key.
func (cm *ConMapBoolFloat64) Set(k bool, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolFloat64) Delete(k bool) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given bool key.
func (cm *ConMapBoolFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Int=BUILTINS"

// ConMapBoolInt is a concurrent safe wrapper around a
// map[Bool]Int.
type ConMapBoolInt struct {
	// M is the underlying map[Bool]Int.
	M map[bool]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolInt creates a new concurrent safe map storing int values,
// for bool keys.
func NewConMapBoolInt() *ConMapBoolInt {
	return ToConMapBoolInt(nil)
}

// ToConMapBoolInt creates a new ConMapBoolInt prepopulated
// with the data from the specified map[Bool]Int.
func ToConMapBoolInt(data map[bool]int) *ConMapBoolInt {
	if data == nil {
		data = make(map[bool]int)
	}
	return &ConMapBoolInt{M: data}
}

//var nilInt int

// Get gets the int value for the given bool key.
func (cm *ConMapBoolInt) Get(k bool) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolInt) GetOK(k bool) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified bool key.
func (cm *ConMapBoolInt) Set(k bool, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolInt) Delete(k bool) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given bool key.
func (cm *ConMapBoolInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Int16=BUILTINS"

// ConMapBoolInt16 is a concurrent safe wrapper around a
// map[Bool]Int16.
type ConMapBoolInt16 struct {
	// M is the underlying map[Bool]Int16.
	M map[bool]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolInt16 creates a new concurrent safe map storing int16 values,
// for bool keys.
func NewConMapBoolInt16() *ConMapBoolInt16 {
	return ToConMapBoolInt16(nil)
}

// ToConMapBoolInt16 creates a new ConMapBoolInt16 prepopulated
// with the data from the specified map[Bool]Int16.
func ToConMapBoolInt16(data map[bool]int16) *ConMapBoolInt16 {
	if data == nil {
		data = make(map[bool]int16)
	}
	return &ConMapBoolInt16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given bool key.
func (cm *ConMapBoolInt16) Get(k bool) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolInt16) GetOK(k bool) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified bool key.
func (cm *ConMapBoolInt16) Set(k bool, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolInt16) Delete(k bool) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given bool key.
func (cm *ConMapBoolInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Int32=BUILTINS"

// ConMapBoolInt32 is a concurrent safe wrapper around a
// map[Bool]Int32.
type ConMapBoolInt32 struct {
	// M is the underlying map[Bool]Int32.
	M map[bool]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolInt32 creates a new concurrent safe map storing int32 values,
// for bool keys.
func NewConMapBoolInt32() *ConMapBoolInt32 {
	return ToConMapBoolInt32(nil)
}

// ToConMapBoolInt32 creates a new ConMapBoolInt32 prepopulated
// with the data from the specified map[Bool]Int32.
func ToConMapBoolInt32(data map[bool]int32) *ConMapBoolInt32 {
	if data == nil {
		data = make(map[bool]int32)
	}
	return &ConMapBoolInt32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given bool key.
func (cm *ConMapBoolInt32) Get(k bool) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolInt32) GetOK(k bool) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified bool key.
func (cm *ConMapBoolInt32) Set(k bool, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolInt32) Delete(k bool) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given bool key.
func (cm *ConMapBoolInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Int64=BUILTINS"

// ConMapBoolInt64 is a concurrent safe wrapper around a
// map[Bool]Int64.
type ConMapBoolInt64 struct {
	// M is the underlying map[Bool]Int64.
	M map[bool]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolInt64 creates a new concurrent safe map storing int64 values,
// for bool keys.
func NewConMapBoolInt64() *ConMapBoolInt64 {
	return ToConMapBoolInt64(nil)
}

// ToConMapBoolInt64 creates a new ConMapBoolInt64 prepopulated
// with the data from the specified map[Bool]Int64.
func ToConMapBoolInt64(data map[bool]int64) *ConMapBoolInt64 {
	if data == nil {
		data = make(map[bool]int64)
	}
	return &ConMapBoolInt64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given bool key.
func (cm *ConMapBoolInt64) Get(k bool) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolInt64) GetOK(k bool) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified bool key.
func (cm *ConMapBoolInt64) Set(k bool, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolInt64) Delete(k bool) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given bool key.
func (cm *ConMapBoolInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Int8=BUILTINS"

// ConMapBoolInt8 is a concurrent safe wrapper around a
// map[Bool]Int8.
type ConMapBoolInt8 struct {
	// M is the underlying map[Bool]Int8.
	M map[bool]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolInt8 creates a new concurrent safe map storing int8 values,
// for bool keys.
func NewConMapBoolInt8() *ConMapBoolInt8 {
	return ToConMapBoolInt8(nil)
}

// ToConMapBoolInt8 creates a new ConMapBoolInt8 prepopulated
// with the data from the specified map[Bool]Int8.
func ToConMapBoolInt8(data map[bool]int8) *ConMapBoolInt8 {
	if data == nil {
		data = make(map[bool]int8)
	}
	return &ConMapBoolInt8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given bool key.
func (cm *ConMapBoolInt8) Get(k bool) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolInt8) GetOK(k bool) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified bool key.
func (cm *ConMapBoolInt8) Set(k bool, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolInt8) Delete(k bool) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given bool key.
func (cm *ConMapBoolInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Rune=BUILTINS"

// ConMapBoolRune is a concurrent safe wrapper around a
// map[Bool]Rune.
type ConMapBoolRune struct {
	// M is the underlying map[Bool]Rune.
	M map[bool]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolRune creates a new concurrent safe map storing rune values,
// for bool keys.
func NewConMapBoolRune() *ConMapBoolRune {
	return ToConMapBoolRune(nil)
}

// ToConMapBoolRune creates a new ConMapBoolRune prepopulated
// with the data from the specified map[Bool]Rune.
func ToConMapBoolRune(data map[bool]rune) *ConMapBoolRune {
	if data == nil {
		data = make(map[bool]rune)
	}
	return &ConMapBoolRune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given bool key.
func (cm *ConMapBoolRune) Get(k bool) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolRune) GetOK(k bool) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified bool key.
func (cm *ConMapBoolRune) Set(k bool, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolRune) Delete(k bool) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given bool key.
func (cm *ConMapBoolRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS String=BUILTINS"

// ConMapBoolString is a concurrent safe wrapper around a
// map[Bool]String.
type ConMapBoolString struct {
	// M is the underlying map[Bool]String.
	M map[bool]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolString creates a new concurrent safe map storing string values,
// for bool keys.
func NewConMapBoolString() *ConMapBoolString {
	return ToConMapBoolString(nil)
}

// ToConMapBoolString creates a new ConMapBoolString prepopulated
// with the data from the specified map[Bool]String.
func ToConMapBoolString(data map[bool]string) *ConMapBoolString {
	if data == nil {
		data = make(map[bool]string)
	}
	return &ConMapBoolString{M: data}
}

//var nilString string

// Get gets the string value for the given bool key.
func (cm *ConMapBoolString) Get(k bool) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolString) GetOK(k bool) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified bool key.
func (cm *ConMapBoolString) Set(k bool, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolString) Delete(k bool) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given bool key.
func (cm *ConMapBoolString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Uint=BUILTINS"

// ConMapBoolUint is a concurrent safe wrapper around a
// map[Bool]Uint.
type ConMapBoolUint struct {
	// M is the underlying map[Bool]Uint.
	M map[bool]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolUint creates a new concurrent safe map storing uint values,
// for bool keys.
func NewConMapBoolUint() *ConMapBoolUint {
	return ToConMapBoolUint(nil)
}

// ToConMapBoolUint creates a new ConMapBoolUint prepopulated
// with the data from the specified map[Bool]Uint.
func ToConMapBoolUint(data map[bool]uint) *ConMapBoolUint {
	if data == nil {
		data = make(map[bool]uint)
	}
	return &ConMapBoolUint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given bool key.
func (cm *ConMapBoolUint) Get(k bool) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolUint) GetOK(k bool) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified bool key.
func (cm *ConMapBoolUint) Set(k bool, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolUint) Delete(k bool) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given bool key.
func (cm *ConMapBoolUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Uint16=BUILTINS"

// ConMapBoolUint16 is a concurrent safe wrapper around a
// map[Bool]Uint16.
type ConMapBoolUint16 struct {
	// M is the underlying map[Bool]Uint16.
	M map[bool]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolUint16 creates a new concurrent safe map storing uint16 values,
// for bool keys.
func NewConMapBoolUint16() *ConMapBoolUint16 {
	return ToConMapBoolUint16(nil)
}

// ToConMapBoolUint16 creates a new ConMapBoolUint16 prepopulated
// with the data from the specified map[Bool]Uint16.
func ToConMapBoolUint16(data map[bool]uint16) *ConMapBoolUint16 {
	if data == nil {
		data = make(map[bool]uint16)
	}
	return &ConMapBoolUint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given bool key.
func (cm *ConMapBoolUint16) Get(k bool) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolUint16) GetOK(k bool) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified bool key.
func (cm *ConMapBoolUint16) Set(k bool, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolUint16) Delete(k bool) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given bool key.
func (cm *ConMapBoolUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Uint32=BUILTINS"

// ConMapBoolUint32 is a concurrent safe wrapper around a
// map[Bool]Uint32.
type ConMapBoolUint32 struct {
	// M is the underlying map[Bool]Uint32.
	M map[bool]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolUint32 creates a new concurrent safe map storing uint32 values,
// for bool keys.
func NewConMapBoolUint32() *ConMapBoolUint32 {
	return ToConMapBoolUint32(nil)
}

// ToConMapBoolUint32 creates a new ConMapBoolUint32 prepopulated
// with the data from the specified map[Bool]Uint32.
func ToConMapBoolUint32(data map[bool]uint32) *ConMapBoolUint32 {
	if data == nil {
		data = make(map[bool]uint32)
	}
	return &ConMapBoolUint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given bool key.
func (cm *ConMapBoolUint32) Get(k bool) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolUint32) GetOK(k bool) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified bool key.
func (cm *ConMapBoolUint32) Set(k bool, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolUint32) Delete(k bool) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given bool key.
func (cm *ConMapBoolUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Uint64=BUILTINS"

// ConMapBoolUint64 is a concurrent safe wrapper around a
// map[Bool]Uint64.
type ConMapBoolUint64 struct {
	// M is the underlying map[Bool]Uint64.
	M map[bool]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolUint64 creates a new concurrent safe map storing uint64 values,
// for bool keys.
func NewConMapBoolUint64() *ConMapBoolUint64 {
	return ToConMapBoolUint64(nil)
}

// ToConMapBoolUint64 creates a new ConMapBoolUint64 prepopulated
// with the data from the specified map[Bool]Uint64.
func ToConMapBoolUint64(data map[bool]uint64) *ConMapBoolUint64 {
	if data == nil {
		data = make(map[bool]uint64)
	}
	return &ConMapBoolUint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given bool key.
func (cm *ConMapBoolUint64) Get(k bool) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolUint64) GetOK(k bool) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified bool key.
func (cm *ConMapBoolUint64) Set(k bool, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolUint64) Delete(k bool) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given bool key.
func (cm *ConMapBoolUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Uint8=BUILTINS"

// ConMapBoolUint8 is a concurrent safe wrapper around a
// map[Bool]Uint8.
type ConMapBoolUint8 struct {
	// M is the underlying map[Bool]Uint8.
	M map[bool]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolUint8 creates a new concurrent safe map storing uint8 values,
// for bool keys.
func NewConMapBoolUint8() *ConMapBoolUint8 {
	return ToConMapBoolUint8(nil)
}

// ToConMapBoolUint8 creates a new ConMapBoolUint8 prepopulated
// with the data from the specified map[Bool]Uint8.
func ToConMapBoolUint8(data map[bool]uint8) *ConMapBoolUint8 {
	if data == nil {
		data = make(map[bool]uint8)
	}
	return &ConMapBoolUint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given bool key.
func (cm *ConMapBoolUint8) Get(k bool) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolUint8) GetOK(k bool) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified bool key.
func (cm *ConMapBoolUint8) Set(k bool, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolUint8) Delete(k bool) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given bool key.
func (cm *ConMapBoolUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Bool=BUILTINS Uintptr=BUILTINS"

// ConMapBoolUintptr is a concurrent safe wrapper around a
// map[Bool]Uintptr.
type ConMapBoolUintptr struct {
	// M is the underlying map[Bool]Uintptr.
	M map[bool]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapBoolUintptr creates a new concurrent safe map storing uintptr values,
// for bool keys.
func NewConMapBoolUintptr() *ConMapBoolUintptr {
	return ToConMapBoolUintptr(nil)
}

// ToConMapBoolUintptr creates a new ConMapBoolUintptr prepopulated
// with the data from the specified map[Bool]Uintptr.
func ToConMapBoolUintptr(data map[bool]uintptr) *ConMapBoolUintptr {
	if data == nil {
		data = make(map[bool]uintptr)
	}
	return &ConMapBoolUintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given bool key.
func (cm *ConMapBoolUintptr) Get(k bool) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given bool key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapBoolUintptr) GetOK(k bool) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified bool key.
func (cm *ConMapBoolUintptr) Set(k bool, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified bool key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapBoolUintptr) Delete(k bool) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given bool key.
func (cm *ConMapBoolUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Bool=BUILTINS"

// ConMapByteBool is a concurrent safe wrapper around a
// map[Byte]Bool.
type ConMapByteBool struct {
	// M is the underlying map[Byte]Bool.
	M map[byte]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteBool creates a new concurrent safe map storing bool values,
// for byte keys.
func NewConMapByteBool() *ConMapByteBool {
	return ToConMapByteBool(nil)
}

// ToConMapByteBool creates a new ConMapByteBool prepopulated
// with the data from the specified map[Byte]Bool.
func ToConMapByteBool(data map[byte]bool) *ConMapByteBool {
	if data == nil {
		data = make(map[byte]bool)
	}
	return &ConMapByteBool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given byte key.
func (cm *ConMapByteBool) Get(k byte) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteBool) GetOK(k byte) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified byte key.
func (cm *ConMapByteBool) Set(k byte, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteBool) Delete(k byte) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given byte key.
func (cm *ConMapByteBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Byte=BUILTINS"

// ConMapByteByte is a concurrent safe wrapper around a
// map[Byte]Byte.
type ConMapByteByte struct {
	// M is the underlying map[Byte]Byte.
	M map[byte]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteByte creates a new concurrent safe map storing byte values,
// for byte keys.
func NewConMapByteByte() *ConMapByteByte {
	return ToConMapByteByte(nil)
}

// ToConMapByteByte creates a new ConMapByteByte prepopulated
// with the data from the specified map[Byte]Byte.
func ToConMapByteByte(data map[byte]byte) *ConMapByteByte {
	if data == nil {
		data = make(map[byte]byte)
	}
	return &ConMapByteByte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given byte key.
func (cm *ConMapByteByte) Get(k byte) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteByte) GetOK(k byte) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified byte key.
func (cm *ConMapByteByte) Set(k byte, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteByte) Delete(k byte) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given byte key.
func (cm *ConMapByteByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Complex128=BUILTINS"

// ConMapByteComplex128 is a concurrent safe wrapper around a
// map[Byte]Complex128.
type ConMapByteComplex128 struct {
	// M is the underlying map[Byte]Complex128.
	M map[byte]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteComplex128 creates a new concurrent safe map storing complex128 values,
// for byte keys.
func NewConMapByteComplex128() *ConMapByteComplex128 {
	return ToConMapByteComplex128(nil)
}

// ToConMapByteComplex128 creates a new ConMapByteComplex128 prepopulated
// with the data from the specified map[Byte]Complex128.
func ToConMapByteComplex128(data map[byte]complex128) *ConMapByteComplex128 {
	if data == nil {
		data = make(map[byte]complex128)
	}
	return &ConMapByteComplex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given byte key.
func (cm *ConMapByteComplex128) Get(k byte) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteComplex128) GetOK(k byte) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified byte key.
func (cm *ConMapByteComplex128) Set(k byte, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteComplex128) Delete(k byte) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given byte key.
func (cm *ConMapByteComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Complex64=BUILTINS"

// ConMapByteComplex64 is a concurrent safe wrapper around a
// map[Byte]Complex64.
type ConMapByteComplex64 struct {
	// M is the underlying map[Byte]Complex64.
	M map[byte]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteComplex64 creates a new concurrent safe map storing complex64 values,
// for byte keys.
func NewConMapByteComplex64() *ConMapByteComplex64 {
	return ToConMapByteComplex64(nil)
}

// ToConMapByteComplex64 creates a new ConMapByteComplex64 prepopulated
// with the data from the specified map[Byte]Complex64.
func ToConMapByteComplex64(data map[byte]complex64) *ConMapByteComplex64 {
	if data == nil {
		data = make(map[byte]complex64)
	}
	return &ConMapByteComplex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given byte key.
func (cm *ConMapByteComplex64) Get(k byte) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteComplex64) GetOK(k byte) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified byte key.
func (cm *ConMapByteComplex64) Set(k byte, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteComplex64) Delete(k byte) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given byte key.
func (cm *ConMapByteComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Error=BUILTINS"

// ConMapByteError is a concurrent safe wrapper around a
// map[Byte]Error.
type ConMapByteError struct {
	// M is the underlying map[Byte]Error.
	M map[byte]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteError creates a new concurrent safe map storing error values,
// for byte keys.
func NewConMapByteError() *ConMapByteError {
	return ToConMapByteError(nil)
}

// ToConMapByteError creates a new ConMapByteError prepopulated
// with the data from the specified map[Byte]Error.
func ToConMapByteError(data map[byte]error) *ConMapByteError {
	if data == nil {
		data = make(map[byte]error)
	}
	return &ConMapByteError{M: data}
}

//var nilError error

// Get gets the error value for the given byte key.
func (cm *ConMapByteError) Get(k byte) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteError) GetOK(k byte) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified byte key.
func (cm *ConMapByteError) Set(k byte, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteError) Delete(k byte) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given byte key.
func (cm *ConMapByteError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Float32=BUILTINS"

// ConMapByteFloat32 is a concurrent safe wrapper around a
// map[Byte]Float32.
type ConMapByteFloat32 struct {
	// M is the underlying map[Byte]Float32.
	M map[byte]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteFloat32 creates a new concurrent safe map storing float32 values,
// for byte keys.
func NewConMapByteFloat32() *ConMapByteFloat32 {
	return ToConMapByteFloat32(nil)
}

// ToConMapByteFloat32 creates a new ConMapByteFloat32 prepopulated
// with the data from the specified map[Byte]Float32.
func ToConMapByteFloat32(data map[byte]float32) *ConMapByteFloat32 {
	if data == nil {
		data = make(map[byte]float32)
	}
	return &ConMapByteFloat32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given byte key.
func (cm *ConMapByteFloat32) Get(k byte) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteFloat32) GetOK(k byte) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified byte key.
func (cm *ConMapByteFloat32) Set(k byte, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteFloat32) Delete(k byte) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given byte key.
func (cm *ConMapByteFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Float64=BUILTINS"

// ConMapByteFloat64 is a concurrent safe wrapper around a
// map[Byte]Float64.
type ConMapByteFloat64 struct {
	// M is the underlying map[Byte]Float64.
	M map[byte]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteFloat64 creates a new concurrent safe map storing float64 values,
// for byte keys.
func NewConMapByteFloat64() *ConMapByteFloat64 {
	return ToConMapByteFloat64(nil)
}

// ToConMapByteFloat64 creates a new ConMapByteFloat64 prepopulated
// with the data from the specified map[Byte]Float64.
func ToConMapByteFloat64(data map[byte]float64) *ConMapByteFloat64 {
	if data == nil {
		data = make(map[byte]float64)
	}
	return &ConMapByteFloat64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given byte key.
func (cm *ConMapByteFloat64) Get(k byte) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteFloat64) GetOK(k byte) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified byte key.
func (cm *ConMapByteFloat64) Set(k byte, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteFloat64) Delete(k byte) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given byte key.
func (cm *ConMapByteFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Int=BUILTINS"

// ConMapByteInt is a concurrent safe wrapper around a
// map[Byte]Int.
type ConMapByteInt struct {
	// M is the underlying map[Byte]Int.
	M map[byte]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteInt creates a new concurrent safe map storing int values,
// for byte keys.
func NewConMapByteInt() *ConMapByteInt {
	return ToConMapByteInt(nil)
}

// ToConMapByteInt creates a new ConMapByteInt prepopulated
// with the data from the specified map[Byte]Int.
func ToConMapByteInt(data map[byte]int) *ConMapByteInt {
	if data == nil {
		data = make(map[byte]int)
	}
	return &ConMapByteInt{M: data}
}

//var nilInt int

// Get gets the int value for the given byte key.
func (cm *ConMapByteInt) Get(k byte) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteInt) GetOK(k byte) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified byte key.
func (cm *ConMapByteInt) Set(k byte, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteInt) Delete(k byte) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given byte key.
func (cm *ConMapByteInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Int16=BUILTINS"

// ConMapByteInt16 is a concurrent safe wrapper around a
// map[Byte]Int16.
type ConMapByteInt16 struct {
	// M is the underlying map[Byte]Int16.
	M map[byte]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteInt16 creates a new concurrent safe map storing int16 values,
// for byte keys.
func NewConMapByteInt16() *ConMapByteInt16 {
	return ToConMapByteInt16(nil)
}

// ToConMapByteInt16 creates a new ConMapByteInt16 prepopulated
// with the data from the specified map[Byte]Int16.
func ToConMapByteInt16(data map[byte]int16) *ConMapByteInt16 {
	if data == nil {
		data = make(map[byte]int16)
	}
	return &ConMapByteInt16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given byte key.
func (cm *ConMapByteInt16) Get(k byte) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteInt16) GetOK(k byte) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified byte key.
func (cm *ConMapByteInt16) Set(k byte, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteInt16) Delete(k byte) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given byte key.
func (cm *ConMapByteInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Int32=BUILTINS"

// ConMapByteInt32 is a concurrent safe wrapper around a
// map[Byte]Int32.
type ConMapByteInt32 struct {
	// M is the underlying map[Byte]Int32.
	M map[byte]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteInt32 creates a new concurrent safe map storing int32 values,
// for byte keys.
func NewConMapByteInt32() *ConMapByteInt32 {
	return ToConMapByteInt32(nil)
}

// ToConMapByteInt32 creates a new ConMapByteInt32 prepopulated
// with the data from the specified map[Byte]Int32.
func ToConMapByteInt32(data map[byte]int32) *ConMapByteInt32 {
	if data == nil {
		data = make(map[byte]int32)
	}
	return &ConMapByteInt32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given byte key.
func (cm *ConMapByteInt32) Get(k byte) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteInt32) GetOK(k byte) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified byte key.
func (cm *ConMapByteInt32) Set(k byte, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteInt32) Delete(k byte) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given byte key.
func (cm *ConMapByteInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Int64=BUILTINS"

// ConMapByteInt64 is a concurrent safe wrapper around a
// map[Byte]Int64.
type ConMapByteInt64 struct {
	// M is the underlying map[Byte]Int64.
	M map[byte]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteInt64 creates a new concurrent safe map storing int64 values,
// for byte keys.
func NewConMapByteInt64() *ConMapByteInt64 {
	return ToConMapByteInt64(nil)
}

// ToConMapByteInt64 creates a new ConMapByteInt64 prepopulated
// with the data from the specified map[Byte]Int64.
func ToConMapByteInt64(data map[byte]int64) *ConMapByteInt64 {
	if data == nil {
		data = make(map[byte]int64)
	}
	return &ConMapByteInt64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given byte key.
func (cm *ConMapByteInt64) Get(k byte) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteInt64) GetOK(k byte) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified byte key.
func (cm *ConMapByteInt64) Set(k byte, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteInt64) Delete(k byte) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given byte key.
func (cm *ConMapByteInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Int8=BUILTINS"

// ConMapByteInt8 is a concurrent safe wrapper around a
// map[Byte]Int8.
type ConMapByteInt8 struct {
	// M is the underlying map[Byte]Int8.
	M map[byte]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteInt8 creates a new concurrent safe map storing int8 values,
// for byte keys.
func NewConMapByteInt8() *ConMapByteInt8 {
	return ToConMapByteInt8(nil)
}

// ToConMapByteInt8 creates a new ConMapByteInt8 prepopulated
// with the data from the specified map[Byte]Int8.
func ToConMapByteInt8(data map[byte]int8) *ConMapByteInt8 {
	if data == nil {
		data = make(map[byte]int8)
	}
	return &ConMapByteInt8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given byte key.
func (cm *ConMapByteInt8) Get(k byte) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteInt8) GetOK(k byte) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified byte key.
func (cm *ConMapByteInt8) Set(k byte, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteInt8) Delete(k byte) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given byte key.
func (cm *ConMapByteInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Rune=BUILTINS"

// ConMapByteRune is a concurrent safe wrapper around a
// map[Byte]Rune.
type ConMapByteRune struct {
	// M is the underlying map[Byte]Rune.
	M map[byte]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteRune creates a new concurrent safe map storing rune values,
// for byte keys.
func NewConMapByteRune() *ConMapByteRune {
	return ToConMapByteRune(nil)
}

// ToConMapByteRune creates a new ConMapByteRune prepopulated
// with the data from the specified map[Byte]Rune.
func ToConMapByteRune(data map[byte]rune) *ConMapByteRune {
	if data == nil {
		data = make(map[byte]rune)
	}
	return &ConMapByteRune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given byte key.
func (cm *ConMapByteRune) Get(k byte) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteRune) GetOK(k byte) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified byte key.
func (cm *ConMapByteRune) Set(k byte, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteRune) Delete(k byte) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given byte key.
func (cm *ConMapByteRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS String=BUILTINS"

// ConMapByteString is a concurrent safe wrapper around a
// map[Byte]String.
type ConMapByteString struct {
	// M is the underlying map[Byte]String.
	M map[byte]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteString creates a new concurrent safe map storing string values,
// for byte keys.
func NewConMapByteString() *ConMapByteString {
	return ToConMapByteString(nil)
}

// ToConMapByteString creates a new ConMapByteString prepopulated
// with the data from the specified map[Byte]String.
func ToConMapByteString(data map[byte]string) *ConMapByteString {
	if data == nil {
		data = make(map[byte]string)
	}
	return &ConMapByteString{M: data}
}

//var nilString string

// Get gets the string value for the given byte key.
func (cm *ConMapByteString) Get(k byte) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteString) GetOK(k byte) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified byte key.
func (cm *ConMapByteString) Set(k byte, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteString) Delete(k byte) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given byte key.
func (cm *ConMapByteString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Uint=BUILTINS"

// ConMapByteUint is a concurrent safe wrapper around a
// map[Byte]Uint.
type ConMapByteUint struct {
	// M is the underlying map[Byte]Uint.
	M map[byte]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteUint creates a new concurrent safe map storing uint values,
// for byte keys.
func NewConMapByteUint() *ConMapByteUint {
	return ToConMapByteUint(nil)
}

// ToConMapByteUint creates a new ConMapByteUint prepopulated
// with the data from the specified map[Byte]Uint.
func ToConMapByteUint(data map[byte]uint) *ConMapByteUint {
	if data == nil {
		data = make(map[byte]uint)
	}
	return &ConMapByteUint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given byte key.
func (cm *ConMapByteUint) Get(k byte) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteUint) GetOK(k byte) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified byte key.
func (cm *ConMapByteUint) Set(k byte, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteUint) Delete(k byte) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given byte key.
func (cm *ConMapByteUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Uint16=BUILTINS"

// ConMapByteUint16 is a concurrent safe wrapper around a
// map[Byte]Uint16.
type ConMapByteUint16 struct {
	// M is the underlying map[Byte]Uint16.
	M map[byte]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteUint16 creates a new concurrent safe map storing uint16 values,
// for byte keys.
func NewConMapByteUint16() *ConMapByteUint16 {
	return ToConMapByteUint16(nil)
}

// ToConMapByteUint16 creates a new ConMapByteUint16 prepopulated
// with the data from the specified map[Byte]Uint16.
func ToConMapByteUint16(data map[byte]uint16) *ConMapByteUint16 {
	if data == nil {
		data = make(map[byte]uint16)
	}
	return &ConMapByteUint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given byte key.
func (cm *ConMapByteUint16) Get(k byte) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteUint16) GetOK(k byte) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified byte key.
func (cm *ConMapByteUint16) Set(k byte, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteUint16) Delete(k byte) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given byte key.
func (cm *ConMapByteUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Uint32=BUILTINS"

// ConMapByteUint32 is a concurrent safe wrapper around a
// map[Byte]Uint32.
type ConMapByteUint32 struct {
	// M is the underlying map[Byte]Uint32.
	M map[byte]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteUint32 creates a new concurrent safe map storing uint32 values,
// for byte keys.
func NewConMapByteUint32() *ConMapByteUint32 {
	return ToConMapByteUint32(nil)
}

// ToConMapByteUint32 creates a new ConMapByteUint32 prepopulated
// with the data from the specified map[Byte]Uint32.
func ToConMapByteUint32(data map[byte]uint32) *ConMapByteUint32 {
	if data == nil {
		data = make(map[byte]uint32)
	}
	return &ConMapByteUint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given byte key.
func (cm *ConMapByteUint32) Get(k byte) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteUint32) GetOK(k byte) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified byte key.
func (cm *ConMapByteUint32) Set(k byte, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteUint32) Delete(k byte) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given byte key.
func (cm *ConMapByteUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Uint64=BUILTINS"

// ConMapByteUint64 is a concurrent safe wrapper around a
// map[Byte]Uint64.
type ConMapByteUint64 struct {
	// M is the underlying map[Byte]Uint64.
	M map[byte]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteUint64 creates a new concurrent safe map storing uint64 values,
// for byte keys.
func NewConMapByteUint64() *ConMapByteUint64 {
	return ToConMapByteUint64(nil)
}

// ToConMapByteUint64 creates a new ConMapByteUint64 prepopulated
// with the data from the specified map[Byte]Uint64.
func ToConMapByteUint64(data map[byte]uint64) *ConMapByteUint64 {
	if data == nil {
		data = make(map[byte]uint64)
	}
	return &ConMapByteUint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given byte key.
func (cm *ConMapByteUint64) Get(k byte) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteUint64) GetOK(k byte) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified byte key.
func (cm *ConMapByteUint64) Set(k byte, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteUint64) Delete(k byte) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given byte key.
func (cm *ConMapByteUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Uint8=BUILTINS"

// ConMapByteUint8 is a concurrent safe wrapper around a
// map[Byte]Uint8.
type ConMapByteUint8 struct {
	// M is the underlying map[Byte]Uint8.
	M map[byte]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteUint8 creates a new concurrent safe map storing uint8 values,
// for byte keys.
func NewConMapByteUint8() *ConMapByteUint8 {
	return ToConMapByteUint8(nil)
}

// ToConMapByteUint8 creates a new ConMapByteUint8 prepopulated
// with the data from the specified map[Byte]Uint8.
func ToConMapByteUint8(data map[byte]uint8) *ConMapByteUint8 {
	if data == nil {
		data = make(map[byte]uint8)
	}
	return &ConMapByteUint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given byte key.
func (cm *ConMapByteUint8) Get(k byte) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteUint8) GetOK(k byte) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified byte key.
func (cm *ConMapByteUint8) Set(k byte, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteUint8) Delete(k byte) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given byte key.
func (cm *ConMapByteUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Byte=BUILTINS Uintptr=BUILTINS"

// ConMapByteUintptr is a concurrent safe wrapper around a
// map[Byte]Uintptr.
type ConMapByteUintptr struct {
	// M is the underlying map[Byte]Uintptr.
	M map[byte]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapByteUintptr creates a new concurrent safe map storing uintptr values,
// for byte keys.
func NewConMapByteUintptr() *ConMapByteUintptr {
	return ToConMapByteUintptr(nil)
}

// ToConMapByteUintptr creates a new ConMapByteUintptr prepopulated
// with the data from the specified map[Byte]Uintptr.
func ToConMapByteUintptr(data map[byte]uintptr) *ConMapByteUintptr {
	if data == nil {
		data = make(map[byte]uintptr)
	}
	return &ConMapByteUintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given byte key.
func (cm *ConMapByteUintptr) Get(k byte) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given byte key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapByteUintptr) GetOK(k byte) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified byte key.
func (cm *ConMapByteUintptr) Set(k byte, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified byte key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapByteUintptr) Delete(k byte) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given byte key.
func (cm *ConMapByteUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Bool=BUILTINS"

// ConMapComplex128Bool is a concurrent safe wrapper around a
// map[Complex128]Bool.
type ConMapComplex128Bool struct {
	// M is the underlying map[Complex128]Bool.
	M map[complex128]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Bool creates a new concurrent safe map storing bool values,
// for complex128 keys.
func NewConMapComplex128Bool() *ConMapComplex128Bool {
	return ToConMapComplex128Bool(nil)
}

// ToConMapComplex128Bool creates a new ConMapComplex128Bool prepopulated
// with the data from the specified map[Complex128]Bool.
func ToConMapComplex128Bool(data map[complex128]bool) *ConMapComplex128Bool {
	if data == nil {
		data = make(map[complex128]bool)
	}
	return &ConMapComplex128Bool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given complex128 key.
func (cm *ConMapComplex128Bool) Get(k complex128) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Bool) GetOK(k complex128) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified complex128 key.
func (cm *ConMapComplex128Bool) Set(k complex128, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Bool) Delete(k complex128) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given complex128 key.
func (cm *ConMapComplex128Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Byte=BUILTINS"

// ConMapComplex128Byte is a concurrent safe wrapper around a
// map[Complex128]Byte.
type ConMapComplex128Byte struct {
	// M is the underlying map[Complex128]Byte.
	M map[complex128]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Byte creates a new concurrent safe map storing byte values,
// for complex128 keys.
func NewConMapComplex128Byte() *ConMapComplex128Byte {
	return ToConMapComplex128Byte(nil)
}

// ToConMapComplex128Byte creates a new ConMapComplex128Byte prepopulated
// with the data from the specified map[Complex128]Byte.
func ToConMapComplex128Byte(data map[complex128]byte) *ConMapComplex128Byte {
	if data == nil {
		data = make(map[complex128]byte)
	}
	return &ConMapComplex128Byte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given complex128 key.
func (cm *ConMapComplex128Byte) Get(k complex128) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Byte) GetOK(k complex128) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified complex128 key.
func (cm *ConMapComplex128Byte) Set(k complex128, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Byte) Delete(k complex128) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given complex128 key.
func (cm *ConMapComplex128Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Complex128=BUILTINS"

// ConMapComplex128Complex128 is a concurrent safe wrapper around a
// map[Complex128]Complex128.
type ConMapComplex128Complex128 struct {
	// M is the underlying map[Complex128]Complex128.
	M map[complex128]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Complex128 creates a new concurrent safe map storing complex128 values,
// for complex128 keys.
func NewConMapComplex128Complex128() *ConMapComplex128Complex128 {
	return ToConMapComplex128Complex128(nil)
}

// ToConMapComplex128Complex128 creates a new ConMapComplex128Complex128 prepopulated
// with the data from the specified map[Complex128]Complex128.
func ToConMapComplex128Complex128(data map[complex128]complex128) *ConMapComplex128Complex128 {
	if data == nil {
		data = make(map[complex128]complex128)
	}
	return &ConMapComplex128Complex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given complex128 key.
func (cm *ConMapComplex128Complex128) Get(k complex128) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Complex128) GetOK(k complex128) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified complex128 key.
func (cm *ConMapComplex128Complex128) Set(k complex128, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Complex128) Delete(k complex128) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given complex128 key.
func (cm *ConMapComplex128Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Complex64=BUILTINS"

// ConMapComplex128Complex64 is a concurrent safe wrapper around a
// map[Complex128]Complex64.
type ConMapComplex128Complex64 struct {
	// M is the underlying map[Complex128]Complex64.
	M map[complex128]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Complex64 creates a new concurrent safe map storing complex64 values,
// for complex128 keys.
func NewConMapComplex128Complex64() *ConMapComplex128Complex64 {
	return ToConMapComplex128Complex64(nil)
}

// ToConMapComplex128Complex64 creates a new ConMapComplex128Complex64 prepopulated
// with the data from the specified map[Complex128]Complex64.
func ToConMapComplex128Complex64(data map[complex128]complex64) *ConMapComplex128Complex64 {
	if data == nil {
		data = make(map[complex128]complex64)
	}
	return &ConMapComplex128Complex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given complex128 key.
func (cm *ConMapComplex128Complex64) Get(k complex128) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Complex64) GetOK(k complex128) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified complex128 key.
func (cm *ConMapComplex128Complex64) Set(k complex128, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Complex64) Delete(k complex128) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given complex128 key.
func (cm *ConMapComplex128Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Error=BUILTINS"

// ConMapComplex128Error is a concurrent safe wrapper around a
// map[Complex128]Error.
type ConMapComplex128Error struct {
	// M is the underlying map[Complex128]Error.
	M map[complex128]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Error creates a new concurrent safe map storing error values,
// for complex128 keys.
func NewConMapComplex128Error() *ConMapComplex128Error {
	return ToConMapComplex128Error(nil)
}

// ToConMapComplex128Error creates a new ConMapComplex128Error prepopulated
// with the data from the specified map[Complex128]Error.
func ToConMapComplex128Error(data map[complex128]error) *ConMapComplex128Error {
	if data == nil {
		data = make(map[complex128]error)
	}
	return &ConMapComplex128Error{M: data}
}

//var nilError error

// Get gets the error value for the given complex128 key.
func (cm *ConMapComplex128Error) Get(k complex128) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Error) GetOK(k complex128) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified complex128 key.
func (cm *ConMapComplex128Error) Set(k complex128, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Error) Delete(k complex128) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given complex128 key.
func (cm *ConMapComplex128Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Float32=BUILTINS"

// ConMapComplex128Float32 is a concurrent safe wrapper around a
// map[Complex128]Float32.
type ConMapComplex128Float32 struct {
	// M is the underlying map[Complex128]Float32.
	M map[complex128]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Float32 creates a new concurrent safe map storing float32 values,
// for complex128 keys.
func NewConMapComplex128Float32() *ConMapComplex128Float32 {
	return ToConMapComplex128Float32(nil)
}

// ToConMapComplex128Float32 creates a new ConMapComplex128Float32 prepopulated
// with the data from the specified map[Complex128]Float32.
func ToConMapComplex128Float32(data map[complex128]float32) *ConMapComplex128Float32 {
	if data == nil {
		data = make(map[complex128]float32)
	}
	return &ConMapComplex128Float32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given complex128 key.
func (cm *ConMapComplex128Float32) Get(k complex128) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Float32) GetOK(k complex128) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified complex128 key.
func (cm *ConMapComplex128Float32) Set(k complex128, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Float32) Delete(k complex128) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given complex128 key.
func (cm *ConMapComplex128Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Float64=BUILTINS"

// ConMapComplex128Float64 is a concurrent safe wrapper around a
// map[Complex128]Float64.
type ConMapComplex128Float64 struct {
	// M is the underlying map[Complex128]Float64.
	M map[complex128]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Float64 creates a new concurrent safe map storing float64 values,
// for complex128 keys.
func NewConMapComplex128Float64() *ConMapComplex128Float64 {
	return ToConMapComplex128Float64(nil)
}

// ToConMapComplex128Float64 creates a new ConMapComplex128Float64 prepopulated
// with the data from the specified map[Complex128]Float64.
func ToConMapComplex128Float64(data map[complex128]float64) *ConMapComplex128Float64 {
	if data == nil {
		data = make(map[complex128]float64)
	}
	return &ConMapComplex128Float64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given complex128 key.
func (cm *ConMapComplex128Float64) Get(k complex128) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Float64) GetOK(k complex128) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified complex128 key.
func (cm *ConMapComplex128Float64) Set(k complex128, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Float64) Delete(k complex128) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given complex128 key.
func (cm *ConMapComplex128Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Int=BUILTINS"

// ConMapComplex128Int is a concurrent safe wrapper around a
// map[Complex128]Int.
type ConMapComplex128Int struct {
	// M is the underlying map[Complex128]Int.
	M map[complex128]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Int creates a new concurrent safe map storing int values,
// for complex128 keys.
func NewConMapComplex128Int() *ConMapComplex128Int {
	return ToConMapComplex128Int(nil)
}

// ToConMapComplex128Int creates a new ConMapComplex128Int prepopulated
// with the data from the specified map[Complex128]Int.
func ToConMapComplex128Int(data map[complex128]int) *ConMapComplex128Int {
	if data == nil {
		data = make(map[complex128]int)
	}
	return &ConMapComplex128Int{M: data}
}

//var nilInt int

// Get gets the int value for the given complex128 key.
func (cm *ConMapComplex128Int) Get(k complex128) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Int) GetOK(k complex128) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified complex128 key.
func (cm *ConMapComplex128Int) Set(k complex128, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Int) Delete(k complex128) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given complex128 key.
func (cm *ConMapComplex128Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Int16=BUILTINS"

// ConMapComplex128Int16 is a concurrent safe wrapper around a
// map[Complex128]Int16.
type ConMapComplex128Int16 struct {
	// M is the underlying map[Complex128]Int16.
	M map[complex128]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Int16 creates a new concurrent safe map storing int16 values,
// for complex128 keys.
func NewConMapComplex128Int16() *ConMapComplex128Int16 {
	return ToConMapComplex128Int16(nil)
}

// ToConMapComplex128Int16 creates a new ConMapComplex128Int16 prepopulated
// with the data from the specified map[Complex128]Int16.
func ToConMapComplex128Int16(data map[complex128]int16) *ConMapComplex128Int16 {
	if data == nil {
		data = make(map[complex128]int16)
	}
	return &ConMapComplex128Int16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given complex128 key.
func (cm *ConMapComplex128Int16) Get(k complex128) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Int16) GetOK(k complex128) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified complex128 key.
func (cm *ConMapComplex128Int16) Set(k complex128, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Int16) Delete(k complex128) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given complex128 key.
func (cm *ConMapComplex128Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Int32=BUILTINS"

// ConMapComplex128Int32 is a concurrent safe wrapper around a
// map[Complex128]Int32.
type ConMapComplex128Int32 struct {
	// M is the underlying map[Complex128]Int32.
	M map[complex128]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Int32 creates a new concurrent safe map storing int32 values,
// for complex128 keys.
func NewConMapComplex128Int32() *ConMapComplex128Int32 {
	return ToConMapComplex128Int32(nil)
}

// ToConMapComplex128Int32 creates a new ConMapComplex128Int32 prepopulated
// with the data from the specified map[Complex128]Int32.
func ToConMapComplex128Int32(data map[complex128]int32) *ConMapComplex128Int32 {
	if data == nil {
		data = make(map[complex128]int32)
	}
	return &ConMapComplex128Int32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given complex128 key.
func (cm *ConMapComplex128Int32) Get(k complex128) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Int32) GetOK(k complex128) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified complex128 key.
func (cm *ConMapComplex128Int32) Set(k complex128, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Int32) Delete(k complex128) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given complex128 key.
func (cm *ConMapComplex128Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Int64=BUILTINS"

// ConMapComplex128Int64 is a concurrent safe wrapper around a
// map[Complex128]Int64.
type ConMapComplex128Int64 struct {
	// M is the underlying map[Complex128]Int64.
	M map[complex128]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Int64 creates a new concurrent safe map storing int64 values,
// for complex128 keys.
func NewConMapComplex128Int64() *ConMapComplex128Int64 {
	return ToConMapComplex128Int64(nil)
}

// ToConMapComplex128Int64 creates a new ConMapComplex128Int64 prepopulated
// with the data from the specified map[Complex128]Int64.
func ToConMapComplex128Int64(data map[complex128]int64) *ConMapComplex128Int64 {
	if data == nil {
		data = make(map[complex128]int64)
	}
	return &ConMapComplex128Int64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given complex128 key.
func (cm *ConMapComplex128Int64) Get(k complex128) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Int64) GetOK(k complex128) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified complex128 key.
func (cm *ConMapComplex128Int64) Set(k complex128, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Int64) Delete(k complex128) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given complex128 key.
func (cm *ConMapComplex128Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Int8=BUILTINS"

// ConMapComplex128Int8 is a concurrent safe wrapper around a
// map[Complex128]Int8.
type ConMapComplex128Int8 struct {
	// M is the underlying map[Complex128]Int8.
	M map[complex128]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Int8 creates a new concurrent safe map storing int8 values,
// for complex128 keys.
func NewConMapComplex128Int8() *ConMapComplex128Int8 {
	return ToConMapComplex128Int8(nil)
}

// ToConMapComplex128Int8 creates a new ConMapComplex128Int8 prepopulated
// with the data from the specified map[Complex128]Int8.
func ToConMapComplex128Int8(data map[complex128]int8) *ConMapComplex128Int8 {
	if data == nil {
		data = make(map[complex128]int8)
	}
	return &ConMapComplex128Int8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given complex128 key.
func (cm *ConMapComplex128Int8) Get(k complex128) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Int8) GetOK(k complex128) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified complex128 key.
func (cm *ConMapComplex128Int8) Set(k complex128, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Int8) Delete(k complex128) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given complex128 key.
func (cm *ConMapComplex128Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Rune=BUILTINS"

// ConMapComplex128Rune is a concurrent safe wrapper around a
// map[Complex128]Rune.
type ConMapComplex128Rune struct {
	// M is the underlying map[Complex128]Rune.
	M map[complex128]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Rune creates a new concurrent safe map storing rune values,
// for complex128 keys.
func NewConMapComplex128Rune() *ConMapComplex128Rune {
	return ToConMapComplex128Rune(nil)
}

// ToConMapComplex128Rune creates a new ConMapComplex128Rune prepopulated
// with the data from the specified map[Complex128]Rune.
func ToConMapComplex128Rune(data map[complex128]rune) *ConMapComplex128Rune {
	if data == nil {
		data = make(map[complex128]rune)
	}
	return &ConMapComplex128Rune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given complex128 key.
func (cm *ConMapComplex128Rune) Get(k complex128) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Rune) GetOK(k complex128) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified complex128 key.
func (cm *ConMapComplex128Rune) Set(k complex128, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Rune) Delete(k complex128) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given complex128 key.
func (cm *ConMapComplex128Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS String=BUILTINS"

// ConMapComplex128String is a concurrent safe wrapper around a
// map[Complex128]String.
type ConMapComplex128String struct {
	// M is the underlying map[Complex128]String.
	M map[complex128]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128String creates a new concurrent safe map storing string values,
// for complex128 keys.
func NewConMapComplex128String() *ConMapComplex128String {
	return ToConMapComplex128String(nil)
}

// ToConMapComplex128String creates a new ConMapComplex128String prepopulated
// with the data from the specified map[Complex128]String.
func ToConMapComplex128String(data map[complex128]string) *ConMapComplex128String {
	if data == nil {
		data = make(map[complex128]string)
	}
	return &ConMapComplex128String{M: data}
}

//var nilString string

// Get gets the string value for the given complex128 key.
func (cm *ConMapComplex128String) Get(k complex128) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128String) GetOK(k complex128) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified complex128 key.
func (cm *ConMapComplex128String) Set(k complex128, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128String) Delete(k complex128) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given complex128 key.
func (cm *ConMapComplex128String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Uint=BUILTINS"

// ConMapComplex128Uint is a concurrent safe wrapper around a
// map[Complex128]Uint.
type ConMapComplex128Uint struct {
	// M is the underlying map[Complex128]Uint.
	M map[complex128]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Uint creates a new concurrent safe map storing uint values,
// for complex128 keys.
func NewConMapComplex128Uint() *ConMapComplex128Uint {
	return ToConMapComplex128Uint(nil)
}

// ToConMapComplex128Uint creates a new ConMapComplex128Uint prepopulated
// with the data from the specified map[Complex128]Uint.
func ToConMapComplex128Uint(data map[complex128]uint) *ConMapComplex128Uint {
	if data == nil {
		data = make(map[complex128]uint)
	}
	return &ConMapComplex128Uint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given complex128 key.
func (cm *ConMapComplex128Uint) Get(k complex128) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Uint) GetOK(k complex128) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified complex128 key.
func (cm *ConMapComplex128Uint) Set(k complex128, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Uint) Delete(k complex128) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given complex128 key.
func (cm *ConMapComplex128Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Uint16=BUILTINS"

// ConMapComplex128Uint16 is a concurrent safe wrapper around a
// map[Complex128]Uint16.
type ConMapComplex128Uint16 struct {
	// M is the underlying map[Complex128]Uint16.
	M map[complex128]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Uint16 creates a new concurrent safe map storing uint16 values,
// for complex128 keys.
func NewConMapComplex128Uint16() *ConMapComplex128Uint16 {
	return ToConMapComplex128Uint16(nil)
}

// ToConMapComplex128Uint16 creates a new ConMapComplex128Uint16 prepopulated
// with the data from the specified map[Complex128]Uint16.
func ToConMapComplex128Uint16(data map[complex128]uint16) *ConMapComplex128Uint16 {
	if data == nil {
		data = make(map[complex128]uint16)
	}
	return &ConMapComplex128Uint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given complex128 key.
func (cm *ConMapComplex128Uint16) Get(k complex128) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Uint16) GetOK(k complex128) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified complex128 key.
func (cm *ConMapComplex128Uint16) Set(k complex128, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Uint16) Delete(k complex128) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given complex128 key.
func (cm *ConMapComplex128Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Uint32=BUILTINS"

// ConMapComplex128Uint32 is a concurrent safe wrapper around a
// map[Complex128]Uint32.
type ConMapComplex128Uint32 struct {
	// M is the underlying map[Complex128]Uint32.
	M map[complex128]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Uint32 creates a new concurrent safe map storing uint32 values,
// for complex128 keys.
func NewConMapComplex128Uint32() *ConMapComplex128Uint32 {
	return ToConMapComplex128Uint32(nil)
}

// ToConMapComplex128Uint32 creates a new ConMapComplex128Uint32 prepopulated
// with the data from the specified map[Complex128]Uint32.
func ToConMapComplex128Uint32(data map[complex128]uint32) *ConMapComplex128Uint32 {
	if data == nil {
		data = make(map[complex128]uint32)
	}
	return &ConMapComplex128Uint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given complex128 key.
func (cm *ConMapComplex128Uint32) Get(k complex128) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Uint32) GetOK(k complex128) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified complex128 key.
func (cm *ConMapComplex128Uint32) Set(k complex128, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Uint32) Delete(k complex128) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given complex128 key.
func (cm *ConMapComplex128Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Uint64=BUILTINS"

// ConMapComplex128Uint64 is a concurrent safe wrapper around a
// map[Complex128]Uint64.
type ConMapComplex128Uint64 struct {
	// M is the underlying map[Complex128]Uint64.
	M map[complex128]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Uint64 creates a new concurrent safe map storing uint64 values,
// for complex128 keys.
func NewConMapComplex128Uint64() *ConMapComplex128Uint64 {
	return ToConMapComplex128Uint64(nil)
}

// ToConMapComplex128Uint64 creates a new ConMapComplex128Uint64 prepopulated
// with the data from the specified map[Complex128]Uint64.
func ToConMapComplex128Uint64(data map[complex128]uint64) *ConMapComplex128Uint64 {
	if data == nil {
		data = make(map[complex128]uint64)
	}
	return &ConMapComplex128Uint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given complex128 key.
func (cm *ConMapComplex128Uint64) Get(k complex128) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Uint64) GetOK(k complex128) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified complex128 key.
func (cm *ConMapComplex128Uint64) Set(k complex128, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Uint64) Delete(k complex128) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given complex128 key.
func (cm *ConMapComplex128Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Uint8=BUILTINS"

// ConMapComplex128Uint8 is a concurrent safe wrapper around a
// map[Complex128]Uint8.
type ConMapComplex128Uint8 struct {
	// M is the underlying map[Complex128]Uint8.
	M map[complex128]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Uint8 creates a new concurrent safe map storing uint8 values,
// for complex128 keys.
func NewConMapComplex128Uint8() *ConMapComplex128Uint8 {
	return ToConMapComplex128Uint8(nil)
}

// ToConMapComplex128Uint8 creates a new ConMapComplex128Uint8 prepopulated
// with the data from the specified map[Complex128]Uint8.
func ToConMapComplex128Uint8(data map[complex128]uint8) *ConMapComplex128Uint8 {
	if data == nil {
		data = make(map[complex128]uint8)
	}
	return &ConMapComplex128Uint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given complex128 key.
func (cm *ConMapComplex128Uint8) Get(k complex128) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Uint8) GetOK(k complex128) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified complex128 key.
func (cm *ConMapComplex128Uint8) Set(k complex128, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Uint8) Delete(k complex128) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given complex128 key.
func (cm *ConMapComplex128Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex128=BUILTINS Uintptr=BUILTINS"

// ConMapComplex128Uintptr is a concurrent safe wrapper around a
// map[Complex128]Uintptr.
type ConMapComplex128Uintptr struct {
	// M is the underlying map[Complex128]Uintptr.
	M map[complex128]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex128Uintptr creates a new concurrent safe map storing uintptr values,
// for complex128 keys.
func NewConMapComplex128Uintptr() *ConMapComplex128Uintptr {
	return ToConMapComplex128Uintptr(nil)
}

// ToConMapComplex128Uintptr creates a new ConMapComplex128Uintptr prepopulated
// with the data from the specified map[Complex128]Uintptr.
func ToConMapComplex128Uintptr(data map[complex128]uintptr) *ConMapComplex128Uintptr {
	if data == nil {
		data = make(map[complex128]uintptr)
	}
	return &ConMapComplex128Uintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given complex128 key.
func (cm *ConMapComplex128Uintptr) Get(k complex128) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given complex128 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex128Uintptr) GetOK(k complex128) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified complex128 key.
func (cm *ConMapComplex128Uintptr) Set(k complex128, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex128 key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex128Uintptr) Delete(k complex128) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given complex128 key.
func (cm *ConMapComplex128Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Bool=BUILTINS"

// ConMapComplex64Bool is a concurrent safe wrapper around a
// map[Complex64]Bool.
type ConMapComplex64Bool struct {
	// M is the underlying map[Complex64]Bool.
	M map[complex64]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Bool creates a new concurrent safe map storing bool values,
// for complex64 keys.
func NewConMapComplex64Bool() *ConMapComplex64Bool {
	return ToConMapComplex64Bool(nil)
}

// ToConMapComplex64Bool creates a new ConMapComplex64Bool prepopulated
// with the data from the specified map[Complex64]Bool.
func ToConMapComplex64Bool(data map[complex64]bool) *ConMapComplex64Bool {
	if data == nil {
		data = make(map[complex64]bool)
	}
	return &ConMapComplex64Bool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given complex64 key.
func (cm *ConMapComplex64Bool) Get(k complex64) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Bool) GetOK(k complex64) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified complex64 key.
func (cm *ConMapComplex64Bool) Set(k complex64, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Bool) Delete(k complex64) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given complex64 key.
func (cm *ConMapComplex64Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Byte=BUILTINS"

// ConMapComplex64Byte is a concurrent safe wrapper around a
// map[Complex64]Byte.
type ConMapComplex64Byte struct {
	// M is the underlying map[Complex64]Byte.
	M map[complex64]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Byte creates a new concurrent safe map storing byte values,
// for complex64 keys.
func NewConMapComplex64Byte() *ConMapComplex64Byte {
	return ToConMapComplex64Byte(nil)
}

// ToConMapComplex64Byte creates a new ConMapComplex64Byte prepopulated
// with the data from the specified map[Complex64]Byte.
func ToConMapComplex64Byte(data map[complex64]byte) *ConMapComplex64Byte {
	if data == nil {
		data = make(map[complex64]byte)
	}
	return &ConMapComplex64Byte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given complex64 key.
func (cm *ConMapComplex64Byte) Get(k complex64) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Byte) GetOK(k complex64) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified complex64 key.
func (cm *ConMapComplex64Byte) Set(k complex64, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Byte) Delete(k complex64) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given complex64 key.
func (cm *ConMapComplex64Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Complex128=BUILTINS"

// ConMapComplex64Complex128 is a concurrent safe wrapper around a
// map[Complex64]Complex128.
type ConMapComplex64Complex128 struct {
	// M is the underlying map[Complex64]Complex128.
	M map[complex64]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Complex128 creates a new concurrent safe map storing complex128 values,
// for complex64 keys.
func NewConMapComplex64Complex128() *ConMapComplex64Complex128 {
	return ToConMapComplex64Complex128(nil)
}

// ToConMapComplex64Complex128 creates a new ConMapComplex64Complex128 prepopulated
// with the data from the specified map[Complex64]Complex128.
func ToConMapComplex64Complex128(data map[complex64]complex128) *ConMapComplex64Complex128 {
	if data == nil {
		data = make(map[complex64]complex128)
	}
	return &ConMapComplex64Complex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given complex64 key.
func (cm *ConMapComplex64Complex128) Get(k complex64) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Complex128) GetOK(k complex64) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified complex64 key.
func (cm *ConMapComplex64Complex128) Set(k complex64, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Complex128) Delete(k complex64) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given complex64 key.
func (cm *ConMapComplex64Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Complex64=BUILTINS"

// ConMapComplex64Complex64 is a concurrent safe wrapper around a
// map[Complex64]Complex64.
type ConMapComplex64Complex64 struct {
	// M is the underlying map[Complex64]Complex64.
	M map[complex64]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Complex64 creates a new concurrent safe map storing complex64 values,
// for complex64 keys.
func NewConMapComplex64Complex64() *ConMapComplex64Complex64 {
	return ToConMapComplex64Complex64(nil)
}

// ToConMapComplex64Complex64 creates a new ConMapComplex64Complex64 prepopulated
// with the data from the specified map[Complex64]Complex64.
func ToConMapComplex64Complex64(data map[complex64]complex64) *ConMapComplex64Complex64 {
	if data == nil {
		data = make(map[complex64]complex64)
	}
	return &ConMapComplex64Complex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given complex64 key.
func (cm *ConMapComplex64Complex64) Get(k complex64) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Complex64) GetOK(k complex64) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified complex64 key.
func (cm *ConMapComplex64Complex64) Set(k complex64, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Complex64) Delete(k complex64) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given complex64 key.
func (cm *ConMapComplex64Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Error=BUILTINS"

// ConMapComplex64Error is a concurrent safe wrapper around a
// map[Complex64]Error.
type ConMapComplex64Error struct {
	// M is the underlying map[Complex64]Error.
	M map[complex64]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Error creates a new concurrent safe map storing error values,
// for complex64 keys.
func NewConMapComplex64Error() *ConMapComplex64Error {
	return ToConMapComplex64Error(nil)
}

// ToConMapComplex64Error creates a new ConMapComplex64Error prepopulated
// with the data from the specified map[Complex64]Error.
func ToConMapComplex64Error(data map[complex64]error) *ConMapComplex64Error {
	if data == nil {
		data = make(map[complex64]error)
	}
	return &ConMapComplex64Error{M: data}
}

//var nilError error

// Get gets the error value for the given complex64 key.
func (cm *ConMapComplex64Error) Get(k complex64) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Error) GetOK(k complex64) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified complex64 key.
func (cm *ConMapComplex64Error) Set(k complex64, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Error) Delete(k complex64) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given complex64 key.
func (cm *ConMapComplex64Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Float32=BUILTINS"

// ConMapComplex64Float32 is a concurrent safe wrapper around a
// map[Complex64]Float32.
type ConMapComplex64Float32 struct {
	// M is the underlying map[Complex64]Float32.
	M map[complex64]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Float32 creates a new concurrent safe map storing float32 values,
// for complex64 keys.
func NewConMapComplex64Float32() *ConMapComplex64Float32 {
	return ToConMapComplex64Float32(nil)
}

// ToConMapComplex64Float32 creates a new ConMapComplex64Float32 prepopulated
// with the data from the specified map[Complex64]Float32.
func ToConMapComplex64Float32(data map[complex64]float32) *ConMapComplex64Float32 {
	if data == nil {
		data = make(map[complex64]float32)
	}
	return &ConMapComplex64Float32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given complex64 key.
func (cm *ConMapComplex64Float32) Get(k complex64) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Float32) GetOK(k complex64) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified complex64 key.
func (cm *ConMapComplex64Float32) Set(k complex64, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Float32) Delete(k complex64) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given complex64 key.
func (cm *ConMapComplex64Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Float64=BUILTINS"

// ConMapComplex64Float64 is a concurrent safe wrapper around a
// map[Complex64]Float64.
type ConMapComplex64Float64 struct {
	// M is the underlying map[Complex64]Float64.
	M map[complex64]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Float64 creates a new concurrent safe map storing float64 values,
// for complex64 keys.
func NewConMapComplex64Float64() *ConMapComplex64Float64 {
	return ToConMapComplex64Float64(nil)
}

// ToConMapComplex64Float64 creates a new ConMapComplex64Float64 prepopulated
// with the data from the specified map[Complex64]Float64.
func ToConMapComplex64Float64(data map[complex64]float64) *ConMapComplex64Float64 {
	if data == nil {
		data = make(map[complex64]float64)
	}
	return &ConMapComplex64Float64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given complex64 key.
func (cm *ConMapComplex64Float64) Get(k complex64) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Float64) GetOK(k complex64) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified complex64 key.
func (cm *ConMapComplex64Float64) Set(k complex64, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Float64) Delete(k complex64) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given complex64 key.
func (cm *ConMapComplex64Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Int=BUILTINS"

// ConMapComplex64Int is a concurrent safe wrapper around a
// map[Complex64]Int.
type ConMapComplex64Int struct {
	// M is the underlying map[Complex64]Int.
	M map[complex64]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Int creates a new concurrent safe map storing int values,
// for complex64 keys.
func NewConMapComplex64Int() *ConMapComplex64Int {
	return ToConMapComplex64Int(nil)
}

// ToConMapComplex64Int creates a new ConMapComplex64Int prepopulated
// with the data from the specified map[Complex64]Int.
func ToConMapComplex64Int(data map[complex64]int) *ConMapComplex64Int {
	if data == nil {
		data = make(map[complex64]int)
	}
	return &ConMapComplex64Int{M: data}
}

//var nilInt int

// Get gets the int value for the given complex64 key.
func (cm *ConMapComplex64Int) Get(k complex64) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Int) GetOK(k complex64) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified complex64 key.
func (cm *ConMapComplex64Int) Set(k complex64, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Int) Delete(k complex64) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given complex64 key.
func (cm *ConMapComplex64Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Int16=BUILTINS"

// ConMapComplex64Int16 is a concurrent safe wrapper around a
// map[Complex64]Int16.
type ConMapComplex64Int16 struct {
	// M is the underlying map[Complex64]Int16.
	M map[complex64]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Int16 creates a new concurrent safe map storing int16 values,
// for complex64 keys.
func NewConMapComplex64Int16() *ConMapComplex64Int16 {
	return ToConMapComplex64Int16(nil)
}

// ToConMapComplex64Int16 creates a new ConMapComplex64Int16 prepopulated
// with the data from the specified map[Complex64]Int16.
func ToConMapComplex64Int16(data map[complex64]int16) *ConMapComplex64Int16 {
	if data == nil {
		data = make(map[complex64]int16)
	}
	return &ConMapComplex64Int16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given complex64 key.
func (cm *ConMapComplex64Int16) Get(k complex64) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Int16) GetOK(k complex64) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified complex64 key.
func (cm *ConMapComplex64Int16) Set(k complex64, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Int16) Delete(k complex64) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given complex64 key.
func (cm *ConMapComplex64Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Int32=BUILTINS"

// ConMapComplex64Int32 is a concurrent safe wrapper around a
// map[Complex64]Int32.
type ConMapComplex64Int32 struct {
	// M is the underlying map[Complex64]Int32.
	M map[complex64]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Int32 creates a new concurrent safe map storing int32 values,
// for complex64 keys.
func NewConMapComplex64Int32() *ConMapComplex64Int32 {
	return ToConMapComplex64Int32(nil)
}

// ToConMapComplex64Int32 creates a new ConMapComplex64Int32 prepopulated
// with the data from the specified map[Complex64]Int32.
func ToConMapComplex64Int32(data map[complex64]int32) *ConMapComplex64Int32 {
	if data == nil {
		data = make(map[complex64]int32)
	}
	return &ConMapComplex64Int32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given complex64 key.
func (cm *ConMapComplex64Int32) Get(k complex64) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Int32) GetOK(k complex64) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified complex64 key.
func (cm *ConMapComplex64Int32) Set(k complex64, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Int32) Delete(k complex64) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given complex64 key.
func (cm *ConMapComplex64Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Int64=BUILTINS"

// ConMapComplex64Int64 is a concurrent safe wrapper around a
// map[Complex64]Int64.
type ConMapComplex64Int64 struct {
	// M is the underlying map[Complex64]Int64.
	M map[complex64]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Int64 creates a new concurrent safe map storing int64 values,
// for complex64 keys.
func NewConMapComplex64Int64() *ConMapComplex64Int64 {
	return ToConMapComplex64Int64(nil)
}

// ToConMapComplex64Int64 creates a new ConMapComplex64Int64 prepopulated
// with the data from the specified map[Complex64]Int64.
func ToConMapComplex64Int64(data map[complex64]int64) *ConMapComplex64Int64 {
	if data == nil {
		data = make(map[complex64]int64)
	}
	return &ConMapComplex64Int64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given complex64 key.
func (cm *ConMapComplex64Int64) Get(k complex64) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Int64) GetOK(k complex64) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified complex64 key.
func (cm *ConMapComplex64Int64) Set(k complex64, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Int64) Delete(k complex64) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given complex64 key.
func (cm *ConMapComplex64Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Int8=BUILTINS"

// ConMapComplex64Int8 is a concurrent safe wrapper around a
// map[Complex64]Int8.
type ConMapComplex64Int8 struct {
	// M is the underlying map[Complex64]Int8.
	M map[complex64]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Int8 creates a new concurrent safe map storing int8 values,
// for complex64 keys.
func NewConMapComplex64Int8() *ConMapComplex64Int8 {
	return ToConMapComplex64Int8(nil)
}

// ToConMapComplex64Int8 creates a new ConMapComplex64Int8 prepopulated
// with the data from the specified map[Complex64]Int8.
func ToConMapComplex64Int8(data map[complex64]int8) *ConMapComplex64Int8 {
	if data == nil {
		data = make(map[complex64]int8)
	}
	return &ConMapComplex64Int8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given complex64 key.
func (cm *ConMapComplex64Int8) Get(k complex64) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Int8) GetOK(k complex64) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified complex64 key.
func (cm *ConMapComplex64Int8) Set(k complex64, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Int8) Delete(k complex64) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given complex64 key.
func (cm *ConMapComplex64Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Rune=BUILTINS"

// ConMapComplex64Rune is a concurrent safe wrapper around a
// map[Complex64]Rune.
type ConMapComplex64Rune struct {
	// M is the underlying map[Complex64]Rune.
	M map[complex64]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Rune creates a new concurrent safe map storing rune values,
// for complex64 keys.
func NewConMapComplex64Rune() *ConMapComplex64Rune {
	return ToConMapComplex64Rune(nil)
}

// ToConMapComplex64Rune creates a new ConMapComplex64Rune prepopulated
// with the data from the specified map[Complex64]Rune.
func ToConMapComplex64Rune(data map[complex64]rune) *ConMapComplex64Rune {
	if data == nil {
		data = make(map[complex64]rune)
	}
	return &ConMapComplex64Rune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given complex64 key.
func (cm *ConMapComplex64Rune) Get(k complex64) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Rune) GetOK(k complex64) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified complex64 key.
func (cm *ConMapComplex64Rune) Set(k complex64, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Rune) Delete(k complex64) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given complex64 key.
func (cm *ConMapComplex64Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS String=BUILTINS"

// ConMapComplex64String is a concurrent safe wrapper around a
// map[Complex64]String.
type ConMapComplex64String struct {
	// M is the underlying map[Complex64]String.
	M map[complex64]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64String creates a new concurrent safe map storing string values,
// for complex64 keys.
func NewConMapComplex64String() *ConMapComplex64String {
	return ToConMapComplex64String(nil)
}

// ToConMapComplex64String creates a new ConMapComplex64String prepopulated
// with the data from the specified map[Complex64]String.
func ToConMapComplex64String(data map[complex64]string) *ConMapComplex64String {
	if data == nil {
		data = make(map[complex64]string)
	}
	return &ConMapComplex64String{M: data}
}

//var nilString string

// Get gets the string value for the given complex64 key.
func (cm *ConMapComplex64String) Get(k complex64) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64String) GetOK(k complex64) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified complex64 key.
func (cm *ConMapComplex64String) Set(k complex64, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64String) Delete(k complex64) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given complex64 key.
func (cm *ConMapComplex64String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Uint=BUILTINS"

// ConMapComplex64Uint is a concurrent safe wrapper around a
// map[Complex64]Uint.
type ConMapComplex64Uint struct {
	// M is the underlying map[Complex64]Uint.
	M map[complex64]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Uint creates a new concurrent safe map storing uint values,
// for complex64 keys.
func NewConMapComplex64Uint() *ConMapComplex64Uint {
	return ToConMapComplex64Uint(nil)
}

// ToConMapComplex64Uint creates a new ConMapComplex64Uint prepopulated
// with the data from the specified map[Complex64]Uint.
func ToConMapComplex64Uint(data map[complex64]uint) *ConMapComplex64Uint {
	if data == nil {
		data = make(map[complex64]uint)
	}
	return &ConMapComplex64Uint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given complex64 key.
func (cm *ConMapComplex64Uint) Get(k complex64) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Uint) GetOK(k complex64) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified complex64 key.
func (cm *ConMapComplex64Uint) Set(k complex64, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Uint) Delete(k complex64) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given complex64 key.
func (cm *ConMapComplex64Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Uint16=BUILTINS"

// ConMapComplex64Uint16 is a concurrent safe wrapper around a
// map[Complex64]Uint16.
type ConMapComplex64Uint16 struct {
	// M is the underlying map[Complex64]Uint16.
	M map[complex64]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Uint16 creates a new concurrent safe map storing uint16 values,
// for complex64 keys.
func NewConMapComplex64Uint16() *ConMapComplex64Uint16 {
	return ToConMapComplex64Uint16(nil)
}

// ToConMapComplex64Uint16 creates a new ConMapComplex64Uint16 prepopulated
// with the data from the specified map[Complex64]Uint16.
func ToConMapComplex64Uint16(data map[complex64]uint16) *ConMapComplex64Uint16 {
	if data == nil {
		data = make(map[complex64]uint16)
	}
	return &ConMapComplex64Uint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given complex64 key.
func (cm *ConMapComplex64Uint16) Get(k complex64) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Uint16) GetOK(k complex64) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified complex64 key.
func (cm *ConMapComplex64Uint16) Set(k complex64, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Uint16) Delete(k complex64) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given complex64 key.
func (cm *ConMapComplex64Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Uint32=BUILTINS"

// ConMapComplex64Uint32 is a concurrent safe wrapper around a
// map[Complex64]Uint32.
type ConMapComplex64Uint32 struct {
	// M is the underlying map[Complex64]Uint32.
	M map[complex64]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Uint32 creates a new concurrent safe map storing uint32 values,
// for complex64 keys.
func NewConMapComplex64Uint32() *ConMapComplex64Uint32 {
	return ToConMapComplex64Uint32(nil)
}

// ToConMapComplex64Uint32 creates a new ConMapComplex64Uint32 prepopulated
// with the data from the specified map[Complex64]Uint32.
func ToConMapComplex64Uint32(data map[complex64]uint32) *ConMapComplex64Uint32 {
	if data == nil {
		data = make(map[complex64]uint32)
	}
	return &ConMapComplex64Uint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given complex64 key.
func (cm *ConMapComplex64Uint32) Get(k complex64) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Uint32) GetOK(k complex64) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified complex64 key.
func (cm *ConMapComplex64Uint32) Set(k complex64, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Uint32) Delete(k complex64) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given complex64 key.
func (cm *ConMapComplex64Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Uint64=BUILTINS"

// ConMapComplex64Uint64 is a concurrent safe wrapper around a
// map[Complex64]Uint64.
type ConMapComplex64Uint64 struct {
	// M is the underlying map[Complex64]Uint64.
	M map[complex64]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Uint64 creates a new concurrent safe map storing uint64 values,
// for complex64 keys.
func NewConMapComplex64Uint64() *ConMapComplex64Uint64 {
	return ToConMapComplex64Uint64(nil)
}

// ToConMapComplex64Uint64 creates a new ConMapComplex64Uint64 prepopulated
// with the data from the specified map[Complex64]Uint64.
func ToConMapComplex64Uint64(data map[complex64]uint64) *ConMapComplex64Uint64 {
	if data == nil {
		data = make(map[complex64]uint64)
	}
	return &ConMapComplex64Uint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given complex64 key.
func (cm *ConMapComplex64Uint64) Get(k complex64) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Uint64) GetOK(k complex64) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified complex64 key.
func (cm *ConMapComplex64Uint64) Set(k complex64, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Uint64) Delete(k complex64) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given complex64 key.
func (cm *ConMapComplex64Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Uint8=BUILTINS"

// ConMapComplex64Uint8 is a concurrent safe wrapper around a
// map[Complex64]Uint8.
type ConMapComplex64Uint8 struct {
	// M is the underlying map[Complex64]Uint8.
	M map[complex64]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Uint8 creates a new concurrent safe map storing uint8 values,
// for complex64 keys.
func NewConMapComplex64Uint8() *ConMapComplex64Uint8 {
	return ToConMapComplex64Uint8(nil)
}

// ToConMapComplex64Uint8 creates a new ConMapComplex64Uint8 prepopulated
// with the data from the specified map[Complex64]Uint8.
func ToConMapComplex64Uint8(data map[complex64]uint8) *ConMapComplex64Uint8 {
	if data == nil {
		data = make(map[complex64]uint8)
	}
	return &ConMapComplex64Uint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given complex64 key.
func (cm *ConMapComplex64Uint8) Get(k complex64) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Uint8) GetOK(k complex64) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified complex64 key.
func (cm *ConMapComplex64Uint8) Set(k complex64, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Uint8) Delete(k complex64) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given complex64 key.
func (cm *ConMapComplex64Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Complex64=BUILTINS Uintptr=BUILTINS"

// ConMapComplex64Uintptr is a concurrent safe wrapper around a
// map[Complex64]Uintptr.
type ConMapComplex64Uintptr struct {
	// M is the underlying map[Complex64]Uintptr.
	M map[complex64]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapComplex64Uintptr creates a new concurrent safe map storing uintptr values,
// for complex64 keys.
func NewConMapComplex64Uintptr() *ConMapComplex64Uintptr {
	return ToConMapComplex64Uintptr(nil)
}

// ToConMapComplex64Uintptr creates a new ConMapComplex64Uintptr prepopulated
// with the data from the specified map[Complex64]Uintptr.
func ToConMapComplex64Uintptr(data map[complex64]uintptr) *ConMapComplex64Uintptr {
	if data == nil {
		data = make(map[complex64]uintptr)
	}
	return &ConMapComplex64Uintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given complex64 key.
func (cm *ConMapComplex64Uintptr) Get(k complex64) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given complex64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapComplex64Uintptr) GetOK(k complex64) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified complex64 key.
func (cm *ConMapComplex64Uintptr) Set(k complex64, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified complex64 key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapComplex64Uintptr) Delete(k complex64) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given complex64 key.
func (cm *ConMapComplex64Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Bool=BUILTINS"

// ConMapErrorBool is a concurrent safe wrapper around a
// map[Error]Bool.
type ConMapErrorBool struct {
	// M is the underlying map[Error]Bool.
	M map[error]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorBool creates a new concurrent safe map storing bool values,
// for error keys.
func NewConMapErrorBool() *ConMapErrorBool {
	return ToConMapErrorBool(nil)
}

// ToConMapErrorBool creates a new ConMapErrorBool prepopulated
// with the data from the specified map[Error]Bool.
func ToConMapErrorBool(data map[error]bool) *ConMapErrorBool {
	if data == nil {
		data = make(map[error]bool)
	}
	return &ConMapErrorBool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given error key.
func (cm *ConMapErrorBool) Get(k error) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorBool) GetOK(k error) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified error key.
func (cm *ConMapErrorBool) Set(k error, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorBool) Delete(k error) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given error key.
func (cm *ConMapErrorBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Byte=BUILTINS"

// ConMapErrorByte is a concurrent safe wrapper around a
// map[Error]Byte.
type ConMapErrorByte struct {
	// M is the underlying map[Error]Byte.
	M map[error]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorByte creates a new concurrent safe map storing byte values,
// for error keys.
func NewConMapErrorByte() *ConMapErrorByte {
	return ToConMapErrorByte(nil)
}

// ToConMapErrorByte creates a new ConMapErrorByte prepopulated
// with the data from the specified map[Error]Byte.
func ToConMapErrorByte(data map[error]byte) *ConMapErrorByte {
	if data == nil {
		data = make(map[error]byte)
	}
	return &ConMapErrorByte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given error key.
func (cm *ConMapErrorByte) Get(k error) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorByte) GetOK(k error) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified error key.
func (cm *ConMapErrorByte) Set(k error, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorByte) Delete(k error) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given error key.
func (cm *ConMapErrorByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Complex128=BUILTINS"

// ConMapErrorComplex128 is a concurrent safe wrapper around a
// map[Error]Complex128.
type ConMapErrorComplex128 struct {
	// M is the underlying map[Error]Complex128.
	M map[error]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorComplex128 creates a new concurrent safe map storing complex128 values,
// for error keys.
func NewConMapErrorComplex128() *ConMapErrorComplex128 {
	return ToConMapErrorComplex128(nil)
}

// ToConMapErrorComplex128 creates a new ConMapErrorComplex128 prepopulated
// with the data from the specified map[Error]Complex128.
func ToConMapErrorComplex128(data map[error]complex128) *ConMapErrorComplex128 {
	if data == nil {
		data = make(map[error]complex128)
	}
	return &ConMapErrorComplex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given error key.
func (cm *ConMapErrorComplex128) Get(k error) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorComplex128) GetOK(k error) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified error key.
func (cm *ConMapErrorComplex128) Set(k error, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorComplex128) Delete(k error) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given error key.
func (cm *ConMapErrorComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Complex64=BUILTINS"

// ConMapErrorComplex64 is a concurrent safe wrapper around a
// map[Error]Complex64.
type ConMapErrorComplex64 struct {
	// M is the underlying map[Error]Complex64.
	M map[error]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorComplex64 creates a new concurrent safe map storing complex64 values,
// for error keys.
func NewConMapErrorComplex64() *ConMapErrorComplex64 {
	return ToConMapErrorComplex64(nil)
}

// ToConMapErrorComplex64 creates a new ConMapErrorComplex64 prepopulated
// with the data from the specified map[Error]Complex64.
func ToConMapErrorComplex64(data map[error]complex64) *ConMapErrorComplex64 {
	if data == nil {
		data = make(map[error]complex64)
	}
	return &ConMapErrorComplex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given error key.
func (cm *ConMapErrorComplex64) Get(k error) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorComplex64) GetOK(k error) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified error key.
func (cm *ConMapErrorComplex64) Set(k error, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorComplex64) Delete(k error) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given error key.
func (cm *ConMapErrorComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Error=BUILTINS"

// ConMapErrorError is a concurrent safe wrapper around a
// map[Error]Error.
type ConMapErrorError struct {
	// M is the underlying map[Error]Error.
	M map[error]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorError creates a new concurrent safe map storing error values,
// for error keys.
func NewConMapErrorError() *ConMapErrorError {
	return ToConMapErrorError(nil)
}

// ToConMapErrorError creates a new ConMapErrorError prepopulated
// with the data from the specified map[Error]Error.
func ToConMapErrorError(data map[error]error) *ConMapErrorError {
	if data == nil {
		data = make(map[error]error)
	}
	return &ConMapErrorError{M: data}
}

//var nilError error

// Get gets the error value for the given error key.
func (cm *ConMapErrorError) Get(k error) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorError) GetOK(k error) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified error key.
func (cm *ConMapErrorError) Set(k error, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorError) Delete(k error) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given error key.
func (cm *ConMapErrorError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Float32=BUILTINS"

// ConMapErrorFloat32 is a concurrent safe wrapper around a
// map[Error]Float32.
type ConMapErrorFloat32 struct {
	// M is the underlying map[Error]Float32.
	M map[error]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorFloat32 creates a new concurrent safe map storing float32 values,
// for error keys.
func NewConMapErrorFloat32() *ConMapErrorFloat32 {
	return ToConMapErrorFloat32(nil)
}

// ToConMapErrorFloat32 creates a new ConMapErrorFloat32 prepopulated
// with the data from the specified map[Error]Float32.
func ToConMapErrorFloat32(data map[error]float32) *ConMapErrorFloat32 {
	if data == nil {
		data = make(map[error]float32)
	}
	return &ConMapErrorFloat32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given error key.
func (cm *ConMapErrorFloat32) Get(k error) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorFloat32) GetOK(k error) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified error key.
func (cm *ConMapErrorFloat32) Set(k error, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorFloat32) Delete(k error) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given error key.
func (cm *ConMapErrorFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Float64=BUILTINS"

// ConMapErrorFloat64 is a concurrent safe wrapper around a
// map[Error]Float64.
type ConMapErrorFloat64 struct {
	// M is the underlying map[Error]Float64.
	M map[error]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorFloat64 creates a new concurrent safe map storing float64 values,
// for error keys.
func NewConMapErrorFloat64() *ConMapErrorFloat64 {
	return ToConMapErrorFloat64(nil)
}

// ToConMapErrorFloat64 creates a new ConMapErrorFloat64 prepopulated
// with the data from the specified map[Error]Float64.
func ToConMapErrorFloat64(data map[error]float64) *ConMapErrorFloat64 {
	if data == nil {
		data = make(map[error]float64)
	}
	return &ConMapErrorFloat64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given error key.
func (cm *ConMapErrorFloat64) Get(k error) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorFloat64) GetOK(k error) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified error key.
func (cm *ConMapErrorFloat64) Set(k error, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorFloat64) Delete(k error) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given error key.
func (cm *ConMapErrorFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Int=BUILTINS"

// ConMapErrorInt is a concurrent safe wrapper around a
// map[Error]Int.
type ConMapErrorInt struct {
	// M is the underlying map[Error]Int.
	M map[error]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorInt creates a new concurrent safe map storing int values,
// for error keys.
func NewConMapErrorInt() *ConMapErrorInt {
	return ToConMapErrorInt(nil)
}

// ToConMapErrorInt creates a new ConMapErrorInt prepopulated
// with the data from the specified map[Error]Int.
func ToConMapErrorInt(data map[error]int) *ConMapErrorInt {
	if data == nil {
		data = make(map[error]int)
	}
	return &ConMapErrorInt{M: data}
}

//var nilInt int

// Get gets the int value for the given error key.
func (cm *ConMapErrorInt) Get(k error) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorInt) GetOK(k error) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified error key.
func (cm *ConMapErrorInt) Set(k error, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorInt) Delete(k error) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given error key.
func (cm *ConMapErrorInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Int16=BUILTINS"

// ConMapErrorInt16 is a concurrent safe wrapper around a
// map[Error]Int16.
type ConMapErrorInt16 struct {
	// M is the underlying map[Error]Int16.
	M map[error]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorInt16 creates a new concurrent safe map storing int16 values,
// for error keys.
func NewConMapErrorInt16() *ConMapErrorInt16 {
	return ToConMapErrorInt16(nil)
}

// ToConMapErrorInt16 creates a new ConMapErrorInt16 prepopulated
// with the data from the specified map[Error]Int16.
func ToConMapErrorInt16(data map[error]int16) *ConMapErrorInt16 {
	if data == nil {
		data = make(map[error]int16)
	}
	return &ConMapErrorInt16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given error key.
func (cm *ConMapErrorInt16) Get(k error) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorInt16) GetOK(k error) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified error key.
func (cm *ConMapErrorInt16) Set(k error, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorInt16) Delete(k error) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given error key.
func (cm *ConMapErrorInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Int32=BUILTINS"

// ConMapErrorInt32 is a concurrent safe wrapper around a
// map[Error]Int32.
type ConMapErrorInt32 struct {
	// M is the underlying map[Error]Int32.
	M map[error]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorInt32 creates a new concurrent safe map storing int32 values,
// for error keys.
func NewConMapErrorInt32() *ConMapErrorInt32 {
	return ToConMapErrorInt32(nil)
}

// ToConMapErrorInt32 creates a new ConMapErrorInt32 prepopulated
// with the data from the specified map[Error]Int32.
func ToConMapErrorInt32(data map[error]int32) *ConMapErrorInt32 {
	if data == nil {
		data = make(map[error]int32)
	}
	return &ConMapErrorInt32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given error key.
func (cm *ConMapErrorInt32) Get(k error) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorInt32) GetOK(k error) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified error key.
func (cm *ConMapErrorInt32) Set(k error, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorInt32) Delete(k error) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given error key.
func (cm *ConMapErrorInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Int64=BUILTINS"

// ConMapErrorInt64 is a concurrent safe wrapper around a
// map[Error]Int64.
type ConMapErrorInt64 struct {
	// M is the underlying map[Error]Int64.
	M map[error]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorInt64 creates a new concurrent safe map storing int64 values,
// for error keys.
func NewConMapErrorInt64() *ConMapErrorInt64 {
	return ToConMapErrorInt64(nil)
}

// ToConMapErrorInt64 creates a new ConMapErrorInt64 prepopulated
// with the data from the specified map[Error]Int64.
func ToConMapErrorInt64(data map[error]int64) *ConMapErrorInt64 {
	if data == nil {
		data = make(map[error]int64)
	}
	return &ConMapErrorInt64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given error key.
func (cm *ConMapErrorInt64) Get(k error) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorInt64) GetOK(k error) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified error key.
func (cm *ConMapErrorInt64) Set(k error, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorInt64) Delete(k error) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given error key.
func (cm *ConMapErrorInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Int8=BUILTINS"

// ConMapErrorInt8 is a concurrent safe wrapper around a
// map[Error]Int8.
type ConMapErrorInt8 struct {
	// M is the underlying map[Error]Int8.
	M map[error]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorInt8 creates a new concurrent safe map storing int8 values,
// for error keys.
func NewConMapErrorInt8() *ConMapErrorInt8 {
	return ToConMapErrorInt8(nil)
}

// ToConMapErrorInt8 creates a new ConMapErrorInt8 prepopulated
// with the data from the specified map[Error]Int8.
func ToConMapErrorInt8(data map[error]int8) *ConMapErrorInt8 {
	if data == nil {
		data = make(map[error]int8)
	}
	return &ConMapErrorInt8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given error key.
func (cm *ConMapErrorInt8) Get(k error) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorInt8) GetOK(k error) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified error key.
func (cm *ConMapErrorInt8) Set(k error, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorInt8) Delete(k error) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given error key.
func (cm *ConMapErrorInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Rune=BUILTINS"

// ConMapErrorRune is a concurrent safe wrapper around a
// map[Error]Rune.
type ConMapErrorRune struct {
	// M is the underlying map[Error]Rune.
	M map[error]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorRune creates a new concurrent safe map storing rune values,
// for error keys.
func NewConMapErrorRune() *ConMapErrorRune {
	return ToConMapErrorRune(nil)
}

// ToConMapErrorRune creates a new ConMapErrorRune prepopulated
// with the data from the specified map[Error]Rune.
func ToConMapErrorRune(data map[error]rune) *ConMapErrorRune {
	if data == nil {
		data = make(map[error]rune)
	}
	return &ConMapErrorRune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given error key.
func (cm *ConMapErrorRune) Get(k error) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorRune) GetOK(k error) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified error key.
func (cm *ConMapErrorRune) Set(k error, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorRune) Delete(k error) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given error key.
func (cm *ConMapErrorRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS String=BUILTINS"

// ConMapErrorString is a concurrent safe wrapper around a
// map[Error]String.
type ConMapErrorString struct {
	// M is the underlying map[Error]String.
	M map[error]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorString creates a new concurrent safe map storing string values,
// for error keys.
func NewConMapErrorString() *ConMapErrorString {
	return ToConMapErrorString(nil)
}

// ToConMapErrorString creates a new ConMapErrorString prepopulated
// with the data from the specified map[Error]String.
func ToConMapErrorString(data map[error]string) *ConMapErrorString {
	if data == nil {
		data = make(map[error]string)
	}
	return &ConMapErrorString{M: data}
}

//var nilString string

// Get gets the string value for the given error key.
func (cm *ConMapErrorString) Get(k error) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorString) GetOK(k error) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified error key.
func (cm *ConMapErrorString) Set(k error, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorString) Delete(k error) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given error key.
func (cm *ConMapErrorString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Uint=BUILTINS"

// ConMapErrorUint is a concurrent safe wrapper around a
// map[Error]Uint.
type ConMapErrorUint struct {
	// M is the underlying map[Error]Uint.
	M map[error]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorUint creates a new concurrent safe map storing uint values,
// for error keys.
func NewConMapErrorUint() *ConMapErrorUint {
	return ToConMapErrorUint(nil)
}

// ToConMapErrorUint creates a new ConMapErrorUint prepopulated
// with the data from the specified map[Error]Uint.
func ToConMapErrorUint(data map[error]uint) *ConMapErrorUint {
	if data == nil {
		data = make(map[error]uint)
	}
	return &ConMapErrorUint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given error key.
func (cm *ConMapErrorUint) Get(k error) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorUint) GetOK(k error) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified error key.
func (cm *ConMapErrorUint) Set(k error, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorUint) Delete(k error) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given error key.
func (cm *ConMapErrorUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Uint16=BUILTINS"

// ConMapErrorUint16 is a concurrent safe wrapper around a
// map[Error]Uint16.
type ConMapErrorUint16 struct {
	// M is the underlying map[Error]Uint16.
	M map[error]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorUint16 creates a new concurrent safe map storing uint16 values,
// for error keys.
func NewConMapErrorUint16() *ConMapErrorUint16 {
	return ToConMapErrorUint16(nil)
}

// ToConMapErrorUint16 creates a new ConMapErrorUint16 prepopulated
// with the data from the specified map[Error]Uint16.
func ToConMapErrorUint16(data map[error]uint16) *ConMapErrorUint16 {
	if data == nil {
		data = make(map[error]uint16)
	}
	return &ConMapErrorUint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given error key.
func (cm *ConMapErrorUint16) Get(k error) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorUint16) GetOK(k error) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified error key.
func (cm *ConMapErrorUint16) Set(k error, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorUint16) Delete(k error) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given error key.
func (cm *ConMapErrorUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Uint32=BUILTINS"

// ConMapErrorUint32 is a concurrent safe wrapper around a
// map[Error]Uint32.
type ConMapErrorUint32 struct {
	// M is the underlying map[Error]Uint32.
	M map[error]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorUint32 creates a new concurrent safe map storing uint32 values,
// for error keys.
func NewConMapErrorUint32() *ConMapErrorUint32 {
	return ToConMapErrorUint32(nil)
}

// ToConMapErrorUint32 creates a new ConMapErrorUint32 prepopulated
// with the data from the specified map[Error]Uint32.
func ToConMapErrorUint32(data map[error]uint32) *ConMapErrorUint32 {
	if data == nil {
		data = make(map[error]uint32)
	}
	return &ConMapErrorUint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given error key.
func (cm *ConMapErrorUint32) Get(k error) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorUint32) GetOK(k error) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified error key.
func (cm *ConMapErrorUint32) Set(k error, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorUint32) Delete(k error) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given error key.
func (cm *ConMapErrorUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Uint64=BUILTINS"

// ConMapErrorUint64 is a concurrent safe wrapper around a
// map[Error]Uint64.
type ConMapErrorUint64 struct {
	// M is the underlying map[Error]Uint64.
	M map[error]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorUint64 creates a new concurrent safe map storing uint64 values,
// for error keys.
func NewConMapErrorUint64() *ConMapErrorUint64 {
	return ToConMapErrorUint64(nil)
}

// ToConMapErrorUint64 creates a new ConMapErrorUint64 prepopulated
// with the data from the specified map[Error]Uint64.
func ToConMapErrorUint64(data map[error]uint64) *ConMapErrorUint64 {
	if data == nil {
		data = make(map[error]uint64)
	}
	return &ConMapErrorUint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given error key.
func (cm *ConMapErrorUint64) Get(k error) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorUint64) GetOK(k error) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified error key.
func (cm *ConMapErrorUint64) Set(k error, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorUint64) Delete(k error) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given error key.
func (cm *ConMapErrorUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Uint8=BUILTINS"

// ConMapErrorUint8 is a concurrent safe wrapper around a
// map[Error]Uint8.
type ConMapErrorUint8 struct {
	// M is the underlying map[Error]Uint8.
	M map[error]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorUint8 creates a new concurrent safe map storing uint8 values,
// for error keys.
func NewConMapErrorUint8() *ConMapErrorUint8 {
	return ToConMapErrorUint8(nil)
}

// ToConMapErrorUint8 creates a new ConMapErrorUint8 prepopulated
// with the data from the specified map[Error]Uint8.
func ToConMapErrorUint8(data map[error]uint8) *ConMapErrorUint8 {
	if data == nil {
		data = make(map[error]uint8)
	}
	return &ConMapErrorUint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given error key.
func (cm *ConMapErrorUint8) Get(k error) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorUint8) GetOK(k error) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified error key.
func (cm *ConMapErrorUint8) Set(k error, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorUint8) Delete(k error) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given error key.
func (cm *ConMapErrorUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Error=BUILTINS Uintptr=BUILTINS"

// ConMapErrorUintptr is a concurrent safe wrapper around a
// map[Error]Uintptr.
type ConMapErrorUintptr struct {
	// M is the underlying map[Error]Uintptr.
	M map[error]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapErrorUintptr creates a new concurrent safe map storing uintptr values,
// for error keys.
func NewConMapErrorUintptr() *ConMapErrorUintptr {
	return ToConMapErrorUintptr(nil)
}

// ToConMapErrorUintptr creates a new ConMapErrorUintptr prepopulated
// with the data from the specified map[Error]Uintptr.
func ToConMapErrorUintptr(data map[error]uintptr) *ConMapErrorUintptr {
	if data == nil {
		data = make(map[error]uintptr)
	}
	return &ConMapErrorUintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given error key.
func (cm *ConMapErrorUintptr) Get(k error) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given error key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapErrorUintptr) GetOK(k error) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified error key.
func (cm *ConMapErrorUintptr) Set(k error, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified error key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapErrorUintptr) Delete(k error) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given error key.
func (cm *ConMapErrorUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Bool=BUILTINS"

// ConMapFloat32Bool is a concurrent safe wrapper around a
// map[Float32]Bool.
type ConMapFloat32Bool struct {
	// M is the underlying map[Float32]Bool.
	M map[float32]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Bool creates a new concurrent safe map storing bool values,
// for float32 keys.
func NewConMapFloat32Bool() *ConMapFloat32Bool {
	return ToConMapFloat32Bool(nil)
}

// ToConMapFloat32Bool creates a new ConMapFloat32Bool prepopulated
// with the data from the specified map[Float32]Bool.
func ToConMapFloat32Bool(data map[float32]bool) *ConMapFloat32Bool {
	if data == nil {
		data = make(map[float32]bool)
	}
	return &ConMapFloat32Bool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given float32 key.
func (cm *ConMapFloat32Bool) Get(k float32) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Bool) GetOK(k float32) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified float32 key.
func (cm *ConMapFloat32Bool) Set(k float32, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Bool) Delete(k float32) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given float32 key.
func (cm *ConMapFloat32Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Byte=BUILTINS"

// ConMapFloat32Byte is a concurrent safe wrapper around a
// map[Float32]Byte.
type ConMapFloat32Byte struct {
	// M is the underlying map[Float32]Byte.
	M map[float32]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Byte creates a new concurrent safe map storing byte values,
// for float32 keys.
func NewConMapFloat32Byte() *ConMapFloat32Byte {
	return ToConMapFloat32Byte(nil)
}

// ToConMapFloat32Byte creates a new ConMapFloat32Byte prepopulated
// with the data from the specified map[Float32]Byte.
func ToConMapFloat32Byte(data map[float32]byte) *ConMapFloat32Byte {
	if data == nil {
		data = make(map[float32]byte)
	}
	return &ConMapFloat32Byte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given float32 key.
func (cm *ConMapFloat32Byte) Get(k float32) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Byte) GetOK(k float32) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified float32 key.
func (cm *ConMapFloat32Byte) Set(k float32, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Byte) Delete(k float32) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given float32 key.
func (cm *ConMapFloat32Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Complex128=BUILTINS"

// ConMapFloat32Complex128 is a concurrent safe wrapper around a
// map[Float32]Complex128.
type ConMapFloat32Complex128 struct {
	// M is the underlying map[Float32]Complex128.
	M map[float32]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Complex128 creates a new concurrent safe map storing complex128 values,
// for float32 keys.
func NewConMapFloat32Complex128() *ConMapFloat32Complex128 {
	return ToConMapFloat32Complex128(nil)
}

// ToConMapFloat32Complex128 creates a new ConMapFloat32Complex128 prepopulated
// with the data from the specified map[Float32]Complex128.
func ToConMapFloat32Complex128(data map[float32]complex128) *ConMapFloat32Complex128 {
	if data == nil {
		data = make(map[float32]complex128)
	}
	return &ConMapFloat32Complex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given float32 key.
func (cm *ConMapFloat32Complex128) Get(k float32) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Complex128) GetOK(k float32) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified float32 key.
func (cm *ConMapFloat32Complex128) Set(k float32, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Complex128) Delete(k float32) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given float32 key.
func (cm *ConMapFloat32Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Complex64=BUILTINS"

// ConMapFloat32Complex64 is a concurrent safe wrapper around a
// map[Float32]Complex64.
type ConMapFloat32Complex64 struct {
	// M is the underlying map[Float32]Complex64.
	M map[float32]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Complex64 creates a new concurrent safe map storing complex64 values,
// for float32 keys.
func NewConMapFloat32Complex64() *ConMapFloat32Complex64 {
	return ToConMapFloat32Complex64(nil)
}

// ToConMapFloat32Complex64 creates a new ConMapFloat32Complex64 prepopulated
// with the data from the specified map[Float32]Complex64.
func ToConMapFloat32Complex64(data map[float32]complex64) *ConMapFloat32Complex64 {
	if data == nil {
		data = make(map[float32]complex64)
	}
	return &ConMapFloat32Complex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given float32 key.
func (cm *ConMapFloat32Complex64) Get(k float32) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Complex64) GetOK(k float32) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified float32 key.
func (cm *ConMapFloat32Complex64) Set(k float32, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Complex64) Delete(k float32) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given float32 key.
func (cm *ConMapFloat32Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Error=BUILTINS"

// ConMapFloat32Error is a concurrent safe wrapper around a
// map[Float32]Error.
type ConMapFloat32Error struct {
	// M is the underlying map[Float32]Error.
	M map[float32]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Error creates a new concurrent safe map storing error values,
// for float32 keys.
func NewConMapFloat32Error() *ConMapFloat32Error {
	return ToConMapFloat32Error(nil)
}

// ToConMapFloat32Error creates a new ConMapFloat32Error prepopulated
// with the data from the specified map[Float32]Error.
func ToConMapFloat32Error(data map[float32]error) *ConMapFloat32Error {
	if data == nil {
		data = make(map[float32]error)
	}
	return &ConMapFloat32Error{M: data}
}

//var nilError error

// Get gets the error value for the given float32 key.
func (cm *ConMapFloat32Error) Get(k float32) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Error) GetOK(k float32) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified float32 key.
func (cm *ConMapFloat32Error) Set(k float32, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Error) Delete(k float32) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given float32 key.
func (cm *ConMapFloat32Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Float32=BUILTINS"

// ConMapFloat32Float32 is a concurrent safe wrapper around a
// map[Float32]Float32.
type ConMapFloat32Float32 struct {
	// M is the underlying map[Float32]Float32.
	M map[float32]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Float32 creates a new concurrent safe map storing float32 values,
// for float32 keys.
func NewConMapFloat32Float32() *ConMapFloat32Float32 {
	return ToConMapFloat32Float32(nil)
}

// ToConMapFloat32Float32 creates a new ConMapFloat32Float32 prepopulated
// with the data from the specified map[Float32]Float32.
func ToConMapFloat32Float32(data map[float32]float32) *ConMapFloat32Float32 {
	if data == nil {
		data = make(map[float32]float32)
	}
	return &ConMapFloat32Float32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given float32 key.
func (cm *ConMapFloat32Float32) Get(k float32) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Float32) GetOK(k float32) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified float32 key.
func (cm *ConMapFloat32Float32) Set(k float32, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Float32) Delete(k float32) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given float32 key.
func (cm *ConMapFloat32Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Float64=BUILTINS"

// ConMapFloat32Float64 is a concurrent safe wrapper around a
// map[Float32]Float64.
type ConMapFloat32Float64 struct {
	// M is the underlying map[Float32]Float64.
	M map[float32]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Float64 creates a new concurrent safe map storing float64 values,
// for float32 keys.
func NewConMapFloat32Float64() *ConMapFloat32Float64 {
	return ToConMapFloat32Float64(nil)
}

// ToConMapFloat32Float64 creates a new ConMapFloat32Float64 prepopulated
// with the data from the specified map[Float32]Float64.
func ToConMapFloat32Float64(data map[float32]float64) *ConMapFloat32Float64 {
	if data == nil {
		data = make(map[float32]float64)
	}
	return &ConMapFloat32Float64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given float32 key.
func (cm *ConMapFloat32Float64) Get(k float32) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Float64) GetOK(k float32) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified float32 key.
func (cm *ConMapFloat32Float64) Set(k float32, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Float64) Delete(k float32) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given float32 key.
func (cm *ConMapFloat32Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Int=BUILTINS"

// ConMapFloat32Int is a concurrent safe wrapper around a
// map[Float32]Int.
type ConMapFloat32Int struct {
	// M is the underlying map[Float32]Int.
	M map[float32]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Int creates a new concurrent safe map storing int values,
// for float32 keys.
func NewConMapFloat32Int() *ConMapFloat32Int {
	return ToConMapFloat32Int(nil)
}

// ToConMapFloat32Int creates a new ConMapFloat32Int prepopulated
// with the data from the specified map[Float32]Int.
func ToConMapFloat32Int(data map[float32]int) *ConMapFloat32Int {
	if data == nil {
		data = make(map[float32]int)
	}
	return &ConMapFloat32Int{M: data}
}

//var nilInt int

// Get gets the int value for the given float32 key.
func (cm *ConMapFloat32Int) Get(k float32) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Int) GetOK(k float32) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified float32 key.
func (cm *ConMapFloat32Int) Set(k float32, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Int) Delete(k float32) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given float32 key.
func (cm *ConMapFloat32Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Int16=BUILTINS"

// ConMapFloat32Int16 is a concurrent safe wrapper around a
// map[Float32]Int16.
type ConMapFloat32Int16 struct {
	// M is the underlying map[Float32]Int16.
	M map[float32]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Int16 creates a new concurrent safe map storing int16 values,
// for float32 keys.
func NewConMapFloat32Int16() *ConMapFloat32Int16 {
	return ToConMapFloat32Int16(nil)
}

// ToConMapFloat32Int16 creates a new ConMapFloat32Int16 prepopulated
// with the data from the specified map[Float32]Int16.
func ToConMapFloat32Int16(data map[float32]int16) *ConMapFloat32Int16 {
	if data == nil {
		data = make(map[float32]int16)
	}
	return &ConMapFloat32Int16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given float32 key.
func (cm *ConMapFloat32Int16) Get(k float32) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Int16) GetOK(k float32) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified float32 key.
func (cm *ConMapFloat32Int16) Set(k float32, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Int16) Delete(k float32) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given float32 key.
func (cm *ConMapFloat32Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Int32=BUILTINS"

// ConMapFloat32Int32 is a concurrent safe wrapper around a
// map[Float32]Int32.
type ConMapFloat32Int32 struct {
	// M is the underlying map[Float32]Int32.
	M map[float32]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Int32 creates a new concurrent safe map storing int32 values,
// for float32 keys.
func NewConMapFloat32Int32() *ConMapFloat32Int32 {
	return ToConMapFloat32Int32(nil)
}

// ToConMapFloat32Int32 creates a new ConMapFloat32Int32 prepopulated
// with the data from the specified map[Float32]Int32.
func ToConMapFloat32Int32(data map[float32]int32) *ConMapFloat32Int32 {
	if data == nil {
		data = make(map[float32]int32)
	}
	return &ConMapFloat32Int32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given float32 key.
func (cm *ConMapFloat32Int32) Get(k float32) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Int32) GetOK(k float32) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified float32 key.
func (cm *ConMapFloat32Int32) Set(k float32, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Int32) Delete(k float32) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given float32 key.
func (cm *ConMapFloat32Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Int64=BUILTINS"

// ConMapFloat32Int64 is a concurrent safe wrapper around a
// map[Float32]Int64.
type ConMapFloat32Int64 struct {
	// M is the underlying map[Float32]Int64.
	M map[float32]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Int64 creates a new concurrent safe map storing int64 values,
// for float32 keys.
func NewConMapFloat32Int64() *ConMapFloat32Int64 {
	return ToConMapFloat32Int64(nil)
}

// ToConMapFloat32Int64 creates a new ConMapFloat32Int64 prepopulated
// with the data from the specified map[Float32]Int64.
func ToConMapFloat32Int64(data map[float32]int64) *ConMapFloat32Int64 {
	if data == nil {
		data = make(map[float32]int64)
	}
	return &ConMapFloat32Int64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given float32 key.
func (cm *ConMapFloat32Int64) Get(k float32) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Int64) GetOK(k float32) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified float32 key.
func (cm *ConMapFloat32Int64) Set(k float32, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Int64) Delete(k float32) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given float32 key.
func (cm *ConMapFloat32Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Int8=BUILTINS"

// ConMapFloat32Int8 is a concurrent safe wrapper around a
// map[Float32]Int8.
type ConMapFloat32Int8 struct {
	// M is the underlying map[Float32]Int8.
	M map[float32]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Int8 creates a new concurrent safe map storing int8 values,
// for float32 keys.
func NewConMapFloat32Int8() *ConMapFloat32Int8 {
	return ToConMapFloat32Int8(nil)
}

// ToConMapFloat32Int8 creates a new ConMapFloat32Int8 prepopulated
// with the data from the specified map[Float32]Int8.
func ToConMapFloat32Int8(data map[float32]int8) *ConMapFloat32Int8 {
	if data == nil {
		data = make(map[float32]int8)
	}
	return &ConMapFloat32Int8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given float32 key.
func (cm *ConMapFloat32Int8) Get(k float32) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Int8) GetOK(k float32) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified float32 key.
func (cm *ConMapFloat32Int8) Set(k float32, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Int8) Delete(k float32) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given float32 key.
func (cm *ConMapFloat32Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Rune=BUILTINS"

// ConMapFloat32Rune is a concurrent safe wrapper around a
// map[Float32]Rune.
type ConMapFloat32Rune struct {
	// M is the underlying map[Float32]Rune.
	M map[float32]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Rune creates a new concurrent safe map storing rune values,
// for float32 keys.
func NewConMapFloat32Rune() *ConMapFloat32Rune {
	return ToConMapFloat32Rune(nil)
}

// ToConMapFloat32Rune creates a new ConMapFloat32Rune prepopulated
// with the data from the specified map[Float32]Rune.
func ToConMapFloat32Rune(data map[float32]rune) *ConMapFloat32Rune {
	if data == nil {
		data = make(map[float32]rune)
	}
	return &ConMapFloat32Rune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given float32 key.
func (cm *ConMapFloat32Rune) Get(k float32) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Rune) GetOK(k float32) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified float32 key.
func (cm *ConMapFloat32Rune) Set(k float32, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Rune) Delete(k float32) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given float32 key.
func (cm *ConMapFloat32Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS String=BUILTINS"

// ConMapFloat32String is a concurrent safe wrapper around a
// map[Float32]String.
type ConMapFloat32String struct {
	// M is the underlying map[Float32]String.
	M map[float32]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32String creates a new concurrent safe map storing string values,
// for float32 keys.
func NewConMapFloat32String() *ConMapFloat32String {
	return ToConMapFloat32String(nil)
}

// ToConMapFloat32String creates a new ConMapFloat32String prepopulated
// with the data from the specified map[Float32]String.
func ToConMapFloat32String(data map[float32]string) *ConMapFloat32String {
	if data == nil {
		data = make(map[float32]string)
	}
	return &ConMapFloat32String{M: data}
}

//var nilString string

// Get gets the string value for the given float32 key.
func (cm *ConMapFloat32String) Get(k float32) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32String) GetOK(k float32) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified float32 key.
func (cm *ConMapFloat32String) Set(k float32, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32String) Delete(k float32) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given float32 key.
func (cm *ConMapFloat32String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Uint=BUILTINS"

// ConMapFloat32Uint is a concurrent safe wrapper around a
// map[Float32]Uint.
type ConMapFloat32Uint struct {
	// M is the underlying map[Float32]Uint.
	M map[float32]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Uint creates a new concurrent safe map storing uint values,
// for float32 keys.
func NewConMapFloat32Uint() *ConMapFloat32Uint {
	return ToConMapFloat32Uint(nil)
}

// ToConMapFloat32Uint creates a new ConMapFloat32Uint prepopulated
// with the data from the specified map[Float32]Uint.
func ToConMapFloat32Uint(data map[float32]uint) *ConMapFloat32Uint {
	if data == nil {
		data = make(map[float32]uint)
	}
	return &ConMapFloat32Uint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given float32 key.
func (cm *ConMapFloat32Uint) Get(k float32) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Uint) GetOK(k float32) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified float32 key.
func (cm *ConMapFloat32Uint) Set(k float32, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Uint) Delete(k float32) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given float32 key.
func (cm *ConMapFloat32Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Uint16=BUILTINS"

// ConMapFloat32Uint16 is a concurrent safe wrapper around a
// map[Float32]Uint16.
type ConMapFloat32Uint16 struct {
	// M is the underlying map[Float32]Uint16.
	M map[float32]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Uint16 creates a new concurrent safe map storing uint16 values,
// for float32 keys.
func NewConMapFloat32Uint16() *ConMapFloat32Uint16 {
	return ToConMapFloat32Uint16(nil)
}

// ToConMapFloat32Uint16 creates a new ConMapFloat32Uint16 prepopulated
// with the data from the specified map[Float32]Uint16.
func ToConMapFloat32Uint16(data map[float32]uint16) *ConMapFloat32Uint16 {
	if data == nil {
		data = make(map[float32]uint16)
	}
	return &ConMapFloat32Uint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given float32 key.
func (cm *ConMapFloat32Uint16) Get(k float32) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Uint16) GetOK(k float32) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified float32 key.
func (cm *ConMapFloat32Uint16) Set(k float32, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Uint16) Delete(k float32) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given float32 key.
func (cm *ConMapFloat32Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Uint32=BUILTINS"

// ConMapFloat32Uint32 is a concurrent safe wrapper around a
// map[Float32]Uint32.
type ConMapFloat32Uint32 struct {
	// M is the underlying map[Float32]Uint32.
	M map[float32]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Uint32 creates a new concurrent safe map storing uint32 values,
// for float32 keys.
func NewConMapFloat32Uint32() *ConMapFloat32Uint32 {
	return ToConMapFloat32Uint32(nil)
}

// ToConMapFloat32Uint32 creates a new ConMapFloat32Uint32 prepopulated
// with the data from the specified map[Float32]Uint32.
func ToConMapFloat32Uint32(data map[float32]uint32) *ConMapFloat32Uint32 {
	if data == nil {
		data = make(map[float32]uint32)
	}
	return &ConMapFloat32Uint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given float32 key.
func (cm *ConMapFloat32Uint32) Get(k float32) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Uint32) GetOK(k float32) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified float32 key.
func (cm *ConMapFloat32Uint32) Set(k float32, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Uint32) Delete(k float32) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given float32 key.
func (cm *ConMapFloat32Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Uint64=BUILTINS"

// ConMapFloat32Uint64 is a concurrent safe wrapper around a
// map[Float32]Uint64.
type ConMapFloat32Uint64 struct {
	// M is the underlying map[Float32]Uint64.
	M map[float32]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Uint64 creates a new concurrent safe map storing uint64 values,
// for float32 keys.
func NewConMapFloat32Uint64() *ConMapFloat32Uint64 {
	return ToConMapFloat32Uint64(nil)
}

// ToConMapFloat32Uint64 creates a new ConMapFloat32Uint64 prepopulated
// with the data from the specified map[Float32]Uint64.
func ToConMapFloat32Uint64(data map[float32]uint64) *ConMapFloat32Uint64 {
	if data == nil {
		data = make(map[float32]uint64)
	}
	return &ConMapFloat32Uint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given float32 key.
func (cm *ConMapFloat32Uint64) Get(k float32) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Uint64) GetOK(k float32) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified float32 key.
func (cm *ConMapFloat32Uint64) Set(k float32, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Uint64) Delete(k float32) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given float32 key.
func (cm *ConMapFloat32Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Uint8=BUILTINS"

// ConMapFloat32Uint8 is a concurrent safe wrapper around a
// map[Float32]Uint8.
type ConMapFloat32Uint8 struct {
	// M is the underlying map[Float32]Uint8.
	M map[float32]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Uint8 creates a new concurrent safe map storing uint8 values,
// for float32 keys.
func NewConMapFloat32Uint8() *ConMapFloat32Uint8 {
	return ToConMapFloat32Uint8(nil)
}

// ToConMapFloat32Uint8 creates a new ConMapFloat32Uint8 prepopulated
// with the data from the specified map[Float32]Uint8.
func ToConMapFloat32Uint8(data map[float32]uint8) *ConMapFloat32Uint8 {
	if data == nil {
		data = make(map[float32]uint8)
	}
	return &ConMapFloat32Uint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given float32 key.
func (cm *ConMapFloat32Uint8) Get(k float32) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Uint8) GetOK(k float32) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified float32 key.
func (cm *ConMapFloat32Uint8) Set(k float32, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Uint8) Delete(k float32) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given float32 key.
func (cm *ConMapFloat32Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float32=BUILTINS Uintptr=BUILTINS"

// ConMapFloat32Uintptr is a concurrent safe wrapper around a
// map[Float32]Uintptr.
type ConMapFloat32Uintptr struct {
	// M is the underlying map[Float32]Uintptr.
	M map[float32]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat32Uintptr creates a new concurrent safe map storing uintptr values,
// for float32 keys.
func NewConMapFloat32Uintptr() *ConMapFloat32Uintptr {
	return ToConMapFloat32Uintptr(nil)
}

// ToConMapFloat32Uintptr creates a new ConMapFloat32Uintptr prepopulated
// with the data from the specified map[Float32]Uintptr.
func ToConMapFloat32Uintptr(data map[float32]uintptr) *ConMapFloat32Uintptr {
	if data == nil {
		data = make(map[float32]uintptr)
	}
	return &ConMapFloat32Uintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given float32 key.
func (cm *ConMapFloat32Uintptr) Get(k float32) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given float32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat32Uintptr) GetOK(k float32) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified float32 key.
func (cm *ConMapFloat32Uintptr) Set(k float32, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float32 key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat32Uintptr) Delete(k float32) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given float32 key.
func (cm *ConMapFloat32Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Bool=BUILTINS"

// ConMapFloat64Bool is a concurrent safe wrapper around a
// map[Float64]Bool.
type ConMapFloat64Bool struct {
	// M is the underlying map[Float64]Bool.
	M map[float64]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Bool creates a new concurrent safe map storing bool values,
// for float64 keys.
func NewConMapFloat64Bool() *ConMapFloat64Bool {
	return ToConMapFloat64Bool(nil)
}

// ToConMapFloat64Bool creates a new ConMapFloat64Bool prepopulated
// with the data from the specified map[Float64]Bool.
func ToConMapFloat64Bool(data map[float64]bool) *ConMapFloat64Bool {
	if data == nil {
		data = make(map[float64]bool)
	}
	return &ConMapFloat64Bool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given float64 key.
func (cm *ConMapFloat64Bool) Get(k float64) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Bool) GetOK(k float64) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified float64 key.
func (cm *ConMapFloat64Bool) Set(k float64, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Bool) Delete(k float64) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given float64 key.
func (cm *ConMapFloat64Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Byte=BUILTINS"

// ConMapFloat64Byte is a concurrent safe wrapper around a
// map[Float64]Byte.
type ConMapFloat64Byte struct {
	// M is the underlying map[Float64]Byte.
	M map[float64]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Byte creates a new concurrent safe map storing byte values,
// for float64 keys.
func NewConMapFloat64Byte() *ConMapFloat64Byte {
	return ToConMapFloat64Byte(nil)
}

// ToConMapFloat64Byte creates a new ConMapFloat64Byte prepopulated
// with the data from the specified map[Float64]Byte.
func ToConMapFloat64Byte(data map[float64]byte) *ConMapFloat64Byte {
	if data == nil {
		data = make(map[float64]byte)
	}
	return &ConMapFloat64Byte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given float64 key.
func (cm *ConMapFloat64Byte) Get(k float64) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Byte) GetOK(k float64) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified float64 key.
func (cm *ConMapFloat64Byte) Set(k float64, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Byte) Delete(k float64) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given float64 key.
func (cm *ConMapFloat64Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Complex128=BUILTINS"

// ConMapFloat64Complex128 is a concurrent safe wrapper around a
// map[Float64]Complex128.
type ConMapFloat64Complex128 struct {
	// M is the underlying map[Float64]Complex128.
	M map[float64]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Complex128 creates a new concurrent safe map storing complex128 values,
// for float64 keys.
func NewConMapFloat64Complex128() *ConMapFloat64Complex128 {
	return ToConMapFloat64Complex128(nil)
}

// ToConMapFloat64Complex128 creates a new ConMapFloat64Complex128 prepopulated
// with the data from the specified map[Float64]Complex128.
func ToConMapFloat64Complex128(data map[float64]complex128) *ConMapFloat64Complex128 {
	if data == nil {
		data = make(map[float64]complex128)
	}
	return &ConMapFloat64Complex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given float64 key.
func (cm *ConMapFloat64Complex128) Get(k float64) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Complex128) GetOK(k float64) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified float64 key.
func (cm *ConMapFloat64Complex128) Set(k float64, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Complex128) Delete(k float64) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given float64 key.
func (cm *ConMapFloat64Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Complex64=BUILTINS"

// ConMapFloat64Complex64 is a concurrent safe wrapper around a
// map[Float64]Complex64.
type ConMapFloat64Complex64 struct {
	// M is the underlying map[Float64]Complex64.
	M map[float64]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Complex64 creates a new concurrent safe map storing complex64 values,
// for float64 keys.
func NewConMapFloat64Complex64() *ConMapFloat64Complex64 {
	return ToConMapFloat64Complex64(nil)
}

// ToConMapFloat64Complex64 creates a new ConMapFloat64Complex64 prepopulated
// with the data from the specified map[Float64]Complex64.
func ToConMapFloat64Complex64(data map[float64]complex64) *ConMapFloat64Complex64 {
	if data == nil {
		data = make(map[float64]complex64)
	}
	return &ConMapFloat64Complex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given float64 key.
func (cm *ConMapFloat64Complex64) Get(k float64) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Complex64) GetOK(k float64) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified float64 key.
func (cm *ConMapFloat64Complex64) Set(k float64, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Complex64) Delete(k float64) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given float64 key.
func (cm *ConMapFloat64Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Error=BUILTINS"

// ConMapFloat64Error is a concurrent safe wrapper around a
// map[Float64]Error.
type ConMapFloat64Error struct {
	// M is the underlying map[Float64]Error.
	M map[float64]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Error creates a new concurrent safe map storing error values,
// for float64 keys.
func NewConMapFloat64Error() *ConMapFloat64Error {
	return ToConMapFloat64Error(nil)
}

// ToConMapFloat64Error creates a new ConMapFloat64Error prepopulated
// with the data from the specified map[Float64]Error.
func ToConMapFloat64Error(data map[float64]error) *ConMapFloat64Error {
	if data == nil {
		data = make(map[float64]error)
	}
	return &ConMapFloat64Error{M: data}
}

//var nilError error

// Get gets the error value for the given float64 key.
func (cm *ConMapFloat64Error) Get(k float64) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Error) GetOK(k float64) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified float64 key.
func (cm *ConMapFloat64Error) Set(k float64, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Error) Delete(k float64) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given float64 key.
func (cm *ConMapFloat64Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Float32=BUILTINS"

// ConMapFloat64Float32 is a concurrent safe wrapper around a
// map[Float64]Float32.
type ConMapFloat64Float32 struct {
	// M is the underlying map[Float64]Float32.
	M map[float64]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Float32 creates a new concurrent safe map storing float32 values,
// for float64 keys.
func NewConMapFloat64Float32() *ConMapFloat64Float32 {
	return ToConMapFloat64Float32(nil)
}

// ToConMapFloat64Float32 creates a new ConMapFloat64Float32 prepopulated
// with the data from the specified map[Float64]Float32.
func ToConMapFloat64Float32(data map[float64]float32) *ConMapFloat64Float32 {
	if data == nil {
		data = make(map[float64]float32)
	}
	return &ConMapFloat64Float32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given float64 key.
func (cm *ConMapFloat64Float32) Get(k float64) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Float32) GetOK(k float64) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified float64 key.
func (cm *ConMapFloat64Float32) Set(k float64, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Float32) Delete(k float64) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given float64 key.
func (cm *ConMapFloat64Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Float64=BUILTINS"

// ConMapFloat64Float64 is a concurrent safe wrapper around a
// map[Float64]Float64.
type ConMapFloat64Float64 struct {
	// M is the underlying map[Float64]Float64.
	M map[float64]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Float64 creates a new concurrent safe map storing float64 values,
// for float64 keys.
func NewConMapFloat64Float64() *ConMapFloat64Float64 {
	return ToConMapFloat64Float64(nil)
}

// ToConMapFloat64Float64 creates a new ConMapFloat64Float64 prepopulated
// with the data from the specified map[Float64]Float64.
func ToConMapFloat64Float64(data map[float64]float64) *ConMapFloat64Float64 {
	if data == nil {
		data = make(map[float64]float64)
	}
	return &ConMapFloat64Float64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given float64 key.
func (cm *ConMapFloat64Float64) Get(k float64) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Float64) GetOK(k float64) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified float64 key.
func (cm *ConMapFloat64Float64) Set(k float64, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Float64) Delete(k float64) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given float64 key.
func (cm *ConMapFloat64Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Int=BUILTINS"

// ConMapFloat64Int is a concurrent safe wrapper around a
// map[Float64]Int.
type ConMapFloat64Int struct {
	// M is the underlying map[Float64]Int.
	M map[float64]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Int creates a new concurrent safe map storing int values,
// for float64 keys.
func NewConMapFloat64Int() *ConMapFloat64Int {
	return ToConMapFloat64Int(nil)
}

// ToConMapFloat64Int creates a new ConMapFloat64Int prepopulated
// with the data from the specified map[Float64]Int.
func ToConMapFloat64Int(data map[float64]int) *ConMapFloat64Int {
	if data == nil {
		data = make(map[float64]int)
	}
	return &ConMapFloat64Int{M: data}
}

//var nilInt int

// Get gets the int value for the given float64 key.
func (cm *ConMapFloat64Int) Get(k float64) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Int) GetOK(k float64) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified float64 key.
func (cm *ConMapFloat64Int) Set(k float64, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Int) Delete(k float64) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given float64 key.
func (cm *ConMapFloat64Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Int16=BUILTINS"

// ConMapFloat64Int16 is a concurrent safe wrapper around a
// map[Float64]Int16.
type ConMapFloat64Int16 struct {
	// M is the underlying map[Float64]Int16.
	M map[float64]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Int16 creates a new concurrent safe map storing int16 values,
// for float64 keys.
func NewConMapFloat64Int16() *ConMapFloat64Int16 {
	return ToConMapFloat64Int16(nil)
}

// ToConMapFloat64Int16 creates a new ConMapFloat64Int16 prepopulated
// with the data from the specified map[Float64]Int16.
func ToConMapFloat64Int16(data map[float64]int16) *ConMapFloat64Int16 {
	if data == nil {
		data = make(map[float64]int16)
	}
	return &ConMapFloat64Int16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given float64 key.
func (cm *ConMapFloat64Int16) Get(k float64) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Int16) GetOK(k float64) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified float64 key.
func (cm *ConMapFloat64Int16) Set(k float64, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Int16) Delete(k float64) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given float64 key.
func (cm *ConMapFloat64Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Int32=BUILTINS"

// ConMapFloat64Int32 is a concurrent safe wrapper around a
// map[Float64]Int32.
type ConMapFloat64Int32 struct {
	// M is the underlying map[Float64]Int32.
	M map[float64]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Int32 creates a new concurrent safe map storing int32 values,
// for float64 keys.
func NewConMapFloat64Int32() *ConMapFloat64Int32 {
	return ToConMapFloat64Int32(nil)
}

// ToConMapFloat64Int32 creates a new ConMapFloat64Int32 prepopulated
// with the data from the specified map[Float64]Int32.
func ToConMapFloat64Int32(data map[float64]int32) *ConMapFloat64Int32 {
	if data == nil {
		data = make(map[float64]int32)
	}
	return &ConMapFloat64Int32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given float64 key.
func (cm *ConMapFloat64Int32) Get(k float64) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Int32) GetOK(k float64) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified float64 key.
func (cm *ConMapFloat64Int32) Set(k float64, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Int32) Delete(k float64) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given float64 key.
func (cm *ConMapFloat64Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Int64=BUILTINS"

// ConMapFloat64Int64 is a concurrent safe wrapper around a
// map[Float64]Int64.
type ConMapFloat64Int64 struct {
	// M is the underlying map[Float64]Int64.
	M map[float64]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Int64 creates a new concurrent safe map storing int64 values,
// for float64 keys.
func NewConMapFloat64Int64() *ConMapFloat64Int64 {
	return ToConMapFloat64Int64(nil)
}

// ToConMapFloat64Int64 creates a new ConMapFloat64Int64 prepopulated
// with the data from the specified map[Float64]Int64.
func ToConMapFloat64Int64(data map[float64]int64) *ConMapFloat64Int64 {
	if data == nil {
		data = make(map[float64]int64)
	}
	return &ConMapFloat64Int64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given float64 key.
func (cm *ConMapFloat64Int64) Get(k float64) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Int64) GetOK(k float64) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified float64 key.
func (cm *ConMapFloat64Int64) Set(k float64, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Int64) Delete(k float64) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given float64 key.
func (cm *ConMapFloat64Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Int8=BUILTINS"

// ConMapFloat64Int8 is a concurrent safe wrapper around a
// map[Float64]Int8.
type ConMapFloat64Int8 struct {
	// M is the underlying map[Float64]Int8.
	M map[float64]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Int8 creates a new concurrent safe map storing int8 values,
// for float64 keys.
func NewConMapFloat64Int8() *ConMapFloat64Int8 {
	return ToConMapFloat64Int8(nil)
}

// ToConMapFloat64Int8 creates a new ConMapFloat64Int8 prepopulated
// with the data from the specified map[Float64]Int8.
func ToConMapFloat64Int8(data map[float64]int8) *ConMapFloat64Int8 {
	if data == nil {
		data = make(map[float64]int8)
	}
	return &ConMapFloat64Int8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given float64 key.
func (cm *ConMapFloat64Int8) Get(k float64) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Int8) GetOK(k float64) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified float64 key.
func (cm *ConMapFloat64Int8) Set(k float64, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Int8) Delete(k float64) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given float64 key.
func (cm *ConMapFloat64Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Rune=BUILTINS"

// ConMapFloat64Rune is a concurrent safe wrapper around a
// map[Float64]Rune.
type ConMapFloat64Rune struct {
	// M is the underlying map[Float64]Rune.
	M map[float64]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Rune creates a new concurrent safe map storing rune values,
// for float64 keys.
func NewConMapFloat64Rune() *ConMapFloat64Rune {
	return ToConMapFloat64Rune(nil)
}

// ToConMapFloat64Rune creates a new ConMapFloat64Rune prepopulated
// with the data from the specified map[Float64]Rune.
func ToConMapFloat64Rune(data map[float64]rune) *ConMapFloat64Rune {
	if data == nil {
		data = make(map[float64]rune)
	}
	return &ConMapFloat64Rune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given float64 key.
func (cm *ConMapFloat64Rune) Get(k float64) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Rune) GetOK(k float64) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified float64 key.
func (cm *ConMapFloat64Rune) Set(k float64, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Rune) Delete(k float64) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given float64 key.
func (cm *ConMapFloat64Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS String=BUILTINS"

// ConMapFloat64String is a concurrent safe wrapper around a
// map[Float64]String.
type ConMapFloat64String struct {
	// M is the underlying map[Float64]String.
	M map[float64]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64String creates a new concurrent safe map storing string values,
// for float64 keys.
func NewConMapFloat64String() *ConMapFloat64String {
	return ToConMapFloat64String(nil)
}

// ToConMapFloat64String creates a new ConMapFloat64String prepopulated
// with the data from the specified map[Float64]String.
func ToConMapFloat64String(data map[float64]string) *ConMapFloat64String {
	if data == nil {
		data = make(map[float64]string)
	}
	return &ConMapFloat64String{M: data}
}

//var nilString string

// Get gets the string value for the given float64 key.
func (cm *ConMapFloat64String) Get(k float64) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64String) GetOK(k float64) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified float64 key.
func (cm *ConMapFloat64String) Set(k float64, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64String) Delete(k float64) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given float64 key.
func (cm *ConMapFloat64String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Uint=BUILTINS"

// ConMapFloat64Uint is a concurrent safe wrapper around a
// map[Float64]Uint.
type ConMapFloat64Uint struct {
	// M is the underlying map[Float64]Uint.
	M map[float64]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Uint creates a new concurrent safe map storing uint values,
// for float64 keys.
func NewConMapFloat64Uint() *ConMapFloat64Uint {
	return ToConMapFloat64Uint(nil)
}

// ToConMapFloat64Uint creates a new ConMapFloat64Uint prepopulated
// with the data from the specified map[Float64]Uint.
func ToConMapFloat64Uint(data map[float64]uint) *ConMapFloat64Uint {
	if data == nil {
		data = make(map[float64]uint)
	}
	return &ConMapFloat64Uint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given float64 key.
func (cm *ConMapFloat64Uint) Get(k float64) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Uint) GetOK(k float64) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified float64 key.
func (cm *ConMapFloat64Uint) Set(k float64, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Uint) Delete(k float64) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given float64 key.
func (cm *ConMapFloat64Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Uint16=BUILTINS"

// ConMapFloat64Uint16 is a concurrent safe wrapper around a
// map[Float64]Uint16.
type ConMapFloat64Uint16 struct {
	// M is the underlying map[Float64]Uint16.
	M map[float64]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Uint16 creates a new concurrent safe map storing uint16 values,
// for float64 keys.
func NewConMapFloat64Uint16() *ConMapFloat64Uint16 {
	return ToConMapFloat64Uint16(nil)
}

// ToConMapFloat64Uint16 creates a new ConMapFloat64Uint16 prepopulated
// with the data from the specified map[Float64]Uint16.
func ToConMapFloat64Uint16(data map[float64]uint16) *ConMapFloat64Uint16 {
	if data == nil {
		data = make(map[float64]uint16)
	}
	return &ConMapFloat64Uint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given float64 key.
func (cm *ConMapFloat64Uint16) Get(k float64) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Uint16) GetOK(k float64) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified float64 key.
func (cm *ConMapFloat64Uint16) Set(k float64, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Uint16) Delete(k float64) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given float64 key.
func (cm *ConMapFloat64Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Uint32=BUILTINS"

// ConMapFloat64Uint32 is a concurrent safe wrapper around a
// map[Float64]Uint32.
type ConMapFloat64Uint32 struct {
	// M is the underlying map[Float64]Uint32.
	M map[float64]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Uint32 creates a new concurrent safe map storing uint32 values,
// for float64 keys.
func NewConMapFloat64Uint32() *ConMapFloat64Uint32 {
	return ToConMapFloat64Uint32(nil)
}

// ToConMapFloat64Uint32 creates a new ConMapFloat64Uint32 prepopulated
// with the data from the specified map[Float64]Uint32.
func ToConMapFloat64Uint32(data map[float64]uint32) *ConMapFloat64Uint32 {
	if data == nil {
		data = make(map[float64]uint32)
	}
	return &ConMapFloat64Uint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given float64 key.
func (cm *ConMapFloat64Uint32) Get(k float64) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Uint32) GetOK(k float64) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified float64 key.
func (cm *ConMapFloat64Uint32) Set(k float64, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Uint32) Delete(k float64) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given float64 key.
func (cm *ConMapFloat64Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Uint64=BUILTINS"

// ConMapFloat64Uint64 is a concurrent safe wrapper around a
// map[Float64]Uint64.
type ConMapFloat64Uint64 struct {
	// M is the underlying map[Float64]Uint64.
	M map[float64]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Uint64 creates a new concurrent safe map storing uint64 values,
// for float64 keys.
func NewConMapFloat64Uint64() *ConMapFloat64Uint64 {
	return ToConMapFloat64Uint64(nil)
}

// ToConMapFloat64Uint64 creates a new ConMapFloat64Uint64 prepopulated
// with the data from the specified map[Float64]Uint64.
func ToConMapFloat64Uint64(data map[float64]uint64) *ConMapFloat64Uint64 {
	if data == nil {
		data = make(map[float64]uint64)
	}
	return &ConMapFloat64Uint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given float64 key.
func (cm *ConMapFloat64Uint64) Get(k float64) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Uint64) GetOK(k float64) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified float64 key.
func (cm *ConMapFloat64Uint64) Set(k float64, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Uint64) Delete(k float64) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given float64 key.
func (cm *ConMapFloat64Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Uint8=BUILTINS"

// ConMapFloat64Uint8 is a concurrent safe wrapper around a
// map[Float64]Uint8.
type ConMapFloat64Uint8 struct {
	// M is the underlying map[Float64]Uint8.
	M map[float64]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Uint8 creates a new concurrent safe map storing uint8 values,
// for float64 keys.
func NewConMapFloat64Uint8() *ConMapFloat64Uint8 {
	return ToConMapFloat64Uint8(nil)
}

// ToConMapFloat64Uint8 creates a new ConMapFloat64Uint8 prepopulated
// with the data from the specified map[Float64]Uint8.
func ToConMapFloat64Uint8(data map[float64]uint8) *ConMapFloat64Uint8 {
	if data == nil {
		data = make(map[float64]uint8)
	}
	return &ConMapFloat64Uint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given float64 key.
func (cm *ConMapFloat64Uint8) Get(k float64) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Uint8) GetOK(k float64) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified float64 key.
func (cm *ConMapFloat64Uint8) Set(k float64, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Uint8) Delete(k float64) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given float64 key.
func (cm *ConMapFloat64Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Float64=BUILTINS Uintptr=BUILTINS"

// ConMapFloat64Uintptr is a concurrent safe wrapper around a
// map[Float64]Uintptr.
type ConMapFloat64Uintptr struct {
	// M is the underlying map[Float64]Uintptr.
	M map[float64]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapFloat64Uintptr creates a new concurrent safe map storing uintptr values,
// for float64 keys.
func NewConMapFloat64Uintptr() *ConMapFloat64Uintptr {
	return ToConMapFloat64Uintptr(nil)
}

// ToConMapFloat64Uintptr creates a new ConMapFloat64Uintptr prepopulated
// with the data from the specified map[Float64]Uintptr.
func ToConMapFloat64Uintptr(data map[float64]uintptr) *ConMapFloat64Uintptr {
	if data == nil {
		data = make(map[float64]uintptr)
	}
	return &ConMapFloat64Uintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given float64 key.
func (cm *ConMapFloat64Uintptr) Get(k float64) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given float64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapFloat64Uintptr) GetOK(k float64) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified float64 key.
func (cm *ConMapFloat64Uintptr) Set(k float64, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified float64 key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapFloat64Uintptr) Delete(k float64) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given float64 key.
func (cm *ConMapFloat64Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Bool=BUILTINS"

// ConMapIntBool is a concurrent safe wrapper around a
// map[Int]Bool.
type ConMapIntBool struct {
	// M is the underlying map[Int]Bool.
	M map[int]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntBool creates a new concurrent safe map storing bool values,
// for int keys.
func NewConMapIntBool() *ConMapIntBool {
	return ToConMapIntBool(nil)
}

// ToConMapIntBool creates a new ConMapIntBool prepopulated
// with the data from the specified map[Int]Bool.
func ToConMapIntBool(data map[int]bool) *ConMapIntBool {
	if data == nil {
		data = make(map[int]bool)
	}
	return &ConMapIntBool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given int key.
func (cm *ConMapIntBool) Get(k int) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntBool) GetOK(k int) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified int key.
func (cm *ConMapIntBool) Set(k int, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntBool) Delete(k int) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given int key.
func (cm *ConMapIntBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Byte=BUILTINS"

// ConMapIntByte is a concurrent safe wrapper around a
// map[Int]Byte.
type ConMapIntByte struct {
	// M is the underlying map[Int]Byte.
	M map[int]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntByte creates a new concurrent safe map storing byte values,
// for int keys.
func NewConMapIntByte() *ConMapIntByte {
	return ToConMapIntByte(nil)
}

// ToConMapIntByte creates a new ConMapIntByte prepopulated
// with the data from the specified map[Int]Byte.
func ToConMapIntByte(data map[int]byte) *ConMapIntByte {
	if data == nil {
		data = make(map[int]byte)
	}
	return &ConMapIntByte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given int key.
func (cm *ConMapIntByte) Get(k int) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntByte) GetOK(k int) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified int key.
func (cm *ConMapIntByte) Set(k int, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntByte) Delete(k int) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given int key.
func (cm *ConMapIntByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Complex128=BUILTINS"

// ConMapIntComplex128 is a concurrent safe wrapper around a
// map[Int]Complex128.
type ConMapIntComplex128 struct {
	// M is the underlying map[Int]Complex128.
	M map[int]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntComplex128 creates a new concurrent safe map storing complex128 values,
// for int keys.
func NewConMapIntComplex128() *ConMapIntComplex128 {
	return ToConMapIntComplex128(nil)
}

// ToConMapIntComplex128 creates a new ConMapIntComplex128 prepopulated
// with the data from the specified map[Int]Complex128.
func ToConMapIntComplex128(data map[int]complex128) *ConMapIntComplex128 {
	if data == nil {
		data = make(map[int]complex128)
	}
	return &ConMapIntComplex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given int key.
func (cm *ConMapIntComplex128) Get(k int) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntComplex128) GetOK(k int) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified int key.
func (cm *ConMapIntComplex128) Set(k int, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntComplex128) Delete(k int) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given int key.
func (cm *ConMapIntComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Complex64=BUILTINS"

// ConMapIntComplex64 is a concurrent safe wrapper around a
// map[Int]Complex64.
type ConMapIntComplex64 struct {
	// M is the underlying map[Int]Complex64.
	M map[int]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntComplex64 creates a new concurrent safe map storing complex64 values,
// for int keys.
func NewConMapIntComplex64() *ConMapIntComplex64 {
	return ToConMapIntComplex64(nil)
}

// ToConMapIntComplex64 creates a new ConMapIntComplex64 prepopulated
// with the data from the specified map[Int]Complex64.
func ToConMapIntComplex64(data map[int]complex64) *ConMapIntComplex64 {
	if data == nil {
		data = make(map[int]complex64)
	}
	return &ConMapIntComplex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given int key.
func (cm *ConMapIntComplex64) Get(k int) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntComplex64) GetOK(k int) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified int key.
func (cm *ConMapIntComplex64) Set(k int, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntComplex64) Delete(k int) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given int key.
func (cm *ConMapIntComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Error=BUILTINS"

// ConMapIntError is a concurrent safe wrapper around a
// map[Int]Error.
type ConMapIntError struct {
	// M is the underlying map[Int]Error.
	M map[int]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntError creates a new concurrent safe map storing error values,
// for int keys.
func NewConMapIntError() *ConMapIntError {
	return ToConMapIntError(nil)
}

// ToConMapIntError creates a new ConMapIntError prepopulated
// with the data from the specified map[Int]Error.
func ToConMapIntError(data map[int]error) *ConMapIntError {
	if data == nil {
		data = make(map[int]error)
	}
	return &ConMapIntError{M: data}
}

//var nilError error

// Get gets the error value for the given int key.
func (cm *ConMapIntError) Get(k int) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntError) GetOK(k int) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified int key.
func (cm *ConMapIntError) Set(k int, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntError) Delete(k int) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given int key.
func (cm *ConMapIntError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Float32=BUILTINS"

// ConMapIntFloat32 is a concurrent safe wrapper around a
// map[Int]Float32.
type ConMapIntFloat32 struct {
	// M is the underlying map[Int]Float32.
	M map[int]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntFloat32 creates a new concurrent safe map storing float32 values,
// for int keys.
func NewConMapIntFloat32() *ConMapIntFloat32 {
	return ToConMapIntFloat32(nil)
}

// ToConMapIntFloat32 creates a new ConMapIntFloat32 prepopulated
// with the data from the specified map[Int]Float32.
func ToConMapIntFloat32(data map[int]float32) *ConMapIntFloat32 {
	if data == nil {
		data = make(map[int]float32)
	}
	return &ConMapIntFloat32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given int key.
func (cm *ConMapIntFloat32) Get(k int) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntFloat32) GetOK(k int) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified int key.
func (cm *ConMapIntFloat32) Set(k int, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntFloat32) Delete(k int) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given int key.
func (cm *ConMapIntFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Float64=BUILTINS"

// ConMapIntFloat64 is a concurrent safe wrapper around a
// map[Int]Float64.
type ConMapIntFloat64 struct {
	// M is the underlying map[Int]Float64.
	M map[int]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntFloat64 creates a new concurrent safe map storing float64 values,
// for int keys.
func NewConMapIntFloat64() *ConMapIntFloat64 {
	return ToConMapIntFloat64(nil)
}

// ToConMapIntFloat64 creates a new ConMapIntFloat64 prepopulated
// with the data from the specified map[Int]Float64.
func ToConMapIntFloat64(data map[int]float64) *ConMapIntFloat64 {
	if data == nil {
		data = make(map[int]float64)
	}
	return &ConMapIntFloat64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given int key.
func (cm *ConMapIntFloat64) Get(k int) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntFloat64) GetOK(k int) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified int key.
func (cm *ConMapIntFloat64) Set(k int, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntFloat64) Delete(k int) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given int key.
func (cm *ConMapIntFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Int=BUILTINS"

// ConMapIntInt is a concurrent safe wrapper around a
// map[Int]Int.
type ConMapIntInt struct {
	// M is the underlying map[Int]Int.
	M map[int]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntInt creates a new concurrent safe map storing int values,
// for int keys.
func NewConMapIntInt() *ConMapIntInt {
	return ToConMapIntInt(nil)
}

// ToConMapIntInt creates a new ConMapIntInt prepopulated
// with the data from the specified map[Int]Int.
func ToConMapIntInt(data map[int]int) *ConMapIntInt {
	if data == nil {
		data = make(map[int]int)
	}
	return &ConMapIntInt{M: data}
}

//var nilInt int

// Get gets the int value for the given int key.
func (cm *ConMapIntInt) Get(k int) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntInt) GetOK(k int) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified int key.
func (cm *ConMapIntInt) Set(k int, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntInt) Delete(k int) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given int key.
func (cm *ConMapIntInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Int16=BUILTINS"

// ConMapIntInt16 is a concurrent safe wrapper around a
// map[Int]Int16.
type ConMapIntInt16 struct {
	// M is the underlying map[Int]Int16.
	M map[int]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntInt16 creates a new concurrent safe map storing int16 values,
// for int keys.
func NewConMapIntInt16() *ConMapIntInt16 {
	return ToConMapIntInt16(nil)
}

// ToConMapIntInt16 creates a new ConMapIntInt16 prepopulated
// with the data from the specified map[Int]Int16.
func ToConMapIntInt16(data map[int]int16) *ConMapIntInt16 {
	if data == nil {
		data = make(map[int]int16)
	}
	return &ConMapIntInt16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given int key.
func (cm *ConMapIntInt16) Get(k int) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntInt16) GetOK(k int) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified int key.
func (cm *ConMapIntInt16) Set(k int, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntInt16) Delete(k int) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given int key.
func (cm *ConMapIntInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Int32=BUILTINS"

// ConMapIntInt32 is a concurrent safe wrapper around a
// map[Int]Int32.
type ConMapIntInt32 struct {
	// M is the underlying map[Int]Int32.
	M map[int]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntInt32 creates a new concurrent safe map storing int32 values,
// for int keys.
func NewConMapIntInt32() *ConMapIntInt32 {
	return ToConMapIntInt32(nil)
}

// ToConMapIntInt32 creates a new ConMapIntInt32 prepopulated
// with the data from the specified map[Int]Int32.
func ToConMapIntInt32(data map[int]int32) *ConMapIntInt32 {
	if data == nil {
		data = make(map[int]int32)
	}
	return &ConMapIntInt32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given int key.
func (cm *ConMapIntInt32) Get(k int) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntInt32) GetOK(k int) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified int key.
func (cm *ConMapIntInt32) Set(k int, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntInt32) Delete(k int) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given int key.
func (cm *ConMapIntInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Int64=BUILTINS"

// ConMapIntInt64 is a concurrent safe wrapper around a
// map[Int]Int64.
type ConMapIntInt64 struct {
	// M is the underlying map[Int]Int64.
	M map[int]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntInt64 creates a new concurrent safe map storing int64 values,
// for int keys.
func NewConMapIntInt64() *ConMapIntInt64 {
	return ToConMapIntInt64(nil)
}

// ToConMapIntInt64 creates a new ConMapIntInt64 prepopulated
// with the data from the specified map[Int]Int64.
func ToConMapIntInt64(data map[int]int64) *ConMapIntInt64 {
	if data == nil {
		data = make(map[int]int64)
	}
	return &ConMapIntInt64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given int key.
func (cm *ConMapIntInt64) Get(k int) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntInt64) GetOK(k int) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified int key.
func (cm *ConMapIntInt64) Set(k int, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntInt64) Delete(k int) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given int key.
func (cm *ConMapIntInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Int8=BUILTINS"

// ConMapIntInt8 is a concurrent safe wrapper around a
// map[Int]Int8.
type ConMapIntInt8 struct {
	// M is the underlying map[Int]Int8.
	M map[int]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntInt8 creates a new concurrent safe map storing int8 values,
// for int keys.
func NewConMapIntInt8() *ConMapIntInt8 {
	return ToConMapIntInt8(nil)
}

// ToConMapIntInt8 creates a new ConMapIntInt8 prepopulated
// with the data from the specified map[Int]Int8.
func ToConMapIntInt8(data map[int]int8) *ConMapIntInt8 {
	if data == nil {
		data = make(map[int]int8)
	}
	return &ConMapIntInt8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given int key.
func (cm *ConMapIntInt8) Get(k int) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntInt8) GetOK(k int) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified int key.
func (cm *ConMapIntInt8) Set(k int, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntInt8) Delete(k int) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given int key.
func (cm *ConMapIntInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Rune=BUILTINS"

// ConMapIntRune is a concurrent safe wrapper around a
// map[Int]Rune.
type ConMapIntRune struct {
	// M is the underlying map[Int]Rune.
	M map[int]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntRune creates a new concurrent safe map storing rune values,
// for int keys.
func NewConMapIntRune() *ConMapIntRune {
	return ToConMapIntRune(nil)
}

// ToConMapIntRune creates a new ConMapIntRune prepopulated
// with the data from the specified map[Int]Rune.
func ToConMapIntRune(data map[int]rune) *ConMapIntRune {
	if data == nil {
		data = make(map[int]rune)
	}
	return &ConMapIntRune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given int key.
func (cm *ConMapIntRune) Get(k int) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntRune) GetOK(k int) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified int key.
func (cm *ConMapIntRune) Set(k int, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntRune) Delete(k int) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given int key.
func (cm *ConMapIntRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS String=BUILTINS"

// ConMapIntString is a concurrent safe wrapper around a
// map[Int]String.
type ConMapIntString struct {
	// M is the underlying map[Int]String.
	M map[int]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntString creates a new concurrent safe map storing string values,
// for int keys.
func NewConMapIntString() *ConMapIntString {
	return ToConMapIntString(nil)
}

// ToConMapIntString creates a new ConMapIntString prepopulated
// with the data from the specified map[Int]String.
func ToConMapIntString(data map[int]string) *ConMapIntString {
	if data == nil {
		data = make(map[int]string)
	}
	return &ConMapIntString{M: data}
}

//var nilString string

// Get gets the string value for the given int key.
func (cm *ConMapIntString) Get(k int) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntString) GetOK(k int) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified int key.
func (cm *ConMapIntString) Set(k int, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntString) Delete(k int) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given int key.
func (cm *ConMapIntString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Uint=BUILTINS"

// ConMapIntUint is a concurrent safe wrapper around a
// map[Int]Uint.
type ConMapIntUint struct {
	// M is the underlying map[Int]Uint.
	M map[int]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntUint creates a new concurrent safe map storing uint values,
// for int keys.
func NewConMapIntUint() *ConMapIntUint {
	return ToConMapIntUint(nil)
}

// ToConMapIntUint creates a new ConMapIntUint prepopulated
// with the data from the specified map[Int]Uint.
func ToConMapIntUint(data map[int]uint) *ConMapIntUint {
	if data == nil {
		data = make(map[int]uint)
	}
	return &ConMapIntUint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given int key.
func (cm *ConMapIntUint) Get(k int) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntUint) GetOK(k int) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified int key.
func (cm *ConMapIntUint) Set(k int, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntUint) Delete(k int) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given int key.
func (cm *ConMapIntUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Uint16=BUILTINS"

// ConMapIntUint16 is a concurrent safe wrapper around a
// map[Int]Uint16.
type ConMapIntUint16 struct {
	// M is the underlying map[Int]Uint16.
	M map[int]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntUint16 creates a new concurrent safe map storing uint16 values,
// for int keys.
func NewConMapIntUint16() *ConMapIntUint16 {
	return ToConMapIntUint16(nil)
}

// ToConMapIntUint16 creates a new ConMapIntUint16 prepopulated
// with the data from the specified map[Int]Uint16.
func ToConMapIntUint16(data map[int]uint16) *ConMapIntUint16 {
	if data == nil {
		data = make(map[int]uint16)
	}
	return &ConMapIntUint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given int key.
func (cm *ConMapIntUint16) Get(k int) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntUint16) GetOK(k int) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified int key.
func (cm *ConMapIntUint16) Set(k int, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntUint16) Delete(k int) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given int key.
func (cm *ConMapIntUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Uint32=BUILTINS"

// ConMapIntUint32 is a concurrent safe wrapper around a
// map[Int]Uint32.
type ConMapIntUint32 struct {
	// M is the underlying map[Int]Uint32.
	M map[int]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntUint32 creates a new concurrent safe map storing uint32 values,
// for int keys.
func NewConMapIntUint32() *ConMapIntUint32 {
	return ToConMapIntUint32(nil)
}

// ToConMapIntUint32 creates a new ConMapIntUint32 prepopulated
// with the data from the specified map[Int]Uint32.
func ToConMapIntUint32(data map[int]uint32) *ConMapIntUint32 {
	if data == nil {
		data = make(map[int]uint32)
	}
	return &ConMapIntUint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given int key.
func (cm *ConMapIntUint32) Get(k int) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntUint32) GetOK(k int) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified int key.
func (cm *ConMapIntUint32) Set(k int, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntUint32) Delete(k int) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given int key.
func (cm *ConMapIntUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Uint64=BUILTINS"

// ConMapIntUint64 is a concurrent safe wrapper around a
// map[Int]Uint64.
type ConMapIntUint64 struct {
	// M is the underlying map[Int]Uint64.
	M map[int]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntUint64 creates a new concurrent safe map storing uint64 values,
// for int keys.
func NewConMapIntUint64() *ConMapIntUint64 {
	return ToConMapIntUint64(nil)
}

// ToConMapIntUint64 creates a new ConMapIntUint64 prepopulated
// with the data from the specified map[Int]Uint64.
func ToConMapIntUint64(data map[int]uint64) *ConMapIntUint64 {
	if data == nil {
		data = make(map[int]uint64)
	}
	return &ConMapIntUint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given int key.
func (cm *ConMapIntUint64) Get(k int) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntUint64) GetOK(k int) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified int key.
func (cm *ConMapIntUint64) Set(k int, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntUint64) Delete(k int) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given int key.
func (cm *ConMapIntUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Uint8=BUILTINS"

// ConMapIntUint8 is a concurrent safe wrapper around a
// map[Int]Uint8.
type ConMapIntUint8 struct {
	// M is the underlying map[Int]Uint8.
	M map[int]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntUint8 creates a new concurrent safe map storing uint8 values,
// for int keys.
func NewConMapIntUint8() *ConMapIntUint8 {
	return ToConMapIntUint8(nil)
}

// ToConMapIntUint8 creates a new ConMapIntUint8 prepopulated
// with the data from the specified map[Int]Uint8.
func ToConMapIntUint8(data map[int]uint8) *ConMapIntUint8 {
	if data == nil {
		data = make(map[int]uint8)
	}
	return &ConMapIntUint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given int key.
func (cm *ConMapIntUint8) Get(k int) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntUint8) GetOK(k int) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified int key.
func (cm *ConMapIntUint8) Set(k int, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntUint8) Delete(k int) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given int key.
func (cm *ConMapIntUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int=BUILTINS Uintptr=BUILTINS"

// ConMapIntUintptr is a concurrent safe wrapper around a
// map[Int]Uintptr.
type ConMapIntUintptr struct {
	// M is the underlying map[Int]Uintptr.
	M map[int]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapIntUintptr creates a new concurrent safe map storing uintptr values,
// for int keys.
func NewConMapIntUintptr() *ConMapIntUintptr {
	return ToConMapIntUintptr(nil)
}

// ToConMapIntUintptr creates a new ConMapIntUintptr prepopulated
// with the data from the specified map[Int]Uintptr.
func ToConMapIntUintptr(data map[int]uintptr) *ConMapIntUintptr {
	if data == nil {
		data = make(map[int]uintptr)
	}
	return &ConMapIntUintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given int key.
func (cm *ConMapIntUintptr) Get(k int) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given int key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapIntUintptr) GetOK(k int) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified int key.
func (cm *ConMapIntUintptr) Set(k int, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapIntUintptr) Delete(k int) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given int key.
func (cm *ConMapIntUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Bool=BUILTINS"

// ConMapInt16Bool is a concurrent safe wrapper around a
// map[Int16]Bool.
type ConMapInt16Bool struct {
	// M is the underlying map[Int16]Bool.
	M map[int16]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Bool creates a new concurrent safe map storing bool values,
// for int16 keys.
func NewConMapInt16Bool() *ConMapInt16Bool {
	return ToConMapInt16Bool(nil)
}

// ToConMapInt16Bool creates a new ConMapInt16Bool prepopulated
// with the data from the specified map[Int16]Bool.
func ToConMapInt16Bool(data map[int16]bool) *ConMapInt16Bool {
	if data == nil {
		data = make(map[int16]bool)
	}
	return &ConMapInt16Bool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given int16 key.
func (cm *ConMapInt16Bool) Get(k int16) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Bool) GetOK(k int16) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified int16 key.
func (cm *ConMapInt16Bool) Set(k int16, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Bool) Delete(k int16) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given int16 key.
func (cm *ConMapInt16Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Byte=BUILTINS"

// ConMapInt16Byte is a concurrent safe wrapper around a
// map[Int16]Byte.
type ConMapInt16Byte struct {
	// M is the underlying map[Int16]Byte.
	M map[int16]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Byte creates a new concurrent safe map storing byte values,
// for int16 keys.
func NewConMapInt16Byte() *ConMapInt16Byte {
	return ToConMapInt16Byte(nil)
}

// ToConMapInt16Byte creates a new ConMapInt16Byte prepopulated
// with the data from the specified map[Int16]Byte.
func ToConMapInt16Byte(data map[int16]byte) *ConMapInt16Byte {
	if data == nil {
		data = make(map[int16]byte)
	}
	return &ConMapInt16Byte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given int16 key.
func (cm *ConMapInt16Byte) Get(k int16) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Byte) GetOK(k int16) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified int16 key.
func (cm *ConMapInt16Byte) Set(k int16, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Byte) Delete(k int16) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given int16 key.
func (cm *ConMapInt16Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Complex128=BUILTINS"

// ConMapInt16Complex128 is a concurrent safe wrapper around a
// map[Int16]Complex128.
type ConMapInt16Complex128 struct {
	// M is the underlying map[Int16]Complex128.
	M map[int16]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Complex128 creates a new concurrent safe map storing complex128 values,
// for int16 keys.
func NewConMapInt16Complex128() *ConMapInt16Complex128 {
	return ToConMapInt16Complex128(nil)
}

// ToConMapInt16Complex128 creates a new ConMapInt16Complex128 prepopulated
// with the data from the specified map[Int16]Complex128.
func ToConMapInt16Complex128(data map[int16]complex128) *ConMapInt16Complex128 {
	if data == nil {
		data = make(map[int16]complex128)
	}
	return &ConMapInt16Complex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given int16 key.
func (cm *ConMapInt16Complex128) Get(k int16) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Complex128) GetOK(k int16) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified int16 key.
func (cm *ConMapInt16Complex128) Set(k int16, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Complex128) Delete(k int16) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given int16 key.
func (cm *ConMapInt16Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Complex64=BUILTINS"

// ConMapInt16Complex64 is a concurrent safe wrapper around a
// map[Int16]Complex64.
type ConMapInt16Complex64 struct {
	// M is the underlying map[Int16]Complex64.
	M map[int16]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Complex64 creates a new concurrent safe map storing complex64 values,
// for int16 keys.
func NewConMapInt16Complex64() *ConMapInt16Complex64 {
	return ToConMapInt16Complex64(nil)
}

// ToConMapInt16Complex64 creates a new ConMapInt16Complex64 prepopulated
// with the data from the specified map[Int16]Complex64.
func ToConMapInt16Complex64(data map[int16]complex64) *ConMapInt16Complex64 {
	if data == nil {
		data = make(map[int16]complex64)
	}
	return &ConMapInt16Complex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given int16 key.
func (cm *ConMapInt16Complex64) Get(k int16) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Complex64) GetOK(k int16) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified int16 key.
func (cm *ConMapInt16Complex64) Set(k int16, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Complex64) Delete(k int16) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given int16 key.
func (cm *ConMapInt16Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Error=BUILTINS"

// ConMapInt16Error is a concurrent safe wrapper around a
// map[Int16]Error.
type ConMapInt16Error struct {
	// M is the underlying map[Int16]Error.
	M map[int16]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Error creates a new concurrent safe map storing error values,
// for int16 keys.
func NewConMapInt16Error() *ConMapInt16Error {
	return ToConMapInt16Error(nil)
}

// ToConMapInt16Error creates a new ConMapInt16Error prepopulated
// with the data from the specified map[Int16]Error.
func ToConMapInt16Error(data map[int16]error) *ConMapInt16Error {
	if data == nil {
		data = make(map[int16]error)
	}
	return &ConMapInt16Error{M: data}
}

//var nilError error

// Get gets the error value for the given int16 key.
func (cm *ConMapInt16Error) Get(k int16) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Error) GetOK(k int16) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified int16 key.
func (cm *ConMapInt16Error) Set(k int16, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Error) Delete(k int16) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given int16 key.
func (cm *ConMapInt16Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Float32=BUILTINS"

// ConMapInt16Float32 is a concurrent safe wrapper around a
// map[Int16]Float32.
type ConMapInt16Float32 struct {
	// M is the underlying map[Int16]Float32.
	M map[int16]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Float32 creates a new concurrent safe map storing float32 values,
// for int16 keys.
func NewConMapInt16Float32() *ConMapInt16Float32 {
	return ToConMapInt16Float32(nil)
}

// ToConMapInt16Float32 creates a new ConMapInt16Float32 prepopulated
// with the data from the specified map[Int16]Float32.
func ToConMapInt16Float32(data map[int16]float32) *ConMapInt16Float32 {
	if data == nil {
		data = make(map[int16]float32)
	}
	return &ConMapInt16Float32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given int16 key.
func (cm *ConMapInt16Float32) Get(k int16) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Float32) GetOK(k int16) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified int16 key.
func (cm *ConMapInt16Float32) Set(k int16, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Float32) Delete(k int16) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given int16 key.
func (cm *ConMapInt16Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Float64=BUILTINS"

// ConMapInt16Float64 is a concurrent safe wrapper around a
// map[Int16]Float64.
type ConMapInt16Float64 struct {
	// M is the underlying map[Int16]Float64.
	M map[int16]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Float64 creates a new concurrent safe map storing float64 values,
// for int16 keys.
func NewConMapInt16Float64() *ConMapInt16Float64 {
	return ToConMapInt16Float64(nil)
}

// ToConMapInt16Float64 creates a new ConMapInt16Float64 prepopulated
// with the data from the specified map[Int16]Float64.
func ToConMapInt16Float64(data map[int16]float64) *ConMapInt16Float64 {
	if data == nil {
		data = make(map[int16]float64)
	}
	return &ConMapInt16Float64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given int16 key.
func (cm *ConMapInt16Float64) Get(k int16) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Float64) GetOK(k int16) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified int16 key.
func (cm *ConMapInt16Float64) Set(k int16, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Float64) Delete(k int16) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given int16 key.
func (cm *ConMapInt16Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Int=BUILTINS"

// ConMapInt16Int is a concurrent safe wrapper around a
// map[Int16]Int.
type ConMapInt16Int struct {
	// M is the underlying map[Int16]Int.
	M map[int16]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Int creates a new concurrent safe map storing int values,
// for int16 keys.
func NewConMapInt16Int() *ConMapInt16Int {
	return ToConMapInt16Int(nil)
}

// ToConMapInt16Int creates a new ConMapInt16Int prepopulated
// with the data from the specified map[Int16]Int.
func ToConMapInt16Int(data map[int16]int) *ConMapInt16Int {
	if data == nil {
		data = make(map[int16]int)
	}
	return &ConMapInt16Int{M: data}
}

//var nilInt int

// Get gets the int value for the given int16 key.
func (cm *ConMapInt16Int) Get(k int16) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Int) GetOK(k int16) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified int16 key.
func (cm *ConMapInt16Int) Set(k int16, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Int) Delete(k int16) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given int16 key.
func (cm *ConMapInt16Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Int16=BUILTINS"

// ConMapInt16Int16 is a concurrent safe wrapper around a
// map[Int16]Int16.
type ConMapInt16Int16 struct {
	// M is the underlying map[Int16]Int16.
	M map[int16]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Int16 creates a new concurrent safe map storing int16 values,
// for int16 keys.
func NewConMapInt16Int16() *ConMapInt16Int16 {
	return ToConMapInt16Int16(nil)
}

// ToConMapInt16Int16 creates a new ConMapInt16Int16 prepopulated
// with the data from the specified map[Int16]Int16.
func ToConMapInt16Int16(data map[int16]int16) *ConMapInt16Int16 {
	if data == nil {
		data = make(map[int16]int16)
	}
	return &ConMapInt16Int16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given int16 key.
func (cm *ConMapInt16Int16) Get(k int16) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Int16) GetOK(k int16) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified int16 key.
func (cm *ConMapInt16Int16) Set(k int16, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Int16) Delete(k int16) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given int16 key.
func (cm *ConMapInt16Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Int32=BUILTINS"

// ConMapInt16Int32 is a concurrent safe wrapper around a
// map[Int16]Int32.
type ConMapInt16Int32 struct {
	// M is the underlying map[Int16]Int32.
	M map[int16]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Int32 creates a new concurrent safe map storing int32 values,
// for int16 keys.
func NewConMapInt16Int32() *ConMapInt16Int32 {
	return ToConMapInt16Int32(nil)
}

// ToConMapInt16Int32 creates a new ConMapInt16Int32 prepopulated
// with the data from the specified map[Int16]Int32.
func ToConMapInt16Int32(data map[int16]int32) *ConMapInt16Int32 {
	if data == nil {
		data = make(map[int16]int32)
	}
	return &ConMapInt16Int32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given int16 key.
func (cm *ConMapInt16Int32) Get(k int16) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Int32) GetOK(k int16) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified int16 key.
func (cm *ConMapInt16Int32) Set(k int16, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Int32) Delete(k int16) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given int16 key.
func (cm *ConMapInt16Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Int64=BUILTINS"

// ConMapInt16Int64 is a concurrent safe wrapper around a
// map[Int16]Int64.
type ConMapInt16Int64 struct {
	// M is the underlying map[Int16]Int64.
	M map[int16]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Int64 creates a new concurrent safe map storing int64 values,
// for int16 keys.
func NewConMapInt16Int64() *ConMapInt16Int64 {
	return ToConMapInt16Int64(nil)
}

// ToConMapInt16Int64 creates a new ConMapInt16Int64 prepopulated
// with the data from the specified map[Int16]Int64.
func ToConMapInt16Int64(data map[int16]int64) *ConMapInt16Int64 {
	if data == nil {
		data = make(map[int16]int64)
	}
	return &ConMapInt16Int64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given int16 key.
func (cm *ConMapInt16Int64) Get(k int16) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Int64) GetOK(k int16) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified int16 key.
func (cm *ConMapInt16Int64) Set(k int16, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Int64) Delete(k int16) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given int16 key.
func (cm *ConMapInt16Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Int8=BUILTINS"

// ConMapInt16Int8 is a concurrent safe wrapper around a
// map[Int16]Int8.
type ConMapInt16Int8 struct {
	// M is the underlying map[Int16]Int8.
	M map[int16]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Int8 creates a new concurrent safe map storing int8 values,
// for int16 keys.
func NewConMapInt16Int8() *ConMapInt16Int8 {
	return ToConMapInt16Int8(nil)
}

// ToConMapInt16Int8 creates a new ConMapInt16Int8 prepopulated
// with the data from the specified map[Int16]Int8.
func ToConMapInt16Int8(data map[int16]int8) *ConMapInt16Int8 {
	if data == nil {
		data = make(map[int16]int8)
	}
	return &ConMapInt16Int8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given int16 key.
func (cm *ConMapInt16Int8) Get(k int16) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Int8) GetOK(k int16) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified int16 key.
func (cm *ConMapInt16Int8) Set(k int16, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Int8) Delete(k int16) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given int16 key.
func (cm *ConMapInt16Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Rune=BUILTINS"

// ConMapInt16Rune is a concurrent safe wrapper around a
// map[Int16]Rune.
type ConMapInt16Rune struct {
	// M is the underlying map[Int16]Rune.
	M map[int16]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Rune creates a new concurrent safe map storing rune values,
// for int16 keys.
func NewConMapInt16Rune() *ConMapInt16Rune {
	return ToConMapInt16Rune(nil)
}

// ToConMapInt16Rune creates a new ConMapInt16Rune prepopulated
// with the data from the specified map[Int16]Rune.
func ToConMapInt16Rune(data map[int16]rune) *ConMapInt16Rune {
	if data == nil {
		data = make(map[int16]rune)
	}
	return &ConMapInt16Rune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given int16 key.
func (cm *ConMapInt16Rune) Get(k int16) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Rune) GetOK(k int16) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified int16 key.
func (cm *ConMapInt16Rune) Set(k int16, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Rune) Delete(k int16) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given int16 key.
func (cm *ConMapInt16Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS String=BUILTINS"

// ConMapInt16String is a concurrent safe wrapper around a
// map[Int16]String.
type ConMapInt16String struct {
	// M is the underlying map[Int16]String.
	M map[int16]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16String creates a new concurrent safe map storing string values,
// for int16 keys.
func NewConMapInt16String() *ConMapInt16String {
	return ToConMapInt16String(nil)
}

// ToConMapInt16String creates a new ConMapInt16String prepopulated
// with the data from the specified map[Int16]String.
func ToConMapInt16String(data map[int16]string) *ConMapInt16String {
	if data == nil {
		data = make(map[int16]string)
	}
	return &ConMapInt16String{M: data}
}

//var nilString string

// Get gets the string value for the given int16 key.
func (cm *ConMapInt16String) Get(k int16) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16String) GetOK(k int16) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified int16 key.
func (cm *ConMapInt16String) Set(k int16, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16String) Delete(k int16) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given int16 key.
func (cm *ConMapInt16String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Uint=BUILTINS"

// ConMapInt16Uint is a concurrent safe wrapper around a
// map[Int16]Uint.
type ConMapInt16Uint struct {
	// M is the underlying map[Int16]Uint.
	M map[int16]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Uint creates a new concurrent safe map storing uint values,
// for int16 keys.
func NewConMapInt16Uint() *ConMapInt16Uint {
	return ToConMapInt16Uint(nil)
}

// ToConMapInt16Uint creates a new ConMapInt16Uint prepopulated
// with the data from the specified map[Int16]Uint.
func ToConMapInt16Uint(data map[int16]uint) *ConMapInt16Uint {
	if data == nil {
		data = make(map[int16]uint)
	}
	return &ConMapInt16Uint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given int16 key.
func (cm *ConMapInt16Uint) Get(k int16) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Uint) GetOK(k int16) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified int16 key.
func (cm *ConMapInt16Uint) Set(k int16, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Uint) Delete(k int16) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given int16 key.
func (cm *ConMapInt16Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Uint16=BUILTINS"

// ConMapInt16Uint16 is a concurrent safe wrapper around a
// map[Int16]Uint16.
type ConMapInt16Uint16 struct {
	// M is the underlying map[Int16]Uint16.
	M map[int16]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Uint16 creates a new concurrent safe map storing uint16 values,
// for int16 keys.
func NewConMapInt16Uint16() *ConMapInt16Uint16 {
	return ToConMapInt16Uint16(nil)
}

// ToConMapInt16Uint16 creates a new ConMapInt16Uint16 prepopulated
// with the data from the specified map[Int16]Uint16.
func ToConMapInt16Uint16(data map[int16]uint16) *ConMapInt16Uint16 {
	if data == nil {
		data = make(map[int16]uint16)
	}
	return &ConMapInt16Uint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given int16 key.
func (cm *ConMapInt16Uint16) Get(k int16) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Uint16) GetOK(k int16) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified int16 key.
func (cm *ConMapInt16Uint16) Set(k int16, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Uint16) Delete(k int16) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given int16 key.
func (cm *ConMapInt16Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Uint32=BUILTINS"

// ConMapInt16Uint32 is a concurrent safe wrapper around a
// map[Int16]Uint32.
type ConMapInt16Uint32 struct {
	// M is the underlying map[Int16]Uint32.
	M map[int16]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Uint32 creates a new concurrent safe map storing uint32 values,
// for int16 keys.
func NewConMapInt16Uint32() *ConMapInt16Uint32 {
	return ToConMapInt16Uint32(nil)
}

// ToConMapInt16Uint32 creates a new ConMapInt16Uint32 prepopulated
// with the data from the specified map[Int16]Uint32.
func ToConMapInt16Uint32(data map[int16]uint32) *ConMapInt16Uint32 {
	if data == nil {
		data = make(map[int16]uint32)
	}
	return &ConMapInt16Uint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given int16 key.
func (cm *ConMapInt16Uint32) Get(k int16) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Uint32) GetOK(k int16) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified int16 key.
func (cm *ConMapInt16Uint32) Set(k int16, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Uint32) Delete(k int16) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given int16 key.
func (cm *ConMapInt16Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Uint64=BUILTINS"

// ConMapInt16Uint64 is a concurrent safe wrapper around a
// map[Int16]Uint64.
type ConMapInt16Uint64 struct {
	// M is the underlying map[Int16]Uint64.
	M map[int16]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Uint64 creates a new concurrent safe map storing uint64 values,
// for int16 keys.
func NewConMapInt16Uint64() *ConMapInt16Uint64 {
	return ToConMapInt16Uint64(nil)
}

// ToConMapInt16Uint64 creates a new ConMapInt16Uint64 prepopulated
// with the data from the specified map[Int16]Uint64.
func ToConMapInt16Uint64(data map[int16]uint64) *ConMapInt16Uint64 {
	if data == nil {
		data = make(map[int16]uint64)
	}
	return &ConMapInt16Uint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given int16 key.
func (cm *ConMapInt16Uint64) Get(k int16) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Uint64) GetOK(k int16) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified int16 key.
func (cm *ConMapInt16Uint64) Set(k int16, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Uint64) Delete(k int16) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given int16 key.
func (cm *ConMapInt16Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Uint8=BUILTINS"

// ConMapInt16Uint8 is a concurrent safe wrapper around a
// map[Int16]Uint8.
type ConMapInt16Uint8 struct {
	// M is the underlying map[Int16]Uint8.
	M map[int16]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Uint8 creates a new concurrent safe map storing uint8 values,
// for int16 keys.
func NewConMapInt16Uint8() *ConMapInt16Uint8 {
	return ToConMapInt16Uint8(nil)
}

// ToConMapInt16Uint8 creates a new ConMapInt16Uint8 prepopulated
// with the data from the specified map[Int16]Uint8.
func ToConMapInt16Uint8(data map[int16]uint8) *ConMapInt16Uint8 {
	if data == nil {
		data = make(map[int16]uint8)
	}
	return &ConMapInt16Uint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given int16 key.
func (cm *ConMapInt16Uint8) Get(k int16) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Uint8) GetOK(k int16) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified int16 key.
func (cm *ConMapInt16Uint8) Set(k int16, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Uint8) Delete(k int16) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given int16 key.
func (cm *ConMapInt16Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int16=BUILTINS Uintptr=BUILTINS"

// ConMapInt16Uintptr is a concurrent safe wrapper around a
// map[Int16]Uintptr.
type ConMapInt16Uintptr struct {
	// M is the underlying map[Int16]Uintptr.
	M map[int16]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt16Uintptr creates a new concurrent safe map storing uintptr values,
// for int16 keys.
func NewConMapInt16Uintptr() *ConMapInt16Uintptr {
	return ToConMapInt16Uintptr(nil)
}

// ToConMapInt16Uintptr creates a new ConMapInt16Uintptr prepopulated
// with the data from the specified map[Int16]Uintptr.
func ToConMapInt16Uintptr(data map[int16]uintptr) *ConMapInt16Uintptr {
	if data == nil {
		data = make(map[int16]uintptr)
	}
	return &ConMapInt16Uintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given int16 key.
func (cm *ConMapInt16Uintptr) Get(k int16) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given int16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt16Uintptr) GetOK(k int16) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified int16 key.
func (cm *ConMapInt16Uintptr) Set(k int16, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int16 key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt16Uintptr) Delete(k int16) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given int16 key.
func (cm *ConMapInt16Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Bool=BUILTINS"

// ConMapInt32Bool is a concurrent safe wrapper around a
// map[Int32]Bool.
type ConMapInt32Bool struct {
	// M is the underlying map[Int32]Bool.
	M map[int32]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Bool creates a new concurrent safe map storing bool values,
// for int32 keys.
func NewConMapInt32Bool() *ConMapInt32Bool {
	return ToConMapInt32Bool(nil)
}

// ToConMapInt32Bool creates a new ConMapInt32Bool prepopulated
// with the data from the specified map[Int32]Bool.
func ToConMapInt32Bool(data map[int32]bool) *ConMapInt32Bool {
	if data == nil {
		data = make(map[int32]bool)
	}
	return &ConMapInt32Bool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given int32 key.
func (cm *ConMapInt32Bool) Get(k int32) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Bool) GetOK(k int32) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified int32 key.
func (cm *ConMapInt32Bool) Set(k int32, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Bool) Delete(k int32) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given int32 key.
func (cm *ConMapInt32Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Byte=BUILTINS"

// ConMapInt32Byte is a concurrent safe wrapper around a
// map[Int32]Byte.
type ConMapInt32Byte struct {
	// M is the underlying map[Int32]Byte.
	M map[int32]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Byte creates a new concurrent safe map storing byte values,
// for int32 keys.
func NewConMapInt32Byte() *ConMapInt32Byte {
	return ToConMapInt32Byte(nil)
}

// ToConMapInt32Byte creates a new ConMapInt32Byte prepopulated
// with the data from the specified map[Int32]Byte.
func ToConMapInt32Byte(data map[int32]byte) *ConMapInt32Byte {
	if data == nil {
		data = make(map[int32]byte)
	}
	return &ConMapInt32Byte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given int32 key.
func (cm *ConMapInt32Byte) Get(k int32) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Byte) GetOK(k int32) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified int32 key.
func (cm *ConMapInt32Byte) Set(k int32, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Byte) Delete(k int32) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given int32 key.
func (cm *ConMapInt32Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Complex128=BUILTINS"

// ConMapInt32Complex128 is a concurrent safe wrapper around a
// map[Int32]Complex128.
type ConMapInt32Complex128 struct {
	// M is the underlying map[Int32]Complex128.
	M map[int32]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Complex128 creates a new concurrent safe map storing complex128 values,
// for int32 keys.
func NewConMapInt32Complex128() *ConMapInt32Complex128 {
	return ToConMapInt32Complex128(nil)
}

// ToConMapInt32Complex128 creates a new ConMapInt32Complex128 prepopulated
// with the data from the specified map[Int32]Complex128.
func ToConMapInt32Complex128(data map[int32]complex128) *ConMapInt32Complex128 {
	if data == nil {
		data = make(map[int32]complex128)
	}
	return &ConMapInt32Complex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given int32 key.
func (cm *ConMapInt32Complex128) Get(k int32) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Complex128) GetOK(k int32) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified int32 key.
func (cm *ConMapInt32Complex128) Set(k int32, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Complex128) Delete(k int32) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given int32 key.
func (cm *ConMapInt32Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Complex64=BUILTINS"

// ConMapInt32Complex64 is a concurrent safe wrapper around a
// map[Int32]Complex64.
type ConMapInt32Complex64 struct {
	// M is the underlying map[Int32]Complex64.
	M map[int32]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Complex64 creates a new concurrent safe map storing complex64 values,
// for int32 keys.
func NewConMapInt32Complex64() *ConMapInt32Complex64 {
	return ToConMapInt32Complex64(nil)
}

// ToConMapInt32Complex64 creates a new ConMapInt32Complex64 prepopulated
// with the data from the specified map[Int32]Complex64.
func ToConMapInt32Complex64(data map[int32]complex64) *ConMapInt32Complex64 {
	if data == nil {
		data = make(map[int32]complex64)
	}
	return &ConMapInt32Complex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given int32 key.
func (cm *ConMapInt32Complex64) Get(k int32) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Complex64) GetOK(k int32) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified int32 key.
func (cm *ConMapInt32Complex64) Set(k int32, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Complex64) Delete(k int32) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given int32 key.
func (cm *ConMapInt32Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Error=BUILTINS"

// ConMapInt32Error is a concurrent safe wrapper around a
// map[Int32]Error.
type ConMapInt32Error struct {
	// M is the underlying map[Int32]Error.
	M map[int32]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Error creates a new concurrent safe map storing error values,
// for int32 keys.
func NewConMapInt32Error() *ConMapInt32Error {
	return ToConMapInt32Error(nil)
}

// ToConMapInt32Error creates a new ConMapInt32Error prepopulated
// with the data from the specified map[Int32]Error.
func ToConMapInt32Error(data map[int32]error) *ConMapInt32Error {
	if data == nil {
		data = make(map[int32]error)
	}
	return &ConMapInt32Error{M: data}
}

//var nilError error

// Get gets the error value for the given int32 key.
func (cm *ConMapInt32Error) Get(k int32) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Error) GetOK(k int32) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified int32 key.
func (cm *ConMapInt32Error) Set(k int32, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Error) Delete(k int32) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given int32 key.
func (cm *ConMapInt32Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Float32=BUILTINS"

// ConMapInt32Float32 is a concurrent safe wrapper around a
// map[Int32]Float32.
type ConMapInt32Float32 struct {
	// M is the underlying map[Int32]Float32.
	M map[int32]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Float32 creates a new concurrent safe map storing float32 values,
// for int32 keys.
func NewConMapInt32Float32() *ConMapInt32Float32 {
	return ToConMapInt32Float32(nil)
}

// ToConMapInt32Float32 creates a new ConMapInt32Float32 prepopulated
// with the data from the specified map[Int32]Float32.
func ToConMapInt32Float32(data map[int32]float32) *ConMapInt32Float32 {
	if data == nil {
		data = make(map[int32]float32)
	}
	return &ConMapInt32Float32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given int32 key.
func (cm *ConMapInt32Float32) Get(k int32) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Float32) GetOK(k int32) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified int32 key.
func (cm *ConMapInt32Float32) Set(k int32, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Float32) Delete(k int32) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given int32 key.
func (cm *ConMapInt32Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Float64=BUILTINS"

// ConMapInt32Float64 is a concurrent safe wrapper around a
// map[Int32]Float64.
type ConMapInt32Float64 struct {
	// M is the underlying map[Int32]Float64.
	M map[int32]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Float64 creates a new concurrent safe map storing float64 values,
// for int32 keys.
func NewConMapInt32Float64() *ConMapInt32Float64 {
	return ToConMapInt32Float64(nil)
}

// ToConMapInt32Float64 creates a new ConMapInt32Float64 prepopulated
// with the data from the specified map[Int32]Float64.
func ToConMapInt32Float64(data map[int32]float64) *ConMapInt32Float64 {
	if data == nil {
		data = make(map[int32]float64)
	}
	return &ConMapInt32Float64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given int32 key.
func (cm *ConMapInt32Float64) Get(k int32) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Float64) GetOK(k int32) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified int32 key.
func (cm *ConMapInt32Float64) Set(k int32, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Float64) Delete(k int32) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given int32 key.
func (cm *ConMapInt32Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Int=BUILTINS"

// ConMapInt32Int is a concurrent safe wrapper around a
// map[Int32]Int.
type ConMapInt32Int struct {
	// M is the underlying map[Int32]Int.
	M map[int32]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Int creates a new concurrent safe map storing int values,
// for int32 keys.
func NewConMapInt32Int() *ConMapInt32Int {
	return ToConMapInt32Int(nil)
}

// ToConMapInt32Int creates a new ConMapInt32Int prepopulated
// with the data from the specified map[Int32]Int.
func ToConMapInt32Int(data map[int32]int) *ConMapInt32Int {
	if data == nil {
		data = make(map[int32]int)
	}
	return &ConMapInt32Int{M: data}
}

//var nilInt int

// Get gets the int value for the given int32 key.
func (cm *ConMapInt32Int) Get(k int32) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Int) GetOK(k int32) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified int32 key.
func (cm *ConMapInt32Int) Set(k int32, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Int) Delete(k int32) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given int32 key.
func (cm *ConMapInt32Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Int16=BUILTINS"

// ConMapInt32Int16 is a concurrent safe wrapper around a
// map[Int32]Int16.
type ConMapInt32Int16 struct {
	// M is the underlying map[Int32]Int16.
	M map[int32]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Int16 creates a new concurrent safe map storing int16 values,
// for int32 keys.
func NewConMapInt32Int16() *ConMapInt32Int16 {
	return ToConMapInt32Int16(nil)
}

// ToConMapInt32Int16 creates a new ConMapInt32Int16 prepopulated
// with the data from the specified map[Int32]Int16.
func ToConMapInt32Int16(data map[int32]int16) *ConMapInt32Int16 {
	if data == nil {
		data = make(map[int32]int16)
	}
	return &ConMapInt32Int16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given int32 key.
func (cm *ConMapInt32Int16) Get(k int32) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Int16) GetOK(k int32) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified int32 key.
func (cm *ConMapInt32Int16) Set(k int32, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Int16) Delete(k int32) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given int32 key.
func (cm *ConMapInt32Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Int32=BUILTINS"

// ConMapInt32Int32 is a concurrent safe wrapper around a
// map[Int32]Int32.
type ConMapInt32Int32 struct {
	// M is the underlying map[Int32]Int32.
	M map[int32]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Int32 creates a new concurrent safe map storing int32 values,
// for int32 keys.
func NewConMapInt32Int32() *ConMapInt32Int32 {
	return ToConMapInt32Int32(nil)
}

// ToConMapInt32Int32 creates a new ConMapInt32Int32 prepopulated
// with the data from the specified map[Int32]Int32.
func ToConMapInt32Int32(data map[int32]int32) *ConMapInt32Int32 {
	if data == nil {
		data = make(map[int32]int32)
	}
	return &ConMapInt32Int32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given int32 key.
func (cm *ConMapInt32Int32) Get(k int32) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Int32) GetOK(k int32) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified int32 key.
func (cm *ConMapInt32Int32) Set(k int32, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Int32) Delete(k int32) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given int32 key.
func (cm *ConMapInt32Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Int64=BUILTINS"

// ConMapInt32Int64 is a concurrent safe wrapper around a
// map[Int32]Int64.
type ConMapInt32Int64 struct {
	// M is the underlying map[Int32]Int64.
	M map[int32]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Int64 creates a new concurrent safe map storing int64 values,
// for int32 keys.
func NewConMapInt32Int64() *ConMapInt32Int64 {
	return ToConMapInt32Int64(nil)
}

// ToConMapInt32Int64 creates a new ConMapInt32Int64 prepopulated
// with the data from the specified map[Int32]Int64.
func ToConMapInt32Int64(data map[int32]int64) *ConMapInt32Int64 {
	if data == nil {
		data = make(map[int32]int64)
	}
	return &ConMapInt32Int64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given int32 key.
func (cm *ConMapInt32Int64) Get(k int32) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Int64) GetOK(k int32) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified int32 key.
func (cm *ConMapInt32Int64) Set(k int32, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Int64) Delete(k int32) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given int32 key.
func (cm *ConMapInt32Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Int8=BUILTINS"

// ConMapInt32Int8 is a concurrent safe wrapper around a
// map[Int32]Int8.
type ConMapInt32Int8 struct {
	// M is the underlying map[Int32]Int8.
	M map[int32]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Int8 creates a new concurrent safe map storing int8 values,
// for int32 keys.
func NewConMapInt32Int8() *ConMapInt32Int8 {
	return ToConMapInt32Int8(nil)
}

// ToConMapInt32Int8 creates a new ConMapInt32Int8 prepopulated
// with the data from the specified map[Int32]Int8.
func ToConMapInt32Int8(data map[int32]int8) *ConMapInt32Int8 {
	if data == nil {
		data = make(map[int32]int8)
	}
	return &ConMapInt32Int8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given int32 key.
func (cm *ConMapInt32Int8) Get(k int32) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Int8) GetOK(k int32) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified int32 key.
func (cm *ConMapInt32Int8) Set(k int32, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Int8) Delete(k int32) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given int32 key.
func (cm *ConMapInt32Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Rune=BUILTINS"

// ConMapInt32Rune is a concurrent safe wrapper around a
// map[Int32]Rune.
type ConMapInt32Rune struct {
	// M is the underlying map[Int32]Rune.
	M map[int32]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Rune creates a new concurrent safe map storing rune values,
// for int32 keys.
func NewConMapInt32Rune() *ConMapInt32Rune {
	return ToConMapInt32Rune(nil)
}

// ToConMapInt32Rune creates a new ConMapInt32Rune prepopulated
// with the data from the specified map[Int32]Rune.
func ToConMapInt32Rune(data map[int32]rune) *ConMapInt32Rune {
	if data == nil {
		data = make(map[int32]rune)
	}
	return &ConMapInt32Rune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given int32 key.
func (cm *ConMapInt32Rune) Get(k int32) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Rune) GetOK(k int32) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified int32 key.
func (cm *ConMapInt32Rune) Set(k int32, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Rune) Delete(k int32) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given int32 key.
func (cm *ConMapInt32Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS String=BUILTINS"

// ConMapInt32String is a concurrent safe wrapper around a
// map[Int32]String.
type ConMapInt32String struct {
	// M is the underlying map[Int32]String.
	M map[int32]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32String creates a new concurrent safe map storing string values,
// for int32 keys.
func NewConMapInt32String() *ConMapInt32String {
	return ToConMapInt32String(nil)
}

// ToConMapInt32String creates a new ConMapInt32String prepopulated
// with the data from the specified map[Int32]String.
func ToConMapInt32String(data map[int32]string) *ConMapInt32String {
	if data == nil {
		data = make(map[int32]string)
	}
	return &ConMapInt32String{M: data}
}

//var nilString string

// Get gets the string value for the given int32 key.
func (cm *ConMapInt32String) Get(k int32) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32String) GetOK(k int32) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified int32 key.
func (cm *ConMapInt32String) Set(k int32, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32String) Delete(k int32) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given int32 key.
func (cm *ConMapInt32String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Uint=BUILTINS"

// ConMapInt32Uint is a concurrent safe wrapper around a
// map[Int32]Uint.
type ConMapInt32Uint struct {
	// M is the underlying map[Int32]Uint.
	M map[int32]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Uint creates a new concurrent safe map storing uint values,
// for int32 keys.
func NewConMapInt32Uint() *ConMapInt32Uint {
	return ToConMapInt32Uint(nil)
}

// ToConMapInt32Uint creates a new ConMapInt32Uint prepopulated
// with the data from the specified map[Int32]Uint.
func ToConMapInt32Uint(data map[int32]uint) *ConMapInt32Uint {
	if data == nil {
		data = make(map[int32]uint)
	}
	return &ConMapInt32Uint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given int32 key.
func (cm *ConMapInt32Uint) Get(k int32) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Uint) GetOK(k int32) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified int32 key.
func (cm *ConMapInt32Uint) Set(k int32, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Uint) Delete(k int32) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given int32 key.
func (cm *ConMapInt32Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Uint16=BUILTINS"

// ConMapInt32Uint16 is a concurrent safe wrapper around a
// map[Int32]Uint16.
type ConMapInt32Uint16 struct {
	// M is the underlying map[Int32]Uint16.
	M map[int32]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Uint16 creates a new concurrent safe map storing uint16 values,
// for int32 keys.
func NewConMapInt32Uint16() *ConMapInt32Uint16 {
	return ToConMapInt32Uint16(nil)
}

// ToConMapInt32Uint16 creates a new ConMapInt32Uint16 prepopulated
// with the data from the specified map[Int32]Uint16.
func ToConMapInt32Uint16(data map[int32]uint16) *ConMapInt32Uint16 {
	if data == nil {
		data = make(map[int32]uint16)
	}
	return &ConMapInt32Uint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given int32 key.
func (cm *ConMapInt32Uint16) Get(k int32) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Uint16) GetOK(k int32) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified int32 key.
func (cm *ConMapInt32Uint16) Set(k int32, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Uint16) Delete(k int32) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given int32 key.
func (cm *ConMapInt32Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Uint32=BUILTINS"

// ConMapInt32Uint32 is a concurrent safe wrapper around a
// map[Int32]Uint32.
type ConMapInt32Uint32 struct {
	// M is the underlying map[Int32]Uint32.
	M map[int32]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Uint32 creates a new concurrent safe map storing uint32 values,
// for int32 keys.
func NewConMapInt32Uint32() *ConMapInt32Uint32 {
	return ToConMapInt32Uint32(nil)
}

// ToConMapInt32Uint32 creates a new ConMapInt32Uint32 prepopulated
// with the data from the specified map[Int32]Uint32.
func ToConMapInt32Uint32(data map[int32]uint32) *ConMapInt32Uint32 {
	if data == nil {
		data = make(map[int32]uint32)
	}
	return &ConMapInt32Uint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given int32 key.
func (cm *ConMapInt32Uint32) Get(k int32) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Uint32) GetOK(k int32) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified int32 key.
func (cm *ConMapInt32Uint32) Set(k int32, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Uint32) Delete(k int32) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given int32 key.
func (cm *ConMapInt32Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Uint64=BUILTINS"

// ConMapInt32Uint64 is a concurrent safe wrapper around a
// map[Int32]Uint64.
type ConMapInt32Uint64 struct {
	// M is the underlying map[Int32]Uint64.
	M map[int32]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Uint64 creates a new concurrent safe map storing uint64 values,
// for int32 keys.
func NewConMapInt32Uint64() *ConMapInt32Uint64 {
	return ToConMapInt32Uint64(nil)
}

// ToConMapInt32Uint64 creates a new ConMapInt32Uint64 prepopulated
// with the data from the specified map[Int32]Uint64.
func ToConMapInt32Uint64(data map[int32]uint64) *ConMapInt32Uint64 {
	if data == nil {
		data = make(map[int32]uint64)
	}
	return &ConMapInt32Uint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given int32 key.
func (cm *ConMapInt32Uint64) Get(k int32) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Uint64) GetOK(k int32) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified int32 key.
func (cm *ConMapInt32Uint64) Set(k int32, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Uint64) Delete(k int32) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given int32 key.
func (cm *ConMapInt32Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Uint8=BUILTINS"

// ConMapInt32Uint8 is a concurrent safe wrapper around a
// map[Int32]Uint8.
type ConMapInt32Uint8 struct {
	// M is the underlying map[Int32]Uint8.
	M map[int32]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Uint8 creates a new concurrent safe map storing uint8 values,
// for int32 keys.
func NewConMapInt32Uint8() *ConMapInt32Uint8 {
	return ToConMapInt32Uint8(nil)
}

// ToConMapInt32Uint8 creates a new ConMapInt32Uint8 prepopulated
// with the data from the specified map[Int32]Uint8.
func ToConMapInt32Uint8(data map[int32]uint8) *ConMapInt32Uint8 {
	if data == nil {
		data = make(map[int32]uint8)
	}
	return &ConMapInt32Uint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given int32 key.
func (cm *ConMapInt32Uint8) Get(k int32) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Uint8) GetOK(k int32) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified int32 key.
func (cm *ConMapInt32Uint8) Set(k int32, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Uint8) Delete(k int32) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given int32 key.
func (cm *ConMapInt32Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int32=BUILTINS Uintptr=BUILTINS"

// ConMapInt32Uintptr is a concurrent safe wrapper around a
// map[Int32]Uintptr.
type ConMapInt32Uintptr struct {
	// M is the underlying map[Int32]Uintptr.
	M map[int32]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt32Uintptr creates a new concurrent safe map storing uintptr values,
// for int32 keys.
func NewConMapInt32Uintptr() *ConMapInt32Uintptr {
	return ToConMapInt32Uintptr(nil)
}

// ToConMapInt32Uintptr creates a new ConMapInt32Uintptr prepopulated
// with the data from the specified map[Int32]Uintptr.
func ToConMapInt32Uintptr(data map[int32]uintptr) *ConMapInt32Uintptr {
	if data == nil {
		data = make(map[int32]uintptr)
	}
	return &ConMapInt32Uintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given int32 key.
func (cm *ConMapInt32Uintptr) Get(k int32) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given int32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt32Uintptr) GetOK(k int32) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified int32 key.
func (cm *ConMapInt32Uintptr) Set(k int32, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int32 key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt32Uintptr) Delete(k int32) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given int32 key.
func (cm *ConMapInt32Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Bool=BUILTINS"

// ConMapInt64Bool is a concurrent safe wrapper around a
// map[Int64]Bool.
type ConMapInt64Bool struct {
	// M is the underlying map[Int64]Bool.
	M map[int64]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Bool creates a new concurrent safe map storing bool values,
// for int64 keys.
func NewConMapInt64Bool() *ConMapInt64Bool {
	return ToConMapInt64Bool(nil)
}

// ToConMapInt64Bool creates a new ConMapInt64Bool prepopulated
// with the data from the specified map[Int64]Bool.
func ToConMapInt64Bool(data map[int64]bool) *ConMapInt64Bool {
	if data == nil {
		data = make(map[int64]bool)
	}
	return &ConMapInt64Bool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given int64 key.
func (cm *ConMapInt64Bool) Get(k int64) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Bool) GetOK(k int64) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified int64 key.
func (cm *ConMapInt64Bool) Set(k int64, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Bool) Delete(k int64) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given int64 key.
func (cm *ConMapInt64Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Byte=BUILTINS"

// ConMapInt64Byte is a concurrent safe wrapper around a
// map[Int64]Byte.
type ConMapInt64Byte struct {
	// M is the underlying map[Int64]Byte.
	M map[int64]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Byte creates a new concurrent safe map storing byte values,
// for int64 keys.
func NewConMapInt64Byte() *ConMapInt64Byte {
	return ToConMapInt64Byte(nil)
}

// ToConMapInt64Byte creates a new ConMapInt64Byte prepopulated
// with the data from the specified map[Int64]Byte.
func ToConMapInt64Byte(data map[int64]byte) *ConMapInt64Byte {
	if data == nil {
		data = make(map[int64]byte)
	}
	return &ConMapInt64Byte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given int64 key.
func (cm *ConMapInt64Byte) Get(k int64) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Byte) GetOK(k int64) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified int64 key.
func (cm *ConMapInt64Byte) Set(k int64, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Byte) Delete(k int64) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given int64 key.
func (cm *ConMapInt64Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Complex128=BUILTINS"

// ConMapInt64Complex128 is a concurrent safe wrapper around a
// map[Int64]Complex128.
type ConMapInt64Complex128 struct {
	// M is the underlying map[Int64]Complex128.
	M map[int64]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Complex128 creates a new concurrent safe map storing complex128 values,
// for int64 keys.
func NewConMapInt64Complex128() *ConMapInt64Complex128 {
	return ToConMapInt64Complex128(nil)
}

// ToConMapInt64Complex128 creates a new ConMapInt64Complex128 prepopulated
// with the data from the specified map[Int64]Complex128.
func ToConMapInt64Complex128(data map[int64]complex128) *ConMapInt64Complex128 {
	if data == nil {
		data = make(map[int64]complex128)
	}
	return &ConMapInt64Complex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given int64 key.
func (cm *ConMapInt64Complex128) Get(k int64) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Complex128) GetOK(k int64) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified int64 key.
func (cm *ConMapInt64Complex128) Set(k int64, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Complex128) Delete(k int64) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given int64 key.
func (cm *ConMapInt64Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Complex64=BUILTINS"

// ConMapInt64Complex64 is a concurrent safe wrapper around a
// map[Int64]Complex64.
type ConMapInt64Complex64 struct {
	// M is the underlying map[Int64]Complex64.
	M map[int64]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Complex64 creates a new concurrent safe map storing complex64 values,
// for int64 keys.
func NewConMapInt64Complex64() *ConMapInt64Complex64 {
	return ToConMapInt64Complex64(nil)
}

// ToConMapInt64Complex64 creates a new ConMapInt64Complex64 prepopulated
// with the data from the specified map[Int64]Complex64.
func ToConMapInt64Complex64(data map[int64]complex64) *ConMapInt64Complex64 {
	if data == nil {
		data = make(map[int64]complex64)
	}
	return &ConMapInt64Complex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given int64 key.
func (cm *ConMapInt64Complex64) Get(k int64) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Complex64) GetOK(k int64) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified int64 key.
func (cm *ConMapInt64Complex64) Set(k int64, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Complex64) Delete(k int64) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given int64 key.
func (cm *ConMapInt64Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Error=BUILTINS"

// ConMapInt64Error is a concurrent safe wrapper around a
// map[Int64]Error.
type ConMapInt64Error struct {
	// M is the underlying map[Int64]Error.
	M map[int64]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Error creates a new concurrent safe map storing error values,
// for int64 keys.
func NewConMapInt64Error() *ConMapInt64Error {
	return ToConMapInt64Error(nil)
}

// ToConMapInt64Error creates a new ConMapInt64Error prepopulated
// with the data from the specified map[Int64]Error.
func ToConMapInt64Error(data map[int64]error) *ConMapInt64Error {
	if data == nil {
		data = make(map[int64]error)
	}
	return &ConMapInt64Error{M: data}
}

//var nilError error

// Get gets the error value for the given int64 key.
func (cm *ConMapInt64Error) Get(k int64) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Error) GetOK(k int64) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified int64 key.
func (cm *ConMapInt64Error) Set(k int64, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Error) Delete(k int64) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given int64 key.
func (cm *ConMapInt64Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Float32=BUILTINS"

// ConMapInt64Float32 is a concurrent safe wrapper around a
// map[Int64]Float32.
type ConMapInt64Float32 struct {
	// M is the underlying map[Int64]Float32.
	M map[int64]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Float32 creates a new concurrent safe map storing float32 values,
// for int64 keys.
func NewConMapInt64Float32() *ConMapInt64Float32 {
	return ToConMapInt64Float32(nil)
}

// ToConMapInt64Float32 creates a new ConMapInt64Float32 prepopulated
// with the data from the specified map[Int64]Float32.
func ToConMapInt64Float32(data map[int64]float32) *ConMapInt64Float32 {
	if data == nil {
		data = make(map[int64]float32)
	}
	return &ConMapInt64Float32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given int64 key.
func (cm *ConMapInt64Float32) Get(k int64) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Float32) GetOK(k int64) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified int64 key.
func (cm *ConMapInt64Float32) Set(k int64, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Float32) Delete(k int64) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given int64 key.
func (cm *ConMapInt64Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Float64=BUILTINS"

// ConMapInt64Float64 is a concurrent safe wrapper around a
// map[Int64]Float64.
type ConMapInt64Float64 struct {
	// M is the underlying map[Int64]Float64.
	M map[int64]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Float64 creates a new concurrent safe map storing float64 values,
// for int64 keys.
func NewConMapInt64Float64() *ConMapInt64Float64 {
	return ToConMapInt64Float64(nil)
}

// ToConMapInt64Float64 creates a new ConMapInt64Float64 prepopulated
// with the data from the specified map[Int64]Float64.
func ToConMapInt64Float64(data map[int64]float64) *ConMapInt64Float64 {
	if data == nil {
		data = make(map[int64]float64)
	}
	return &ConMapInt64Float64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given int64 key.
func (cm *ConMapInt64Float64) Get(k int64) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Float64) GetOK(k int64) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified int64 key.
func (cm *ConMapInt64Float64) Set(k int64, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Float64) Delete(k int64) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given int64 key.
func (cm *ConMapInt64Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Int=BUILTINS"

// ConMapInt64Int is a concurrent safe wrapper around a
// map[Int64]Int.
type ConMapInt64Int struct {
	// M is the underlying map[Int64]Int.
	M map[int64]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Int creates a new concurrent safe map storing int values,
// for int64 keys.
func NewConMapInt64Int() *ConMapInt64Int {
	return ToConMapInt64Int(nil)
}

// ToConMapInt64Int creates a new ConMapInt64Int prepopulated
// with the data from the specified map[Int64]Int.
func ToConMapInt64Int(data map[int64]int) *ConMapInt64Int {
	if data == nil {
		data = make(map[int64]int)
	}
	return &ConMapInt64Int{M: data}
}

//var nilInt int

// Get gets the int value for the given int64 key.
func (cm *ConMapInt64Int) Get(k int64) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Int) GetOK(k int64) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified int64 key.
func (cm *ConMapInt64Int) Set(k int64, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Int) Delete(k int64) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given int64 key.
func (cm *ConMapInt64Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Int16=BUILTINS"

// ConMapInt64Int16 is a concurrent safe wrapper around a
// map[Int64]Int16.
type ConMapInt64Int16 struct {
	// M is the underlying map[Int64]Int16.
	M map[int64]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Int16 creates a new concurrent safe map storing int16 values,
// for int64 keys.
func NewConMapInt64Int16() *ConMapInt64Int16 {
	return ToConMapInt64Int16(nil)
}

// ToConMapInt64Int16 creates a new ConMapInt64Int16 prepopulated
// with the data from the specified map[Int64]Int16.
func ToConMapInt64Int16(data map[int64]int16) *ConMapInt64Int16 {
	if data == nil {
		data = make(map[int64]int16)
	}
	return &ConMapInt64Int16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given int64 key.
func (cm *ConMapInt64Int16) Get(k int64) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Int16) GetOK(k int64) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified int64 key.
func (cm *ConMapInt64Int16) Set(k int64, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Int16) Delete(k int64) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given int64 key.
func (cm *ConMapInt64Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Int32=BUILTINS"

// ConMapInt64Int32 is a concurrent safe wrapper around a
// map[Int64]Int32.
type ConMapInt64Int32 struct {
	// M is the underlying map[Int64]Int32.
	M map[int64]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Int32 creates a new concurrent safe map storing int32 values,
// for int64 keys.
func NewConMapInt64Int32() *ConMapInt64Int32 {
	return ToConMapInt64Int32(nil)
}

// ToConMapInt64Int32 creates a new ConMapInt64Int32 prepopulated
// with the data from the specified map[Int64]Int32.
func ToConMapInt64Int32(data map[int64]int32) *ConMapInt64Int32 {
	if data == nil {
		data = make(map[int64]int32)
	}
	return &ConMapInt64Int32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given int64 key.
func (cm *ConMapInt64Int32) Get(k int64) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Int32) GetOK(k int64) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified int64 key.
func (cm *ConMapInt64Int32) Set(k int64, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Int32) Delete(k int64) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given int64 key.
func (cm *ConMapInt64Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Int64=BUILTINS"

// ConMapInt64Int64 is a concurrent safe wrapper around a
// map[Int64]Int64.
type ConMapInt64Int64 struct {
	// M is the underlying map[Int64]Int64.
	M map[int64]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Int64 creates a new concurrent safe map storing int64 values,
// for int64 keys.
func NewConMapInt64Int64() *ConMapInt64Int64 {
	return ToConMapInt64Int64(nil)
}

// ToConMapInt64Int64 creates a new ConMapInt64Int64 prepopulated
// with the data from the specified map[Int64]Int64.
func ToConMapInt64Int64(data map[int64]int64) *ConMapInt64Int64 {
	if data == nil {
		data = make(map[int64]int64)
	}
	return &ConMapInt64Int64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given int64 key.
func (cm *ConMapInt64Int64) Get(k int64) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Int64) GetOK(k int64) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified int64 key.
func (cm *ConMapInt64Int64) Set(k int64, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Int64) Delete(k int64) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given int64 key.
func (cm *ConMapInt64Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Int8=BUILTINS"

// ConMapInt64Int8 is a concurrent safe wrapper around a
// map[Int64]Int8.
type ConMapInt64Int8 struct {
	// M is the underlying map[Int64]Int8.
	M map[int64]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Int8 creates a new concurrent safe map storing int8 values,
// for int64 keys.
func NewConMapInt64Int8() *ConMapInt64Int8 {
	return ToConMapInt64Int8(nil)
}

// ToConMapInt64Int8 creates a new ConMapInt64Int8 prepopulated
// with the data from the specified map[Int64]Int8.
func ToConMapInt64Int8(data map[int64]int8) *ConMapInt64Int8 {
	if data == nil {
		data = make(map[int64]int8)
	}
	return &ConMapInt64Int8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given int64 key.
func (cm *ConMapInt64Int8) Get(k int64) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Int8) GetOK(k int64) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified int64 key.
func (cm *ConMapInt64Int8) Set(k int64, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Int8) Delete(k int64) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given int64 key.
func (cm *ConMapInt64Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Rune=BUILTINS"

// ConMapInt64Rune is a concurrent safe wrapper around a
// map[Int64]Rune.
type ConMapInt64Rune struct {
	// M is the underlying map[Int64]Rune.
	M map[int64]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Rune creates a new concurrent safe map storing rune values,
// for int64 keys.
func NewConMapInt64Rune() *ConMapInt64Rune {
	return ToConMapInt64Rune(nil)
}

// ToConMapInt64Rune creates a new ConMapInt64Rune prepopulated
// with the data from the specified map[Int64]Rune.
func ToConMapInt64Rune(data map[int64]rune) *ConMapInt64Rune {
	if data == nil {
		data = make(map[int64]rune)
	}
	return &ConMapInt64Rune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given int64 key.
func (cm *ConMapInt64Rune) Get(k int64) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Rune) GetOK(k int64) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified int64 key.
func (cm *ConMapInt64Rune) Set(k int64, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Rune) Delete(k int64) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given int64 key.
func (cm *ConMapInt64Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS String=BUILTINS"

// ConMapInt64String is a concurrent safe wrapper around a
// map[Int64]String.
type ConMapInt64String struct {
	// M is the underlying map[Int64]String.
	M map[int64]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64String creates a new concurrent safe map storing string values,
// for int64 keys.
func NewConMapInt64String() *ConMapInt64String {
	return ToConMapInt64String(nil)
}

// ToConMapInt64String creates a new ConMapInt64String prepopulated
// with the data from the specified map[Int64]String.
func ToConMapInt64String(data map[int64]string) *ConMapInt64String {
	if data == nil {
		data = make(map[int64]string)
	}
	return &ConMapInt64String{M: data}
}

//var nilString string

// Get gets the string value for the given int64 key.
func (cm *ConMapInt64String) Get(k int64) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64String) GetOK(k int64) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified int64 key.
func (cm *ConMapInt64String) Set(k int64, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64String) Delete(k int64) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given int64 key.
func (cm *ConMapInt64String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Uint=BUILTINS"

// ConMapInt64Uint is a concurrent safe wrapper around a
// map[Int64]Uint.
type ConMapInt64Uint struct {
	// M is the underlying map[Int64]Uint.
	M map[int64]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Uint creates a new concurrent safe map storing uint values,
// for int64 keys.
func NewConMapInt64Uint() *ConMapInt64Uint {
	return ToConMapInt64Uint(nil)
}

// ToConMapInt64Uint creates a new ConMapInt64Uint prepopulated
// with the data from the specified map[Int64]Uint.
func ToConMapInt64Uint(data map[int64]uint) *ConMapInt64Uint {
	if data == nil {
		data = make(map[int64]uint)
	}
	return &ConMapInt64Uint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given int64 key.
func (cm *ConMapInt64Uint) Get(k int64) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Uint) GetOK(k int64) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified int64 key.
func (cm *ConMapInt64Uint) Set(k int64, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Uint) Delete(k int64) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given int64 key.
func (cm *ConMapInt64Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Uint16=BUILTINS"

// ConMapInt64Uint16 is a concurrent safe wrapper around a
// map[Int64]Uint16.
type ConMapInt64Uint16 struct {
	// M is the underlying map[Int64]Uint16.
	M map[int64]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Uint16 creates a new concurrent safe map storing uint16 values,
// for int64 keys.
func NewConMapInt64Uint16() *ConMapInt64Uint16 {
	return ToConMapInt64Uint16(nil)
}

// ToConMapInt64Uint16 creates a new ConMapInt64Uint16 prepopulated
// with the data from the specified map[Int64]Uint16.
func ToConMapInt64Uint16(data map[int64]uint16) *ConMapInt64Uint16 {
	if data == nil {
		data = make(map[int64]uint16)
	}
	return &ConMapInt64Uint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given int64 key.
func (cm *ConMapInt64Uint16) Get(k int64) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Uint16) GetOK(k int64) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified int64 key.
func (cm *ConMapInt64Uint16) Set(k int64, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Uint16) Delete(k int64) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given int64 key.
func (cm *ConMapInt64Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Uint32=BUILTINS"

// ConMapInt64Uint32 is a concurrent safe wrapper around a
// map[Int64]Uint32.
type ConMapInt64Uint32 struct {
	// M is the underlying map[Int64]Uint32.
	M map[int64]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Uint32 creates a new concurrent safe map storing uint32 values,
// for int64 keys.
func NewConMapInt64Uint32() *ConMapInt64Uint32 {
	return ToConMapInt64Uint32(nil)
}

// ToConMapInt64Uint32 creates a new ConMapInt64Uint32 prepopulated
// with the data from the specified map[Int64]Uint32.
func ToConMapInt64Uint32(data map[int64]uint32) *ConMapInt64Uint32 {
	if data == nil {
		data = make(map[int64]uint32)
	}
	return &ConMapInt64Uint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given int64 key.
func (cm *ConMapInt64Uint32) Get(k int64) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Uint32) GetOK(k int64) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified int64 key.
func (cm *ConMapInt64Uint32) Set(k int64, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Uint32) Delete(k int64) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given int64 key.
func (cm *ConMapInt64Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Uint64=BUILTINS"

// ConMapInt64Uint64 is a concurrent safe wrapper around a
// map[Int64]Uint64.
type ConMapInt64Uint64 struct {
	// M is the underlying map[Int64]Uint64.
	M map[int64]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Uint64 creates a new concurrent safe map storing uint64 values,
// for int64 keys.
func NewConMapInt64Uint64() *ConMapInt64Uint64 {
	return ToConMapInt64Uint64(nil)
}

// ToConMapInt64Uint64 creates a new ConMapInt64Uint64 prepopulated
// with the data from the specified map[Int64]Uint64.
func ToConMapInt64Uint64(data map[int64]uint64) *ConMapInt64Uint64 {
	if data == nil {
		data = make(map[int64]uint64)
	}
	return &ConMapInt64Uint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given int64 key.
func (cm *ConMapInt64Uint64) Get(k int64) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Uint64) GetOK(k int64) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified int64 key.
func (cm *ConMapInt64Uint64) Set(k int64, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Uint64) Delete(k int64) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given int64 key.
func (cm *ConMapInt64Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Uint8=BUILTINS"

// ConMapInt64Uint8 is a concurrent safe wrapper around a
// map[Int64]Uint8.
type ConMapInt64Uint8 struct {
	// M is the underlying map[Int64]Uint8.
	M map[int64]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Uint8 creates a new concurrent safe map storing uint8 values,
// for int64 keys.
func NewConMapInt64Uint8() *ConMapInt64Uint8 {
	return ToConMapInt64Uint8(nil)
}

// ToConMapInt64Uint8 creates a new ConMapInt64Uint8 prepopulated
// with the data from the specified map[Int64]Uint8.
func ToConMapInt64Uint8(data map[int64]uint8) *ConMapInt64Uint8 {
	if data == nil {
		data = make(map[int64]uint8)
	}
	return &ConMapInt64Uint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given int64 key.
func (cm *ConMapInt64Uint8) Get(k int64) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Uint8) GetOK(k int64) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified int64 key.
func (cm *ConMapInt64Uint8) Set(k int64, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Uint8) Delete(k int64) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given int64 key.
func (cm *ConMapInt64Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int64=BUILTINS Uintptr=BUILTINS"

// ConMapInt64Uintptr is a concurrent safe wrapper around a
// map[Int64]Uintptr.
type ConMapInt64Uintptr struct {
	// M is the underlying map[Int64]Uintptr.
	M map[int64]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt64Uintptr creates a new concurrent safe map storing uintptr values,
// for int64 keys.
func NewConMapInt64Uintptr() *ConMapInt64Uintptr {
	return ToConMapInt64Uintptr(nil)
}

// ToConMapInt64Uintptr creates a new ConMapInt64Uintptr prepopulated
// with the data from the specified map[Int64]Uintptr.
func ToConMapInt64Uintptr(data map[int64]uintptr) *ConMapInt64Uintptr {
	if data == nil {
		data = make(map[int64]uintptr)
	}
	return &ConMapInt64Uintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given int64 key.
func (cm *ConMapInt64Uintptr) Get(k int64) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given int64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt64Uintptr) GetOK(k int64) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified int64 key.
func (cm *ConMapInt64Uintptr) Set(k int64, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int64 key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt64Uintptr) Delete(k int64) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given int64 key.
func (cm *ConMapInt64Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Bool=BUILTINS"

// ConMapInt8Bool is a concurrent safe wrapper around a
// map[Int8]Bool.
type ConMapInt8Bool struct {
	// M is the underlying map[Int8]Bool.
	M map[int8]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Bool creates a new concurrent safe map storing bool values,
// for int8 keys.
func NewConMapInt8Bool() *ConMapInt8Bool {
	return ToConMapInt8Bool(nil)
}

// ToConMapInt8Bool creates a new ConMapInt8Bool prepopulated
// with the data from the specified map[Int8]Bool.
func ToConMapInt8Bool(data map[int8]bool) *ConMapInt8Bool {
	if data == nil {
		data = make(map[int8]bool)
	}
	return &ConMapInt8Bool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given int8 key.
func (cm *ConMapInt8Bool) Get(k int8) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Bool) GetOK(k int8) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified int8 key.
func (cm *ConMapInt8Bool) Set(k int8, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Bool) Delete(k int8) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given int8 key.
func (cm *ConMapInt8Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Byte=BUILTINS"

// ConMapInt8Byte is a concurrent safe wrapper around a
// map[Int8]Byte.
type ConMapInt8Byte struct {
	// M is the underlying map[Int8]Byte.
	M map[int8]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Byte creates a new concurrent safe map storing byte values,
// for int8 keys.
func NewConMapInt8Byte() *ConMapInt8Byte {
	return ToConMapInt8Byte(nil)
}

// ToConMapInt8Byte creates a new ConMapInt8Byte prepopulated
// with the data from the specified map[Int8]Byte.
func ToConMapInt8Byte(data map[int8]byte) *ConMapInt8Byte {
	if data == nil {
		data = make(map[int8]byte)
	}
	return &ConMapInt8Byte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given int8 key.
func (cm *ConMapInt8Byte) Get(k int8) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Byte) GetOK(k int8) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified int8 key.
func (cm *ConMapInt8Byte) Set(k int8, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Byte) Delete(k int8) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given int8 key.
func (cm *ConMapInt8Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Complex128=BUILTINS"

// ConMapInt8Complex128 is a concurrent safe wrapper around a
// map[Int8]Complex128.
type ConMapInt8Complex128 struct {
	// M is the underlying map[Int8]Complex128.
	M map[int8]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Complex128 creates a new concurrent safe map storing complex128 values,
// for int8 keys.
func NewConMapInt8Complex128() *ConMapInt8Complex128 {
	return ToConMapInt8Complex128(nil)
}

// ToConMapInt8Complex128 creates a new ConMapInt8Complex128 prepopulated
// with the data from the specified map[Int8]Complex128.
func ToConMapInt8Complex128(data map[int8]complex128) *ConMapInt8Complex128 {
	if data == nil {
		data = make(map[int8]complex128)
	}
	return &ConMapInt8Complex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given int8 key.
func (cm *ConMapInt8Complex128) Get(k int8) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Complex128) GetOK(k int8) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified int8 key.
func (cm *ConMapInt8Complex128) Set(k int8, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Complex128) Delete(k int8) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given int8 key.
func (cm *ConMapInt8Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Complex64=BUILTINS"

// ConMapInt8Complex64 is a concurrent safe wrapper around a
// map[Int8]Complex64.
type ConMapInt8Complex64 struct {
	// M is the underlying map[Int8]Complex64.
	M map[int8]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Complex64 creates a new concurrent safe map storing complex64 values,
// for int8 keys.
func NewConMapInt8Complex64() *ConMapInt8Complex64 {
	return ToConMapInt8Complex64(nil)
}

// ToConMapInt8Complex64 creates a new ConMapInt8Complex64 prepopulated
// with the data from the specified map[Int8]Complex64.
func ToConMapInt8Complex64(data map[int8]complex64) *ConMapInt8Complex64 {
	if data == nil {
		data = make(map[int8]complex64)
	}
	return &ConMapInt8Complex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given int8 key.
func (cm *ConMapInt8Complex64) Get(k int8) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Complex64) GetOK(k int8) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified int8 key.
func (cm *ConMapInt8Complex64) Set(k int8, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Complex64) Delete(k int8) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given int8 key.
func (cm *ConMapInt8Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Error=BUILTINS"

// ConMapInt8Error is a concurrent safe wrapper around a
// map[Int8]Error.
type ConMapInt8Error struct {
	// M is the underlying map[Int8]Error.
	M map[int8]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Error creates a new concurrent safe map storing error values,
// for int8 keys.
func NewConMapInt8Error() *ConMapInt8Error {
	return ToConMapInt8Error(nil)
}

// ToConMapInt8Error creates a new ConMapInt8Error prepopulated
// with the data from the specified map[Int8]Error.
func ToConMapInt8Error(data map[int8]error) *ConMapInt8Error {
	if data == nil {
		data = make(map[int8]error)
	}
	return &ConMapInt8Error{M: data}
}

//var nilError error

// Get gets the error value for the given int8 key.
func (cm *ConMapInt8Error) Get(k int8) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Error) GetOK(k int8) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified int8 key.
func (cm *ConMapInt8Error) Set(k int8, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Error) Delete(k int8) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given int8 key.
func (cm *ConMapInt8Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Float32=BUILTINS"

// ConMapInt8Float32 is a concurrent safe wrapper around a
// map[Int8]Float32.
type ConMapInt8Float32 struct {
	// M is the underlying map[Int8]Float32.
	M map[int8]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Float32 creates a new concurrent safe map storing float32 values,
// for int8 keys.
func NewConMapInt8Float32() *ConMapInt8Float32 {
	return ToConMapInt8Float32(nil)
}

// ToConMapInt8Float32 creates a new ConMapInt8Float32 prepopulated
// with the data from the specified map[Int8]Float32.
func ToConMapInt8Float32(data map[int8]float32) *ConMapInt8Float32 {
	if data == nil {
		data = make(map[int8]float32)
	}
	return &ConMapInt8Float32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given int8 key.
func (cm *ConMapInt8Float32) Get(k int8) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Float32) GetOK(k int8) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified int8 key.
func (cm *ConMapInt8Float32) Set(k int8, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Float32) Delete(k int8) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given int8 key.
func (cm *ConMapInt8Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Float64=BUILTINS"

// ConMapInt8Float64 is a concurrent safe wrapper around a
// map[Int8]Float64.
type ConMapInt8Float64 struct {
	// M is the underlying map[Int8]Float64.
	M map[int8]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Float64 creates a new concurrent safe map storing float64 values,
// for int8 keys.
func NewConMapInt8Float64() *ConMapInt8Float64 {
	return ToConMapInt8Float64(nil)
}

// ToConMapInt8Float64 creates a new ConMapInt8Float64 prepopulated
// with the data from the specified map[Int8]Float64.
func ToConMapInt8Float64(data map[int8]float64) *ConMapInt8Float64 {
	if data == nil {
		data = make(map[int8]float64)
	}
	return &ConMapInt8Float64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given int8 key.
func (cm *ConMapInt8Float64) Get(k int8) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Float64) GetOK(k int8) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified int8 key.
func (cm *ConMapInt8Float64) Set(k int8, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Float64) Delete(k int8) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given int8 key.
func (cm *ConMapInt8Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Int=BUILTINS"

// ConMapInt8Int is a concurrent safe wrapper around a
// map[Int8]Int.
type ConMapInt8Int struct {
	// M is the underlying map[Int8]Int.
	M map[int8]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Int creates a new concurrent safe map storing int values,
// for int8 keys.
func NewConMapInt8Int() *ConMapInt8Int {
	return ToConMapInt8Int(nil)
}

// ToConMapInt8Int creates a new ConMapInt8Int prepopulated
// with the data from the specified map[Int8]Int.
func ToConMapInt8Int(data map[int8]int) *ConMapInt8Int {
	if data == nil {
		data = make(map[int8]int)
	}
	return &ConMapInt8Int{M: data}
}

//var nilInt int

// Get gets the int value for the given int8 key.
func (cm *ConMapInt8Int) Get(k int8) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Int) GetOK(k int8) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified int8 key.
func (cm *ConMapInt8Int) Set(k int8, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Int) Delete(k int8) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given int8 key.
func (cm *ConMapInt8Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Int16=BUILTINS"

// ConMapInt8Int16 is a concurrent safe wrapper around a
// map[Int8]Int16.
type ConMapInt8Int16 struct {
	// M is the underlying map[Int8]Int16.
	M map[int8]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Int16 creates a new concurrent safe map storing int16 values,
// for int8 keys.
func NewConMapInt8Int16() *ConMapInt8Int16 {
	return ToConMapInt8Int16(nil)
}

// ToConMapInt8Int16 creates a new ConMapInt8Int16 prepopulated
// with the data from the specified map[Int8]Int16.
func ToConMapInt8Int16(data map[int8]int16) *ConMapInt8Int16 {
	if data == nil {
		data = make(map[int8]int16)
	}
	return &ConMapInt8Int16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given int8 key.
func (cm *ConMapInt8Int16) Get(k int8) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Int16) GetOK(k int8) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified int8 key.
func (cm *ConMapInt8Int16) Set(k int8, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Int16) Delete(k int8) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given int8 key.
func (cm *ConMapInt8Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Int32=BUILTINS"

// ConMapInt8Int32 is a concurrent safe wrapper around a
// map[Int8]Int32.
type ConMapInt8Int32 struct {
	// M is the underlying map[Int8]Int32.
	M map[int8]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Int32 creates a new concurrent safe map storing int32 values,
// for int8 keys.
func NewConMapInt8Int32() *ConMapInt8Int32 {
	return ToConMapInt8Int32(nil)
}

// ToConMapInt8Int32 creates a new ConMapInt8Int32 prepopulated
// with the data from the specified map[Int8]Int32.
func ToConMapInt8Int32(data map[int8]int32) *ConMapInt8Int32 {
	if data == nil {
		data = make(map[int8]int32)
	}
	return &ConMapInt8Int32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given int8 key.
func (cm *ConMapInt8Int32) Get(k int8) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Int32) GetOK(k int8) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified int8 key.
func (cm *ConMapInt8Int32) Set(k int8, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Int32) Delete(k int8) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given int8 key.
func (cm *ConMapInt8Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Int64=BUILTINS"

// ConMapInt8Int64 is a concurrent safe wrapper around a
// map[Int8]Int64.
type ConMapInt8Int64 struct {
	// M is the underlying map[Int8]Int64.
	M map[int8]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Int64 creates a new concurrent safe map storing int64 values,
// for int8 keys.
func NewConMapInt8Int64() *ConMapInt8Int64 {
	return ToConMapInt8Int64(nil)
}

// ToConMapInt8Int64 creates a new ConMapInt8Int64 prepopulated
// with the data from the specified map[Int8]Int64.
func ToConMapInt8Int64(data map[int8]int64) *ConMapInt8Int64 {
	if data == nil {
		data = make(map[int8]int64)
	}
	return &ConMapInt8Int64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given int8 key.
func (cm *ConMapInt8Int64) Get(k int8) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Int64) GetOK(k int8) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified int8 key.
func (cm *ConMapInt8Int64) Set(k int8, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Int64) Delete(k int8) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given int8 key.
func (cm *ConMapInt8Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Int8=BUILTINS"

// ConMapInt8Int8 is a concurrent safe wrapper around a
// map[Int8]Int8.
type ConMapInt8Int8 struct {
	// M is the underlying map[Int8]Int8.
	M map[int8]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Int8 creates a new concurrent safe map storing int8 values,
// for int8 keys.
func NewConMapInt8Int8() *ConMapInt8Int8 {
	return ToConMapInt8Int8(nil)
}

// ToConMapInt8Int8 creates a new ConMapInt8Int8 prepopulated
// with the data from the specified map[Int8]Int8.
func ToConMapInt8Int8(data map[int8]int8) *ConMapInt8Int8 {
	if data == nil {
		data = make(map[int8]int8)
	}
	return &ConMapInt8Int8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given int8 key.
func (cm *ConMapInt8Int8) Get(k int8) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Int8) GetOK(k int8) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified int8 key.
func (cm *ConMapInt8Int8) Set(k int8, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Int8) Delete(k int8) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given int8 key.
func (cm *ConMapInt8Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Rune=BUILTINS"

// ConMapInt8Rune is a concurrent safe wrapper around a
// map[Int8]Rune.
type ConMapInt8Rune struct {
	// M is the underlying map[Int8]Rune.
	M map[int8]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Rune creates a new concurrent safe map storing rune values,
// for int8 keys.
func NewConMapInt8Rune() *ConMapInt8Rune {
	return ToConMapInt8Rune(nil)
}

// ToConMapInt8Rune creates a new ConMapInt8Rune prepopulated
// with the data from the specified map[Int8]Rune.
func ToConMapInt8Rune(data map[int8]rune) *ConMapInt8Rune {
	if data == nil {
		data = make(map[int8]rune)
	}
	return &ConMapInt8Rune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given int8 key.
func (cm *ConMapInt8Rune) Get(k int8) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Rune) GetOK(k int8) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified int8 key.
func (cm *ConMapInt8Rune) Set(k int8, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Rune) Delete(k int8) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given int8 key.
func (cm *ConMapInt8Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS String=BUILTINS"

// ConMapInt8String is a concurrent safe wrapper around a
// map[Int8]String.
type ConMapInt8String struct {
	// M is the underlying map[Int8]String.
	M map[int8]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8String creates a new concurrent safe map storing string values,
// for int8 keys.
func NewConMapInt8String() *ConMapInt8String {
	return ToConMapInt8String(nil)
}

// ToConMapInt8String creates a new ConMapInt8String prepopulated
// with the data from the specified map[Int8]String.
func ToConMapInt8String(data map[int8]string) *ConMapInt8String {
	if data == nil {
		data = make(map[int8]string)
	}
	return &ConMapInt8String{M: data}
}

//var nilString string

// Get gets the string value for the given int8 key.
func (cm *ConMapInt8String) Get(k int8) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8String) GetOK(k int8) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified int8 key.
func (cm *ConMapInt8String) Set(k int8, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8String) Delete(k int8) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given int8 key.
func (cm *ConMapInt8String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Uint=BUILTINS"

// ConMapInt8Uint is a concurrent safe wrapper around a
// map[Int8]Uint.
type ConMapInt8Uint struct {
	// M is the underlying map[Int8]Uint.
	M map[int8]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Uint creates a new concurrent safe map storing uint values,
// for int8 keys.
func NewConMapInt8Uint() *ConMapInt8Uint {
	return ToConMapInt8Uint(nil)
}

// ToConMapInt8Uint creates a new ConMapInt8Uint prepopulated
// with the data from the specified map[Int8]Uint.
func ToConMapInt8Uint(data map[int8]uint) *ConMapInt8Uint {
	if data == nil {
		data = make(map[int8]uint)
	}
	return &ConMapInt8Uint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given int8 key.
func (cm *ConMapInt8Uint) Get(k int8) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Uint) GetOK(k int8) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified int8 key.
func (cm *ConMapInt8Uint) Set(k int8, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Uint) Delete(k int8) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given int8 key.
func (cm *ConMapInt8Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Uint16=BUILTINS"

// ConMapInt8Uint16 is a concurrent safe wrapper around a
// map[Int8]Uint16.
type ConMapInt8Uint16 struct {
	// M is the underlying map[Int8]Uint16.
	M map[int8]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Uint16 creates a new concurrent safe map storing uint16 values,
// for int8 keys.
func NewConMapInt8Uint16() *ConMapInt8Uint16 {
	return ToConMapInt8Uint16(nil)
}

// ToConMapInt8Uint16 creates a new ConMapInt8Uint16 prepopulated
// with the data from the specified map[Int8]Uint16.
func ToConMapInt8Uint16(data map[int8]uint16) *ConMapInt8Uint16 {
	if data == nil {
		data = make(map[int8]uint16)
	}
	return &ConMapInt8Uint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given int8 key.
func (cm *ConMapInt8Uint16) Get(k int8) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Uint16) GetOK(k int8) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified int8 key.
func (cm *ConMapInt8Uint16) Set(k int8, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Uint16) Delete(k int8) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given int8 key.
func (cm *ConMapInt8Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Uint32=BUILTINS"

// ConMapInt8Uint32 is a concurrent safe wrapper around a
// map[Int8]Uint32.
type ConMapInt8Uint32 struct {
	// M is the underlying map[Int8]Uint32.
	M map[int8]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Uint32 creates a new concurrent safe map storing uint32 values,
// for int8 keys.
func NewConMapInt8Uint32() *ConMapInt8Uint32 {
	return ToConMapInt8Uint32(nil)
}

// ToConMapInt8Uint32 creates a new ConMapInt8Uint32 prepopulated
// with the data from the specified map[Int8]Uint32.
func ToConMapInt8Uint32(data map[int8]uint32) *ConMapInt8Uint32 {
	if data == nil {
		data = make(map[int8]uint32)
	}
	return &ConMapInt8Uint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given int8 key.
func (cm *ConMapInt8Uint32) Get(k int8) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Uint32) GetOK(k int8) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified int8 key.
func (cm *ConMapInt8Uint32) Set(k int8, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Uint32) Delete(k int8) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given int8 key.
func (cm *ConMapInt8Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Uint64=BUILTINS"

// ConMapInt8Uint64 is a concurrent safe wrapper around a
// map[Int8]Uint64.
type ConMapInt8Uint64 struct {
	// M is the underlying map[Int8]Uint64.
	M map[int8]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Uint64 creates a new concurrent safe map storing uint64 values,
// for int8 keys.
func NewConMapInt8Uint64() *ConMapInt8Uint64 {
	return ToConMapInt8Uint64(nil)
}

// ToConMapInt8Uint64 creates a new ConMapInt8Uint64 prepopulated
// with the data from the specified map[Int8]Uint64.
func ToConMapInt8Uint64(data map[int8]uint64) *ConMapInt8Uint64 {
	if data == nil {
		data = make(map[int8]uint64)
	}
	return &ConMapInt8Uint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given int8 key.
func (cm *ConMapInt8Uint64) Get(k int8) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Uint64) GetOK(k int8) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified int8 key.
func (cm *ConMapInt8Uint64) Set(k int8, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Uint64) Delete(k int8) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given int8 key.
func (cm *ConMapInt8Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Uint8=BUILTINS"

// ConMapInt8Uint8 is a concurrent safe wrapper around a
// map[Int8]Uint8.
type ConMapInt8Uint8 struct {
	// M is the underlying map[Int8]Uint8.
	M map[int8]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Uint8 creates a new concurrent safe map storing uint8 values,
// for int8 keys.
func NewConMapInt8Uint8() *ConMapInt8Uint8 {
	return ToConMapInt8Uint8(nil)
}

// ToConMapInt8Uint8 creates a new ConMapInt8Uint8 prepopulated
// with the data from the specified map[Int8]Uint8.
func ToConMapInt8Uint8(data map[int8]uint8) *ConMapInt8Uint8 {
	if data == nil {
		data = make(map[int8]uint8)
	}
	return &ConMapInt8Uint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given int8 key.
func (cm *ConMapInt8Uint8) Get(k int8) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Uint8) GetOK(k int8) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified int8 key.
func (cm *ConMapInt8Uint8) Set(k int8, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Uint8) Delete(k int8) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given int8 key.
func (cm *ConMapInt8Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Int8=BUILTINS Uintptr=BUILTINS"

// ConMapInt8Uintptr is a concurrent safe wrapper around a
// map[Int8]Uintptr.
type ConMapInt8Uintptr struct {
	// M is the underlying map[Int8]Uintptr.
	M map[int8]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapInt8Uintptr creates a new concurrent safe map storing uintptr values,
// for int8 keys.
func NewConMapInt8Uintptr() *ConMapInt8Uintptr {
	return ToConMapInt8Uintptr(nil)
}

// ToConMapInt8Uintptr creates a new ConMapInt8Uintptr prepopulated
// with the data from the specified map[Int8]Uintptr.
func ToConMapInt8Uintptr(data map[int8]uintptr) *ConMapInt8Uintptr {
	if data == nil {
		data = make(map[int8]uintptr)
	}
	return &ConMapInt8Uintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given int8 key.
func (cm *ConMapInt8Uintptr) Get(k int8) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given int8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapInt8Uintptr) GetOK(k int8) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified int8 key.
func (cm *ConMapInt8Uintptr) Set(k int8, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified int8 key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapInt8Uintptr) Delete(k int8) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given int8 key.
func (cm *ConMapInt8Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Bool=BUILTINS"

// ConMapRuneBool is a concurrent safe wrapper around a
// map[Rune]Bool.
type ConMapRuneBool struct {
	// M is the underlying map[Rune]Bool.
	M map[rune]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneBool creates a new concurrent safe map storing bool values,
// for rune keys.
func NewConMapRuneBool() *ConMapRuneBool {
	return ToConMapRuneBool(nil)
}

// ToConMapRuneBool creates a new ConMapRuneBool prepopulated
// with the data from the specified map[Rune]Bool.
func ToConMapRuneBool(data map[rune]bool) *ConMapRuneBool {
	if data == nil {
		data = make(map[rune]bool)
	}
	return &ConMapRuneBool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given rune key.
func (cm *ConMapRuneBool) Get(k rune) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneBool) GetOK(k rune) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified rune key.
func (cm *ConMapRuneBool) Set(k rune, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneBool) Delete(k rune) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given rune key.
func (cm *ConMapRuneBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Byte=BUILTINS"

// ConMapRuneByte is a concurrent safe wrapper around a
// map[Rune]Byte.
type ConMapRuneByte struct {
	// M is the underlying map[Rune]Byte.
	M map[rune]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneByte creates a new concurrent safe map storing byte values,
// for rune keys.
func NewConMapRuneByte() *ConMapRuneByte {
	return ToConMapRuneByte(nil)
}

// ToConMapRuneByte creates a new ConMapRuneByte prepopulated
// with the data from the specified map[Rune]Byte.
func ToConMapRuneByte(data map[rune]byte) *ConMapRuneByte {
	if data == nil {
		data = make(map[rune]byte)
	}
	return &ConMapRuneByte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given rune key.
func (cm *ConMapRuneByte) Get(k rune) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneByte) GetOK(k rune) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified rune key.
func (cm *ConMapRuneByte) Set(k rune, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneByte) Delete(k rune) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given rune key.
func (cm *ConMapRuneByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Complex128=BUILTINS"

// ConMapRuneComplex128 is a concurrent safe wrapper around a
// map[Rune]Complex128.
type ConMapRuneComplex128 struct {
	// M is the underlying map[Rune]Complex128.
	M map[rune]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneComplex128 creates a new concurrent safe map storing complex128 values,
// for rune keys.
func NewConMapRuneComplex128() *ConMapRuneComplex128 {
	return ToConMapRuneComplex128(nil)
}

// ToConMapRuneComplex128 creates a new ConMapRuneComplex128 prepopulated
// with the data from the specified map[Rune]Complex128.
func ToConMapRuneComplex128(data map[rune]complex128) *ConMapRuneComplex128 {
	if data == nil {
		data = make(map[rune]complex128)
	}
	return &ConMapRuneComplex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given rune key.
func (cm *ConMapRuneComplex128) Get(k rune) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneComplex128) GetOK(k rune) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified rune key.
func (cm *ConMapRuneComplex128) Set(k rune, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneComplex128) Delete(k rune) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given rune key.
func (cm *ConMapRuneComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Complex64=BUILTINS"

// ConMapRuneComplex64 is a concurrent safe wrapper around a
// map[Rune]Complex64.
type ConMapRuneComplex64 struct {
	// M is the underlying map[Rune]Complex64.
	M map[rune]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneComplex64 creates a new concurrent safe map storing complex64 values,
// for rune keys.
func NewConMapRuneComplex64() *ConMapRuneComplex64 {
	return ToConMapRuneComplex64(nil)
}

// ToConMapRuneComplex64 creates a new ConMapRuneComplex64 prepopulated
// with the data from the specified map[Rune]Complex64.
func ToConMapRuneComplex64(data map[rune]complex64) *ConMapRuneComplex64 {
	if data == nil {
		data = make(map[rune]complex64)
	}
	return &ConMapRuneComplex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given rune key.
func (cm *ConMapRuneComplex64) Get(k rune) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneComplex64) GetOK(k rune) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified rune key.
func (cm *ConMapRuneComplex64) Set(k rune, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneComplex64) Delete(k rune) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given rune key.
func (cm *ConMapRuneComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Error=BUILTINS"

// ConMapRuneError is a concurrent safe wrapper around a
// map[Rune]Error.
type ConMapRuneError struct {
	// M is the underlying map[Rune]Error.
	M map[rune]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneError creates a new concurrent safe map storing error values,
// for rune keys.
func NewConMapRuneError() *ConMapRuneError {
	return ToConMapRuneError(nil)
}

// ToConMapRuneError creates a new ConMapRuneError prepopulated
// with the data from the specified map[Rune]Error.
func ToConMapRuneError(data map[rune]error) *ConMapRuneError {
	if data == nil {
		data = make(map[rune]error)
	}
	return &ConMapRuneError{M: data}
}

//var nilError error

// Get gets the error value for the given rune key.
func (cm *ConMapRuneError) Get(k rune) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneError) GetOK(k rune) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified rune key.
func (cm *ConMapRuneError) Set(k rune, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneError) Delete(k rune) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given rune key.
func (cm *ConMapRuneError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Float32=BUILTINS"

// ConMapRuneFloat32 is a concurrent safe wrapper around a
// map[Rune]Float32.
type ConMapRuneFloat32 struct {
	// M is the underlying map[Rune]Float32.
	M map[rune]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneFloat32 creates a new concurrent safe map storing float32 values,
// for rune keys.
func NewConMapRuneFloat32() *ConMapRuneFloat32 {
	return ToConMapRuneFloat32(nil)
}

// ToConMapRuneFloat32 creates a new ConMapRuneFloat32 prepopulated
// with the data from the specified map[Rune]Float32.
func ToConMapRuneFloat32(data map[rune]float32) *ConMapRuneFloat32 {
	if data == nil {
		data = make(map[rune]float32)
	}
	return &ConMapRuneFloat32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given rune key.
func (cm *ConMapRuneFloat32) Get(k rune) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneFloat32) GetOK(k rune) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified rune key.
func (cm *ConMapRuneFloat32) Set(k rune, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneFloat32) Delete(k rune) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given rune key.
func (cm *ConMapRuneFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Float64=BUILTINS"

// ConMapRuneFloat64 is a concurrent safe wrapper around a
// map[Rune]Float64.
type ConMapRuneFloat64 struct {
	// M is the underlying map[Rune]Float64.
	M map[rune]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneFloat64 creates a new concurrent safe map storing float64 values,
// for rune keys.
func NewConMapRuneFloat64() *ConMapRuneFloat64 {
	return ToConMapRuneFloat64(nil)
}

// ToConMapRuneFloat64 creates a new ConMapRuneFloat64 prepopulated
// with the data from the specified map[Rune]Float64.
func ToConMapRuneFloat64(data map[rune]float64) *ConMapRuneFloat64 {
	if data == nil {
		data = make(map[rune]float64)
	}
	return &ConMapRuneFloat64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given rune key.
func (cm *ConMapRuneFloat64) Get(k rune) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneFloat64) GetOK(k rune) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified rune key.
func (cm *ConMapRuneFloat64) Set(k rune, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneFloat64) Delete(k rune) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given rune key.
func (cm *ConMapRuneFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Int=BUILTINS"

// ConMapRuneInt is a concurrent safe wrapper around a
// map[Rune]Int.
type ConMapRuneInt struct {
	// M is the underlying map[Rune]Int.
	M map[rune]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneInt creates a new concurrent safe map storing int values,
// for rune keys.
func NewConMapRuneInt() *ConMapRuneInt {
	return ToConMapRuneInt(nil)
}

// ToConMapRuneInt creates a new ConMapRuneInt prepopulated
// with the data from the specified map[Rune]Int.
func ToConMapRuneInt(data map[rune]int) *ConMapRuneInt {
	if data == nil {
		data = make(map[rune]int)
	}
	return &ConMapRuneInt{M: data}
}

//var nilInt int

// Get gets the int value for the given rune key.
func (cm *ConMapRuneInt) Get(k rune) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneInt) GetOK(k rune) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified rune key.
func (cm *ConMapRuneInt) Set(k rune, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneInt) Delete(k rune) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given rune key.
func (cm *ConMapRuneInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Int16=BUILTINS"

// ConMapRuneInt16 is a concurrent safe wrapper around a
// map[Rune]Int16.
type ConMapRuneInt16 struct {
	// M is the underlying map[Rune]Int16.
	M map[rune]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneInt16 creates a new concurrent safe map storing int16 values,
// for rune keys.
func NewConMapRuneInt16() *ConMapRuneInt16 {
	return ToConMapRuneInt16(nil)
}

// ToConMapRuneInt16 creates a new ConMapRuneInt16 prepopulated
// with the data from the specified map[Rune]Int16.
func ToConMapRuneInt16(data map[rune]int16) *ConMapRuneInt16 {
	if data == nil {
		data = make(map[rune]int16)
	}
	return &ConMapRuneInt16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given rune key.
func (cm *ConMapRuneInt16) Get(k rune) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneInt16) GetOK(k rune) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified rune key.
func (cm *ConMapRuneInt16) Set(k rune, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneInt16) Delete(k rune) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given rune key.
func (cm *ConMapRuneInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Int32=BUILTINS"

// ConMapRuneInt32 is a concurrent safe wrapper around a
// map[Rune]Int32.
type ConMapRuneInt32 struct {
	// M is the underlying map[Rune]Int32.
	M map[rune]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneInt32 creates a new concurrent safe map storing int32 values,
// for rune keys.
func NewConMapRuneInt32() *ConMapRuneInt32 {
	return ToConMapRuneInt32(nil)
}

// ToConMapRuneInt32 creates a new ConMapRuneInt32 prepopulated
// with the data from the specified map[Rune]Int32.
func ToConMapRuneInt32(data map[rune]int32) *ConMapRuneInt32 {
	if data == nil {
		data = make(map[rune]int32)
	}
	return &ConMapRuneInt32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given rune key.
func (cm *ConMapRuneInt32) Get(k rune) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneInt32) GetOK(k rune) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified rune key.
func (cm *ConMapRuneInt32) Set(k rune, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneInt32) Delete(k rune) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given rune key.
func (cm *ConMapRuneInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Int64=BUILTINS"

// ConMapRuneInt64 is a concurrent safe wrapper around a
// map[Rune]Int64.
type ConMapRuneInt64 struct {
	// M is the underlying map[Rune]Int64.
	M map[rune]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneInt64 creates a new concurrent safe map storing int64 values,
// for rune keys.
func NewConMapRuneInt64() *ConMapRuneInt64 {
	return ToConMapRuneInt64(nil)
}

// ToConMapRuneInt64 creates a new ConMapRuneInt64 prepopulated
// with the data from the specified map[Rune]Int64.
func ToConMapRuneInt64(data map[rune]int64) *ConMapRuneInt64 {
	if data == nil {
		data = make(map[rune]int64)
	}
	return &ConMapRuneInt64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given rune key.
func (cm *ConMapRuneInt64) Get(k rune) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneInt64) GetOK(k rune) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified rune key.
func (cm *ConMapRuneInt64) Set(k rune, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneInt64) Delete(k rune) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given rune key.
func (cm *ConMapRuneInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Int8=BUILTINS"

// ConMapRuneInt8 is a concurrent safe wrapper around a
// map[Rune]Int8.
type ConMapRuneInt8 struct {
	// M is the underlying map[Rune]Int8.
	M map[rune]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneInt8 creates a new concurrent safe map storing int8 values,
// for rune keys.
func NewConMapRuneInt8() *ConMapRuneInt8 {
	return ToConMapRuneInt8(nil)
}

// ToConMapRuneInt8 creates a new ConMapRuneInt8 prepopulated
// with the data from the specified map[Rune]Int8.
func ToConMapRuneInt8(data map[rune]int8) *ConMapRuneInt8 {
	if data == nil {
		data = make(map[rune]int8)
	}
	return &ConMapRuneInt8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given rune key.
func (cm *ConMapRuneInt8) Get(k rune) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneInt8) GetOK(k rune) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified rune key.
func (cm *ConMapRuneInt8) Set(k rune, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneInt8) Delete(k rune) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given rune key.
func (cm *ConMapRuneInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Rune=BUILTINS"

// ConMapRuneRune is a concurrent safe wrapper around a
// map[Rune]Rune.
type ConMapRuneRune struct {
	// M is the underlying map[Rune]Rune.
	M map[rune]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneRune creates a new concurrent safe map storing rune values,
// for rune keys.
func NewConMapRuneRune() *ConMapRuneRune {
	return ToConMapRuneRune(nil)
}

// ToConMapRuneRune creates a new ConMapRuneRune prepopulated
// with the data from the specified map[Rune]Rune.
func ToConMapRuneRune(data map[rune]rune) *ConMapRuneRune {
	if data == nil {
		data = make(map[rune]rune)
	}
	return &ConMapRuneRune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given rune key.
func (cm *ConMapRuneRune) Get(k rune) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneRune) GetOK(k rune) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified rune key.
func (cm *ConMapRuneRune) Set(k rune, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneRune) Delete(k rune) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given rune key.
func (cm *ConMapRuneRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS String=BUILTINS"

// ConMapRuneString is a concurrent safe wrapper around a
// map[Rune]String.
type ConMapRuneString struct {
	// M is the underlying map[Rune]String.
	M map[rune]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneString creates a new concurrent safe map storing string values,
// for rune keys.
func NewConMapRuneString() *ConMapRuneString {
	return ToConMapRuneString(nil)
}

// ToConMapRuneString creates a new ConMapRuneString prepopulated
// with the data from the specified map[Rune]String.
func ToConMapRuneString(data map[rune]string) *ConMapRuneString {
	if data == nil {
		data = make(map[rune]string)
	}
	return &ConMapRuneString{M: data}
}

//var nilString string

// Get gets the string value for the given rune key.
func (cm *ConMapRuneString) Get(k rune) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneString) GetOK(k rune) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified rune key.
func (cm *ConMapRuneString) Set(k rune, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneString) Delete(k rune) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given rune key.
func (cm *ConMapRuneString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Uint=BUILTINS"

// ConMapRuneUint is a concurrent safe wrapper around a
// map[Rune]Uint.
type ConMapRuneUint struct {
	// M is the underlying map[Rune]Uint.
	M map[rune]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneUint creates a new concurrent safe map storing uint values,
// for rune keys.
func NewConMapRuneUint() *ConMapRuneUint {
	return ToConMapRuneUint(nil)
}

// ToConMapRuneUint creates a new ConMapRuneUint prepopulated
// with the data from the specified map[Rune]Uint.
func ToConMapRuneUint(data map[rune]uint) *ConMapRuneUint {
	if data == nil {
		data = make(map[rune]uint)
	}
	return &ConMapRuneUint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given rune key.
func (cm *ConMapRuneUint) Get(k rune) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneUint) GetOK(k rune) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified rune key.
func (cm *ConMapRuneUint) Set(k rune, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneUint) Delete(k rune) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given rune key.
func (cm *ConMapRuneUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Uint16=BUILTINS"

// ConMapRuneUint16 is a concurrent safe wrapper around a
// map[Rune]Uint16.
type ConMapRuneUint16 struct {
	// M is the underlying map[Rune]Uint16.
	M map[rune]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneUint16 creates a new concurrent safe map storing uint16 values,
// for rune keys.
func NewConMapRuneUint16() *ConMapRuneUint16 {
	return ToConMapRuneUint16(nil)
}

// ToConMapRuneUint16 creates a new ConMapRuneUint16 prepopulated
// with the data from the specified map[Rune]Uint16.
func ToConMapRuneUint16(data map[rune]uint16) *ConMapRuneUint16 {
	if data == nil {
		data = make(map[rune]uint16)
	}
	return &ConMapRuneUint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given rune key.
func (cm *ConMapRuneUint16) Get(k rune) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneUint16) GetOK(k rune) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified rune key.
func (cm *ConMapRuneUint16) Set(k rune, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneUint16) Delete(k rune) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given rune key.
func (cm *ConMapRuneUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Uint32=BUILTINS"

// ConMapRuneUint32 is a concurrent safe wrapper around a
// map[Rune]Uint32.
type ConMapRuneUint32 struct {
	// M is the underlying map[Rune]Uint32.
	M map[rune]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneUint32 creates a new concurrent safe map storing uint32 values,
// for rune keys.
func NewConMapRuneUint32() *ConMapRuneUint32 {
	return ToConMapRuneUint32(nil)
}

// ToConMapRuneUint32 creates a new ConMapRuneUint32 prepopulated
// with the data from the specified map[Rune]Uint32.
func ToConMapRuneUint32(data map[rune]uint32) *ConMapRuneUint32 {
	if data == nil {
		data = make(map[rune]uint32)
	}
	return &ConMapRuneUint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given rune key.
func (cm *ConMapRuneUint32) Get(k rune) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneUint32) GetOK(k rune) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified rune key.
func (cm *ConMapRuneUint32) Set(k rune, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneUint32) Delete(k rune) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given rune key.
func (cm *ConMapRuneUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Uint64=BUILTINS"

// ConMapRuneUint64 is a concurrent safe wrapper around a
// map[Rune]Uint64.
type ConMapRuneUint64 struct {
	// M is the underlying map[Rune]Uint64.
	M map[rune]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneUint64 creates a new concurrent safe map storing uint64 values,
// for rune keys.
func NewConMapRuneUint64() *ConMapRuneUint64 {
	return ToConMapRuneUint64(nil)
}

// ToConMapRuneUint64 creates a new ConMapRuneUint64 prepopulated
// with the data from the specified map[Rune]Uint64.
func ToConMapRuneUint64(data map[rune]uint64) *ConMapRuneUint64 {
	if data == nil {
		data = make(map[rune]uint64)
	}
	return &ConMapRuneUint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given rune key.
func (cm *ConMapRuneUint64) Get(k rune) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneUint64) GetOK(k rune) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified rune key.
func (cm *ConMapRuneUint64) Set(k rune, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneUint64) Delete(k rune) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given rune key.
func (cm *ConMapRuneUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Uint8=BUILTINS"

// ConMapRuneUint8 is a concurrent safe wrapper around a
// map[Rune]Uint8.
type ConMapRuneUint8 struct {
	// M is the underlying map[Rune]Uint8.
	M map[rune]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneUint8 creates a new concurrent safe map storing uint8 values,
// for rune keys.
func NewConMapRuneUint8() *ConMapRuneUint8 {
	return ToConMapRuneUint8(nil)
}

// ToConMapRuneUint8 creates a new ConMapRuneUint8 prepopulated
// with the data from the specified map[Rune]Uint8.
func ToConMapRuneUint8(data map[rune]uint8) *ConMapRuneUint8 {
	if data == nil {
		data = make(map[rune]uint8)
	}
	return &ConMapRuneUint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given rune key.
func (cm *ConMapRuneUint8) Get(k rune) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneUint8) GetOK(k rune) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified rune key.
func (cm *ConMapRuneUint8) Set(k rune, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneUint8) Delete(k rune) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given rune key.
func (cm *ConMapRuneUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Rune=BUILTINS Uintptr=BUILTINS"

// ConMapRuneUintptr is a concurrent safe wrapper around a
// map[Rune]Uintptr.
type ConMapRuneUintptr struct {
	// M is the underlying map[Rune]Uintptr.
	M map[rune]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapRuneUintptr creates a new concurrent safe map storing uintptr values,
// for rune keys.
func NewConMapRuneUintptr() *ConMapRuneUintptr {
	return ToConMapRuneUintptr(nil)
}

// ToConMapRuneUintptr creates a new ConMapRuneUintptr prepopulated
// with the data from the specified map[Rune]Uintptr.
func ToConMapRuneUintptr(data map[rune]uintptr) *ConMapRuneUintptr {
	if data == nil {
		data = make(map[rune]uintptr)
	}
	return &ConMapRuneUintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given rune key.
func (cm *ConMapRuneUintptr) Get(k rune) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given rune key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapRuneUintptr) GetOK(k rune) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified rune key.
func (cm *ConMapRuneUintptr) Set(k rune, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified rune key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapRuneUintptr) Delete(k rune) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given rune key.
func (cm *ConMapRuneUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Bool=BUILTINS"

// ConMapStringBool is a concurrent safe wrapper around a
// map[String]Bool.
type ConMapStringBool struct {
	// M is the underlying map[String]Bool.
	M map[string]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringBool creates a new concurrent safe map storing bool values,
// for string keys.
func NewConMapStringBool() *ConMapStringBool {
	return ToConMapStringBool(nil)
}

// ToConMapStringBool creates a new ConMapStringBool prepopulated
// with the data from the specified map[String]Bool.
func ToConMapStringBool(data map[string]bool) *ConMapStringBool {
	if data == nil {
		data = make(map[string]bool)
	}
	return &ConMapStringBool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given string key.
func (cm *ConMapStringBool) Get(k string) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringBool) GetOK(k string) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified string key.
func (cm *ConMapStringBool) Set(k string, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringBool) Delete(k string) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given string key.
func (cm *ConMapStringBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Byte=BUILTINS"

// ConMapStringByte is a concurrent safe wrapper around a
// map[String]Byte.
type ConMapStringByte struct {
	// M is the underlying map[String]Byte.
	M map[string]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringByte creates a new concurrent safe map storing byte values,
// for string keys.
func NewConMapStringByte() *ConMapStringByte {
	return ToConMapStringByte(nil)
}

// ToConMapStringByte creates a new ConMapStringByte prepopulated
// with the data from the specified map[String]Byte.
func ToConMapStringByte(data map[string]byte) *ConMapStringByte {
	if data == nil {
		data = make(map[string]byte)
	}
	return &ConMapStringByte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given string key.
func (cm *ConMapStringByte) Get(k string) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringByte) GetOK(k string) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified string key.
func (cm *ConMapStringByte) Set(k string, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringByte) Delete(k string) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given string key.
func (cm *ConMapStringByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Complex128=BUILTINS"

// ConMapStringComplex128 is a concurrent safe wrapper around a
// map[String]Complex128.
type ConMapStringComplex128 struct {
	// M is the underlying map[String]Complex128.
	M map[string]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringComplex128 creates a new concurrent safe map storing complex128 values,
// for string keys.
func NewConMapStringComplex128() *ConMapStringComplex128 {
	return ToConMapStringComplex128(nil)
}

// ToConMapStringComplex128 creates a new ConMapStringComplex128 prepopulated
// with the data from the specified map[String]Complex128.
func ToConMapStringComplex128(data map[string]complex128) *ConMapStringComplex128 {
	if data == nil {
		data = make(map[string]complex128)
	}
	return &ConMapStringComplex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given string key.
func (cm *ConMapStringComplex128) Get(k string) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringComplex128) GetOK(k string) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified string key.
func (cm *ConMapStringComplex128) Set(k string, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringComplex128) Delete(k string) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given string key.
func (cm *ConMapStringComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Complex64=BUILTINS"

// ConMapStringComplex64 is a concurrent safe wrapper around a
// map[String]Complex64.
type ConMapStringComplex64 struct {
	// M is the underlying map[String]Complex64.
	M map[string]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringComplex64 creates a new concurrent safe map storing complex64 values,
// for string keys.
func NewConMapStringComplex64() *ConMapStringComplex64 {
	return ToConMapStringComplex64(nil)
}

// ToConMapStringComplex64 creates a new ConMapStringComplex64 prepopulated
// with the data from the specified map[String]Complex64.
func ToConMapStringComplex64(data map[string]complex64) *ConMapStringComplex64 {
	if data == nil {
		data = make(map[string]complex64)
	}
	return &ConMapStringComplex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given string key.
func (cm *ConMapStringComplex64) Get(k string) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringComplex64) GetOK(k string) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified string key.
func (cm *ConMapStringComplex64) Set(k string, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringComplex64) Delete(k string) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given string key.
func (cm *ConMapStringComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Error=BUILTINS"

// ConMapStringError is a concurrent safe wrapper around a
// map[String]Error.
type ConMapStringError struct {
	// M is the underlying map[String]Error.
	M map[string]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringError creates a new concurrent safe map storing error values,
// for string keys.
func NewConMapStringError() *ConMapStringError {
	return ToConMapStringError(nil)
}

// ToConMapStringError creates a new ConMapStringError prepopulated
// with the data from the specified map[String]Error.
func ToConMapStringError(data map[string]error) *ConMapStringError {
	if data == nil {
		data = make(map[string]error)
	}
	return &ConMapStringError{M: data}
}

//var nilError error

// Get gets the error value for the given string key.
func (cm *ConMapStringError) Get(k string) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringError) GetOK(k string) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified string key.
func (cm *ConMapStringError) Set(k string, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringError) Delete(k string) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given string key.
func (cm *ConMapStringError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Float32=BUILTINS"

// ConMapStringFloat32 is a concurrent safe wrapper around a
// map[String]Float32.
type ConMapStringFloat32 struct {
	// M is the underlying map[String]Float32.
	M map[string]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringFloat32 creates a new concurrent safe map storing float32 values,
// for string keys.
func NewConMapStringFloat32() *ConMapStringFloat32 {
	return ToConMapStringFloat32(nil)
}

// ToConMapStringFloat32 creates a new ConMapStringFloat32 prepopulated
// with the data from the specified map[String]Float32.
func ToConMapStringFloat32(data map[string]float32) *ConMapStringFloat32 {
	if data == nil {
		data = make(map[string]float32)
	}
	return &ConMapStringFloat32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given string key.
func (cm *ConMapStringFloat32) Get(k string) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringFloat32) GetOK(k string) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified string key.
func (cm *ConMapStringFloat32) Set(k string, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringFloat32) Delete(k string) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given string key.
func (cm *ConMapStringFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Float64=BUILTINS"

// ConMapStringFloat64 is a concurrent safe wrapper around a
// map[String]Float64.
type ConMapStringFloat64 struct {
	// M is the underlying map[String]Float64.
	M map[string]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringFloat64 creates a new concurrent safe map storing float64 values,
// for string keys.
func NewConMapStringFloat64() *ConMapStringFloat64 {
	return ToConMapStringFloat64(nil)
}

// ToConMapStringFloat64 creates a new ConMapStringFloat64 prepopulated
// with the data from the specified map[String]Float64.
func ToConMapStringFloat64(data map[string]float64) *ConMapStringFloat64 {
	if data == nil {
		data = make(map[string]float64)
	}
	return &ConMapStringFloat64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given string key.
func (cm *ConMapStringFloat64) Get(k string) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringFloat64) GetOK(k string) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified string key.
func (cm *ConMapStringFloat64) Set(k string, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringFloat64) Delete(k string) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given string key.
func (cm *ConMapStringFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Int=BUILTINS"

// ConMapStringInt is a concurrent safe wrapper around a
// map[String]Int.
type ConMapStringInt struct {
	// M is the underlying map[String]Int.
	M map[string]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringInt creates a new concurrent safe map storing int values,
// for string keys.
func NewConMapStringInt() *ConMapStringInt {
	return ToConMapStringInt(nil)
}

// ToConMapStringInt creates a new ConMapStringInt prepopulated
// with the data from the specified map[String]Int.
func ToConMapStringInt(data map[string]int) *ConMapStringInt {
	if data == nil {
		data = make(map[string]int)
	}
	return &ConMapStringInt{M: data}
}

//var nilInt int

// Get gets the int value for the given string key.
func (cm *ConMapStringInt) Get(k string) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringInt) GetOK(k string) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified string key.
func (cm *ConMapStringInt) Set(k string, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringInt) Delete(k string) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given string key.
func (cm *ConMapStringInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Int16=BUILTINS"

// ConMapStringInt16 is a concurrent safe wrapper around a
// map[String]Int16.
type ConMapStringInt16 struct {
	// M is the underlying map[String]Int16.
	M map[string]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringInt16 creates a new concurrent safe map storing int16 values,
// for string keys.
func NewConMapStringInt16() *ConMapStringInt16 {
	return ToConMapStringInt16(nil)
}

// ToConMapStringInt16 creates a new ConMapStringInt16 prepopulated
// with the data from the specified map[String]Int16.
func ToConMapStringInt16(data map[string]int16) *ConMapStringInt16 {
	if data == nil {
		data = make(map[string]int16)
	}
	return &ConMapStringInt16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given string key.
func (cm *ConMapStringInt16) Get(k string) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringInt16) GetOK(k string) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified string key.
func (cm *ConMapStringInt16) Set(k string, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringInt16) Delete(k string) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given string key.
func (cm *ConMapStringInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Int32=BUILTINS"

// ConMapStringInt32 is a concurrent safe wrapper around a
// map[String]Int32.
type ConMapStringInt32 struct {
	// M is the underlying map[String]Int32.
	M map[string]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringInt32 creates a new concurrent safe map storing int32 values,
// for string keys.
func NewConMapStringInt32() *ConMapStringInt32 {
	return ToConMapStringInt32(nil)
}

// ToConMapStringInt32 creates a new ConMapStringInt32 prepopulated
// with the data from the specified map[String]Int32.
func ToConMapStringInt32(data map[string]int32) *ConMapStringInt32 {
	if data == nil {
		data = make(map[string]int32)
	}
	return &ConMapStringInt32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given string key.
func (cm *ConMapStringInt32) Get(k string) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringInt32) GetOK(k string) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified string key.
func (cm *ConMapStringInt32) Set(k string, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringInt32) Delete(k string) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given string key.
func (cm *ConMapStringInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Int64=BUILTINS"

// ConMapStringInt64 is a concurrent safe wrapper around a
// map[String]Int64.
type ConMapStringInt64 struct {
	// M is the underlying map[String]Int64.
	M map[string]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringInt64 creates a new concurrent safe map storing int64 values,
// for string keys.
func NewConMapStringInt64() *ConMapStringInt64 {
	return ToConMapStringInt64(nil)
}

// ToConMapStringInt64 creates a new ConMapStringInt64 prepopulated
// with the data from the specified map[String]Int64.
func ToConMapStringInt64(data map[string]int64) *ConMapStringInt64 {
	if data == nil {
		data = make(map[string]int64)
	}
	return &ConMapStringInt64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given string key.
func (cm *ConMapStringInt64) Get(k string) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringInt64) GetOK(k string) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified string key.
func (cm *ConMapStringInt64) Set(k string, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringInt64) Delete(k string) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given string key.
func (cm *ConMapStringInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Int8=BUILTINS"

// ConMapStringInt8 is a concurrent safe wrapper around a
// map[String]Int8.
type ConMapStringInt8 struct {
	// M is the underlying map[String]Int8.
	M map[string]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringInt8 creates a new concurrent safe map storing int8 values,
// for string keys.
func NewConMapStringInt8() *ConMapStringInt8 {
	return ToConMapStringInt8(nil)
}

// ToConMapStringInt8 creates a new ConMapStringInt8 prepopulated
// with the data from the specified map[String]Int8.
func ToConMapStringInt8(data map[string]int8) *ConMapStringInt8 {
	if data == nil {
		data = make(map[string]int8)
	}
	return &ConMapStringInt8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given string key.
func (cm *ConMapStringInt8) Get(k string) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringInt8) GetOK(k string) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified string key.
func (cm *ConMapStringInt8) Set(k string, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringInt8) Delete(k string) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given string key.
func (cm *ConMapStringInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Rune=BUILTINS"

// ConMapStringRune is a concurrent safe wrapper around a
// map[String]Rune.
type ConMapStringRune struct {
	// M is the underlying map[String]Rune.
	M map[string]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringRune creates a new concurrent safe map storing rune values,
// for string keys.
func NewConMapStringRune() *ConMapStringRune {
	return ToConMapStringRune(nil)
}

// ToConMapStringRune creates a new ConMapStringRune prepopulated
// with the data from the specified map[String]Rune.
func ToConMapStringRune(data map[string]rune) *ConMapStringRune {
	if data == nil {
		data = make(map[string]rune)
	}
	return &ConMapStringRune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given string key.
func (cm *ConMapStringRune) Get(k string) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringRune) GetOK(k string) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified string key.
func (cm *ConMapStringRune) Set(k string, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringRune) Delete(k string) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given string key.
func (cm *ConMapStringRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS String=BUILTINS"

// ConMapStringString is a concurrent safe wrapper around a
// map[String]String.
type ConMapStringString struct {
	// M is the underlying map[String]String.
	M map[string]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringString creates a new concurrent safe map storing string values,
// for string keys.
func NewConMapStringString() *ConMapStringString {
	return ToConMapStringString(nil)
}

// ToConMapStringString creates a new ConMapStringString prepopulated
// with the data from the specified map[String]String.
func ToConMapStringString(data map[string]string) *ConMapStringString {
	if data == nil {
		data = make(map[string]string)
	}
	return &ConMapStringString{M: data}
}

//var nilString string

// Get gets the string value for the given string key.
func (cm *ConMapStringString) Get(k string) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringString) GetOK(k string) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified string key.
func (cm *ConMapStringString) Set(k string, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringString) Delete(k string) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given string key.
func (cm *ConMapStringString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Uint=BUILTINS"

// ConMapStringUint is a concurrent safe wrapper around a
// map[String]Uint.
type ConMapStringUint struct {
	// M is the underlying map[String]Uint.
	M map[string]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringUint creates a new concurrent safe map storing uint values,
// for string keys.
func NewConMapStringUint() *ConMapStringUint {
	return ToConMapStringUint(nil)
}

// ToConMapStringUint creates a new ConMapStringUint prepopulated
// with the data from the specified map[String]Uint.
func ToConMapStringUint(data map[string]uint) *ConMapStringUint {
	if data == nil {
		data = make(map[string]uint)
	}
	return &ConMapStringUint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given string key.
func (cm *ConMapStringUint) Get(k string) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringUint) GetOK(k string) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified string key.
func (cm *ConMapStringUint) Set(k string, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringUint) Delete(k string) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given string key.
func (cm *ConMapStringUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Uint16=BUILTINS"

// ConMapStringUint16 is a concurrent safe wrapper around a
// map[String]Uint16.
type ConMapStringUint16 struct {
	// M is the underlying map[String]Uint16.
	M map[string]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringUint16 creates a new concurrent safe map storing uint16 values,
// for string keys.
func NewConMapStringUint16() *ConMapStringUint16 {
	return ToConMapStringUint16(nil)
}

// ToConMapStringUint16 creates a new ConMapStringUint16 prepopulated
// with the data from the specified map[String]Uint16.
func ToConMapStringUint16(data map[string]uint16) *ConMapStringUint16 {
	if data == nil {
		data = make(map[string]uint16)
	}
	return &ConMapStringUint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given string key.
func (cm *ConMapStringUint16) Get(k string) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringUint16) GetOK(k string) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified string key.
func (cm *ConMapStringUint16) Set(k string, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringUint16) Delete(k string) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given string key.
func (cm *ConMapStringUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Uint32=BUILTINS"

// ConMapStringUint32 is a concurrent safe wrapper around a
// map[String]Uint32.
type ConMapStringUint32 struct {
	// M is the underlying map[String]Uint32.
	M map[string]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringUint32 creates a new concurrent safe map storing uint32 values,
// for string keys.
func NewConMapStringUint32() *ConMapStringUint32 {
	return ToConMapStringUint32(nil)
}

// ToConMapStringUint32 creates a new ConMapStringUint32 prepopulated
// with the data from the specified map[String]Uint32.
func ToConMapStringUint32(data map[string]uint32) *ConMapStringUint32 {
	if data == nil {
		data = make(map[string]uint32)
	}
	return &ConMapStringUint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given string key.
func (cm *ConMapStringUint32) Get(k string) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringUint32) GetOK(k string) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified string key.
func (cm *ConMapStringUint32) Set(k string, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringUint32) Delete(k string) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given string key.
func (cm *ConMapStringUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Uint64=BUILTINS"

// ConMapStringUint64 is a concurrent safe wrapper around a
// map[String]Uint64.
type ConMapStringUint64 struct {
	// M is the underlying map[String]Uint64.
	M map[string]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringUint64 creates a new concurrent safe map storing uint64 values,
// for string keys.
func NewConMapStringUint64() *ConMapStringUint64 {
	return ToConMapStringUint64(nil)
}

// ToConMapStringUint64 creates a new ConMapStringUint64 prepopulated
// with the data from the specified map[String]Uint64.
func ToConMapStringUint64(data map[string]uint64) *ConMapStringUint64 {
	if data == nil {
		data = make(map[string]uint64)
	}
	return &ConMapStringUint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given string key.
func (cm *ConMapStringUint64) Get(k string) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringUint64) GetOK(k string) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified string key.
func (cm *ConMapStringUint64) Set(k string, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringUint64) Delete(k string) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given string key.
func (cm *ConMapStringUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Uint8=BUILTINS"

// ConMapStringUint8 is a concurrent safe wrapper around a
// map[String]Uint8.
type ConMapStringUint8 struct {
	// M is the underlying map[String]Uint8.
	M map[string]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringUint8 creates a new concurrent safe map storing uint8 values,
// for string keys.
func NewConMapStringUint8() *ConMapStringUint8 {
	return ToConMapStringUint8(nil)
}

// ToConMapStringUint8 creates a new ConMapStringUint8 prepopulated
// with the data from the specified map[String]Uint8.
func ToConMapStringUint8(data map[string]uint8) *ConMapStringUint8 {
	if data == nil {
		data = make(map[string]uint8)
	}
	return &ConMapStringUint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given string key.
func (cm *ConMapStringUint8) Get(k string) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringUint8) GetOK(k string) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified string key.
func (cm *ConMapStringUint8) Set(k string, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringUint8) Delete(k string) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given string key.
func (cm *ConMapStringUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "String=BUILTINS Uintptr=BUILTINS"

// ConMapStringUintptr is a concurrent safe wrapper around a
// map[String]Uintptr.
type ConMapStringUintptr struct {
	// M is the underlying map[String]Uintptr.
	M map[string]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapStringUintptr creates a new concurrent safe map storing uintptr values,
// for string keys.
func NewConMapStringUintptr() *ConMapStringUintptr {
	return ToConMapStringUintptr(nil)
}

// ToConMapStringUintptr creates a new ConMapStringUintptr prepopulated
// with the data from the specified map[String]Uintptr.
func ToConMapStringUintptr(data map[string]uintptr) *ConMapStringUintptr {
	if data == nil {
		data = make(map[string]uintptr)
	}
	return &ConMapStringUintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given string key.
func (cm *ConMapStringUintptr) Get(k string) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given string key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapStringUintptr) GetOK(k string) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified string key.
func (cm *ConMapStringUintptr) Set(k string, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified string key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapStringUintptr) Delete(k string) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given string key.
func (cm *ConMapStringUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Bool=BUILTINS"

// ConMapUintBool is a concurrent safe wrapper around a
// map[Uint]Bool.
type ConMapUintBool struct {
	// M is the underlying map[Uint]Bool.
	M map[uint]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintBool creates a new concurrent safe map storing bool values,
// for uint keys.
func NewConMapUintBool() *ConMapUintBool {
	return ToConMapUintBool(nil)
}

// ToConMapUintBool creates a new ConMapUintBool prepopulated
// with the data from the specified map[Uint]Bool.
func ToConMapUintBool(data map[uint]bool) *ConMapUintBool {
	if data == nil {
		data = make(map[uint]bool)
	}
	return &ConMapUintBool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given uint key.
func (cm *ConMapUintBool) Get(k uint) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintBool) GetOK(k uint) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified uint key.
func (cm *ConMapUintBool) Set(k uint, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintBool) Delete(k uint) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given uint key.
func (cm *ConMapUintBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Byte=BUILTINS"

// ConMapUintByte is a concurrent safe wrapper around a
// map[Uint]Byte.
type ConMapUintByte struct {
	// M is the underlying map[Uint]Byte.
	M map[uint]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintByte creates a new concurrent safe map storing byte values,
// for uint keys.
func NewConMapUintByte() *ConMapUintByte {
	return ToConMapUintByte(nil)
}

// ToConMapUintByte creates a new ConMapUintByte prepopulated
// with the data from the specified map[Uint]Byte.
func ToConMapUintByte(data map[uint]byte) *ConMapUintByte {
	if data == nil {
		data = make(map[uint]byte)
	}
	return &ConMapUintByte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given uint key.
func (cm *ConMapUintByte) Get(k uint) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintByte) GetOK(k uint) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified uint key.
func (cm *ConMapUintByte) Set(k uint, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintByte) Delete(k uint) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given uint key.
func (cm *ConMapUintByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Complex128=BUILTINS"

// ConMapUintComplex128 is a concurrent safe wrapper around a
// map[Uint]Complex128.
type ConMapUintComplex128 struct {
	// M is the underlying map[Uint]Complex128.
	M map[uint]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintComplex128 creates a new concurrent safe map storing complex128 values,
// for uint keys.
func NewConMapUintComplex128() *ConMapUintComplex128 {
	return ToConMapUintComplex128(nil)
}

// ToConMapUintComplex128 creates a new ConMapUintComplex128 prepopulated
// with the data from the specified map[Uint]Complex128.
func ToConMapUintComplex128(data map[uint]complex128) *ConMapUintComplex128 {
	if data == nil {
		data = make(map[uint]complex128)
	}
	return &ConMapUintComplex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given uint key.
func (cm *ConMapUintComplex128) Get(k uint) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintComplex128) GetOK(k uint) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified uint key.
func (cm *ConMapUintComplex128) Set(k uint, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintComplex128) Delete(k uint) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given uint key.
func (cm *ConMapUintComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Complex64=BUILTINS"

// ConMapUintComplex64 is a concurrent safe wrapper around a
// map[Uint]Complex64.
type ConMapUintComplex64 struct {
	// M is the underlying map[Uint]Complex64.
	M map[uint]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintComplex64 creates a new concurrent safe map storing complex64 values,
// for uint keys.
func NewConMapUintComplex64() *ConMapUintComplex64 {
	return ToConMapUintComplex64(nil)
}

// ToConMapUintComplex64 creates a new ConMapUintComplex64 prepopulated
// with the data from the specified map[Uint]Complex64.
func ToConMapUintComplex64(data map[uint]complex64) *ConMapUintComplex64 {
	if data == nil {
		data = make(map[uint]complex64)
	}
	return &ConMapUintComplex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given uint key.
func (cm *ConMapUintComplex64) Get(k uint) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintComplex64) GetOK(k uint) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified uint key.
func (cm *ConMapUintComplex64) Set(k uint, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintComplex64) Delete(k uint) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given uint key.
func (cm *ConMapUintComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Error=BUILTINS"

// ConMapUintError is a concurrent safe wrapper around a
// map[Uint]Error.
type ConMapUintError struct {
	// M is the underlying map[Uint]Error.
	M map[uint]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintError creates a new concurrent safe map storing error values,
// for uint keys.
func NewConMapUintError() *ConMapUintError {
	return ToConMapUintError(nil)
}

// ToConMapUintError creates a new ConMapUintError prepopulated
// with the data from the specified map[Uint]Error.
func ToConMapUintError(data map[uint]error) *ConMapUintError {
	if data == nil {
		data = make(map[uint]error)
	}
	return &ConMapUintError{M: data}
}

//var nilError error

// Get gets the error value for the given uint key.
func (cm *ConMapUintError) Get(k uint) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintError) GetOK(k uint) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified uint key.
func (cm *ConMapUintError) Set(k uint, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintError) Delete(k uint) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given uint key.
func (cm *ConMapUintError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Float32=BUILTINS"

// ConMapUintFloat32 is a concurrent safe wrapper around a
// map[Uint]Float32.
type ConMapUintFloat32 struct {
	// M is the underlying map[Uint]Float32.
	M map[uint]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintFloat32 creates a new concurrent safe map storing float32 values,
// for uint keys.
func NewConMapUintFloat32() *ConMapUintFloat32 {
	return ToConMapUintFloat32(nil)
}

// ToConMapUintFloat32 creates a new ConMapUintFloat32 prepopulated
// with the data from the specified map[Uint]Float32.
func ToConMapUintFloat32(data map[uint]float32) *ConMapUintFloat32 {
	if data == nil {
		data = make(map[uint]float32)
	}
	return &ConMapUintFloat32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given uint key.
func (cm *ConMapUintFloat32) Get(k uint) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintFloat32) GetOK(k uint) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified uint key.
func (cm *ConMapUintFloat32) Set(k uint, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintFloat32) Delete(k uint) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given uint key.
func (cm *ConMapUintFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Float64=BUILTINS"

// ConMapUintFloat64 is a concurrent safe wrapper around a
// map[Uint]Float64.
type ConMapUintFloat64 struct {
	// M is the underlying map[Uint]Float64.
	M map[uint]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintFloat64 creates a new concurrent safe map storing float64 values,
// for uint keys.
func NewConMapUintFloat64() *ConMapUintFloat64 {
	return ToConMapUintFloat64(nil)
}

// ToConMapUintFloat64 creates a new ConMapUintFloat64 prepopulated
// with the data from the specified map[Uint]Float64.
func ToConMapUintFloat64(data map[uint]float64) *ConMapUintFloat64 {
	if data == nil {
		data = make(map[uint]float64)
	}
	return &ConMapUintFloat64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given uint key.
func (cm *ConMapUintFloat64) Get(k uint) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintFloat64) GetOK(k uint) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified uint key.
func (cm *ConMapUintFloat64) Set(k uint, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintFloat64) Delete(k uint) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given uint key.
func (cm *ConMapUintFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Int=BUILTINS"

// ConMapUintInt is a concurrent safe wrapper around a
// map[Uint]Int.
type ConMapUintInt struct {
	// M is the underlying map[Uint]Int.
	M map[uint]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintInt creates a new concurrent safe map storing int values,
// for uint keys.
func NewConMapUintInt() *ConMapUintInt {
	return ToConMapUintInt(nil)
}

// ToConMapUintInt creates a new ConMapUintInt prepopulated
// with the data from the specified map[Uint]Int.
func ToConMapUintInt(data map[uint]int) *ConMapUintInt {
	if data == nil {
		data = make(map[uint]int)
	}
	return &ConMapUintInt{M: data}
}

//var nilInt int

// Get gets the int value for the given uint key.
func (cm *ConMapUintInt) Get(k uint) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintInt) GetOK(k uint) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified uint key.
func (cm *ConMapUintInt) Set(k uint, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintInt) Delete(k uint) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given uint key.
func (cm *ConMapUintInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Int16=BUILTINS"

// ConMapUintInt16 is a concurrent safe wrapper around a
// map[Uint]Int16.
type ConMapUintInt16 struct {
	// M is the underlying map[Uint]Int16.
	M map[uint]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintInt16 creates a new concurrent safe map storing int16 values,
// for uint keys.
func NewConMapUintInt16() *ConMapUintInt16 {
	return ToConMapUintInt16(nil)
}

// ToConMapUintInt16 creates a new ConMapUintInt16 prepopulated
// with the data from the specified map[Uint]Int16.
func ToConMapUintInt16(data map[uint]int16) *ConMapUintInt16 {
	if data == nil {
		data = make(map[uint]int16)
	}
	return &ConMapUintInt16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given uint key.
func (cm *ConMapUintInt16) Get(k uint) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintInt16) GetOK(k uint) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified uint key.
func (cm *ConMapUintInt16) Set(k uint, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintInt16) Delete(k uint) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given uint key.
func (cm *ConMapUintInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Int32=BUILTINS"

// ConMapUintInt32 is a concurrent safe wrapper around a
// map[Uint]Int32.
type ConMapUintInt32 struct {
	// M is the underlying map[Uint]Int32.
	M map[uint]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintInt32 creates a new concurrent safe map storing int32 values,
// for uint keys.
func NewConMapUintInt32() *ConMapUintInt32 {
	return ToConMapUintInt32(nil)
}

// ToConMapUintInt32 creates a new ConMapUintInt32 prepopulated
// with the data from the specified map[Uint]Int32.
func ToConMapUintInt32(data map[uint]int32) *ConMapUintInt32 {
	if data == nil {
		data = make(map[uint]int32)
	}
	return &ConMapUintInt32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given uint key.
func (cm *ConMapUintInt32) Get(k uint) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintInt32) GetOK(k uint) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified uint key.
func (cm *ConMapUintInt32) Set(k uint, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintInt32) Delete(k uint) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given uint key.
func (cm *ConMapUintInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Int64=BUILTINS"

// ConMapUintInt64 is a concurrent safe wrapper around a
// map[Uint]Int64.
type ConMapUintInt64 struct {
	// M is the underlying map[Uint]Int64.
	M map[uint]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintInt64 creates a new concurrent safe map storing int64 values,
// for uint keys.
func NewConMapUintInt64() *ConMapUintInt64 {
	return ToConMapUintInt64(nil)
}

// ToConMapUintInt64 creates a new ConMapUintInt64 prepopulated
// with the data from the specified map[Uint]Int64.
func ToConMapUintInt64(data map[uint]int64) *ConMapUintInt64 {
	if data == nil {
		data = make(map[uint]int64)
	}
	return &ConMapUintInt64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given uint key.
func (cm *ConMapUintInt64) Get(k uint) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintInt64) GetOK(k uint) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified uint key.
func (cm *ConMapUintInt64) Set(k uint, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintInt64) Delete(k uint) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given uint key.
func (cm *ConMapUintInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Int8=BUILTINS"

// ConMapUintInt8 is a concurrent safe wrapper around a
// map[Uint]Int8.
type ConMapUintInt8 struct {
	// M is the underlying map[Uint]Int8.
	M map[uint]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintInt8 creates a new concurrent safe map storing int8 values,
// for uint keys.
func NewConMapUintInt8() *ConMapUintInt8 {
	return ToConMapUintInt8(nil)
}

// ToConMapUintInt8 creates a new ConMapUintInt8 prepopulated
// with the data from the specified map[Uint]Int8.
func ToConMapUintInt8(data map[uint]int8) *ConMapUintInt8 {
	if data == nil {
		data = make(map[uint]int8)
	}
	return &ConMapUintInt8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given uint key.
func (cm *ConMapUintInt8) Get(k uint) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintInt8) GetOK(k uint) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified uint key.
func (cm *ConMapUintInt8) Set(k uint, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintInt8) Delete(k uint) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given uint key.
func (cm *ConMapUintInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Rune=BUILTINS"

// ConMapUintRune is a concurrent safe wrapper around a
// map[Uint]Rune.
type ConMapUintRune struct {
	// M is the underlying map[Uint]Rune.
	M map[uint]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintRune creates a new concurrent safe map storing rune values,
// for uint keys.
func NewConMapUintRune() *ConMapUintRune {
	return ToConMapUintRune(nil)
}

// ToConMapUintRune creates a new ConMapUintRune prepopulated
// with the data from the specified map[Uint]Rune.
func ToConMapUintRune(data map[uint]rune) *ConMapUintRune {
	if data == nil {
		data = make(map[uint]rune)
	}
	return &ConMapUintRune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given uint key.
func (cm *ConMapUintRune) Get(k uint) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintRune) GetOK(k uint) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified uint key.
func (cm *ConMapUintRune) Set(k uint, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintRune) Delete(k uint) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given uint key.
func (cm *ConMapUintRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS String=BUILTINS"

// ConMapUintString is a concurrent safe wrapper around a
// map[Uint]String.
type ConMapUintString struct {
	// M is the underlying map[Uint]String.
	M map[uint]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintString creates a new concurrent safe map storing string values,
// for uint keys.
func NewConMapUintString() *ConMapUintString {
	return ToConMapUintString(nil)
}

// ToConMapUintString creates a new ConMapUintString prepopulated
// with the data from the specified map[Uint]String.
func ToConMapUintString(data map[uint]string) *ConMapUintString {
	if data == nil {
		data = make(map[uint]string)
	}
	return &ConMapUintString{M: data}
}

//var nilString string

// Get gets the string value for the given uint key.
func (cm *ConMapUintString) Get(k uint) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintString) GetOK(k uint) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified uint key.
func (cm *ConMapUintString) Set(k uint, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintString) Delete(k uint) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given uint key.
func (cm *ConMapUintString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Uint=BUILTINS"

// ConMapUintUint is a concurrent safe wrapper around a
// map[Uint]Uint.
type ConMapUintUint struct {
	// M is the underlying map[Uint]Uint.
	M map[uint]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintUint creates a new concurrent safe map storing uint values,
// for uint keys.
func NewConMapUintUint() *ConMapUintUint {
	return ToConMapUintUint(nil)
}

// ToConMapUintUint creates a new ConMapUintUint prepopulated
// with the data from the specified map[Uint]Uint.
func ToConMapUintUint(data map[uint]uint) *ConMapUintUint {
	if data == nil {
		data = make(map[uint]uint)
	}
	return &ConMapUintUint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given uint key.
func (cm *ConMapUintUint) Get(k uint) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintUint) GetOK(k uint) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified uint key.
func (cm *ConMapUintUint) Set(k uint, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintUint) Delete(k uint) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given uint key.
func (cm *ConMapUintUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Uint16=BUILTINS"

// ConMapUintUint16 is a concurrent safe wrapper around a
// map[Uint]Uint16.
type ConMapUintUint16 struct {
	// M is the underlying map[Uint]Uint16.
	M map[uint]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintUint16 creates a new concurrent safe map storing uint16 values,
// for uint keys.
func NewConMapUintUint16() *ConMapUintUint16 {
	return ToConMapUintUint16(nil)
}

// ToConMapUintUint16 creates a new ConMapUintUint16 prepopulated
// with the data from the specified map[Uint]Uint16.
func ToConMapUintUint16(data map[uint]uint16) *ConMapUintUint16 {
	if data == nil {
		data = make(map[uint]uint16)
	}
	return &ConMapUintUint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given uint key.
func (cm *ConMapUintUint16) Get(k uint) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintUint16) GetOK(k uint) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified uint key.
func (cm *ConMapUintUint16) Set(k uint, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintUint16) Delete(k uint) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given uint key.
func (cm *ConMapUintUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Uint32=BUILTINS"

// ConMapUintUint32 is a concurrent safe wrapper around a
// map[Uint]Uint32.
type ConMapUintUint32 struct {
	// M is the underlying map[Uint]Uint32.
	M map[uint]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintUint32 creates a new concurrent safe map storing uint32 values,
// for uint keys.
func NewConMapUintUint32() *ConMapUintUint32 {
	return ToConMapUintUint32(nil)
}

// ToConMapUintUint32 creates a new ConMapUintUint32 prepopulated
// with the data from the specified map[Uint]Uint32.
func ToConMapUintUint32(data map[uint]uint32) *ConMapUintUint32 {
	if data == nil {
		data = make(map[uint]uint32)
	}
	return &ConMapUintUint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given uint key.
func (cm *ConMapUintUint32) Get(k uint) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintUint32) GetOK(k uint) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified uint key.
func (cm *ConMapUintUint32) Set(k uint, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintUint32) Delete(k uint) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given uint key.
func (cm *ConMapUintUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Uint64=BUILTINS"

// ConMapUintUint64 is a concurrent safe wrapper around a
// map[Uint]Uint64.
type ConMapUintUint64 struct {
	// M is the underlying map[Uint]Uint64.
	M map[uint]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintUint64 creates a new concurrent safe map storing uint64 values,
// for uint keys.
func NewConMapUintUint64() *ConMapUintUint64 {
	return ToConMapUintUint64(nil)
}

// ToConMapUintUint64 creates a new ConMapUintUint64 prepopulated
// with the data from the specified map[Uint]Uint64.
func ToConMapUintUint64(data map[uint]uint64) *ConMapUintUint64 {
	if data == nil {
		data = make(map[uint]uint64)
	}
	return &ConMapUintUint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given uint key.
func (cm *ConMapUintUint64) Get(k uint) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintUint64) GetOK(k uint) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified uint key.
func (cm *ConMapUintUint64) Set(k uint, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintUint64) Delete(k uint) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given uint key.
func (cm *ConMapUintUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Uint8=BUILTINS"

// ConMapUintUint8 is a concurrent safe wrapper around a
// map[Uint]Uint8.
type ConMapUintUint8 struct {
	// M is the underlying map[Uint]Uint8.
	M map[uint]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintUint8 creates a new concurrent safe map storing uint8 values,
// for uint keys.
func NewConMapUintUint8() *ConMapUintUint8 {
	return ToConMapUintUint8(nil)
}

// ToConMapUintUint8 creates a new ConMapUintUint8 prepopulated
// with the data from the specified map[Uint]Uint8.
func ToConMapUintUint8(data map[uint]uint8) *ConMapUintUint8 {
	if data == nil {
		data = make(map[uint]uint8)
	}
	return &ConMapUintUint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given uint key.
func (cm *ConMapUintUint8) Get(k uint) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintUint8) GetOK(k uint) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified uint key.
func (cm *ConMapUintUint8) Set(k uint, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintUint8) Delete(k uint) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given uint key.
func (cm *ConMapUintUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint=BUILTINS Uintptr=BUILTINS"

// ConMapUintUintptr is a concurrent safe wrapper around a
// map[Uint]Uintptr.
type ConMapUintUintptr struct {
	// M is the underlying map[Uint]Uintptr.
	M map[uint]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintUintptr creates a new concurrent safe map storing uintptr values,
// for uint keys.
func NewConMapUintUintptr() *ConMapUintUintptr {
	return ToConMapUintUintptr(nil)
}

// ToConMapUintUintptr creates a new ConMapUintUintptr prepopulated
// with the data from the specified map[Uint]Uintptr.
func ToConMapUintUintptr(data map[uint]uintptr) *ConMapUintUintptr {
	if data == nil {
		data = make(map[uint]uintptr)
	}
	return &ConMapUintUintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given uint key.
func (cm *ConMapUintUintptr) Get(k uint) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given uint key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintUintptr) GetOK(k uint) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified uint key.
func (cm *ConMapUintUintptr) Set(k uint, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintUintptr) Delete(k uint) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given uint key.
func (cm *ConMapUintUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Bool=BUILTINS"

// ConMapUint16Bool is a concurrent safe wrapper around a
// map[Uint16]Bool.
type ConMapUint16Bool struct {
	// M is the underlying map[Uint16]Bool.
	M map[uint16]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Bool creates a new concurrent safe map storing bool values,
// for uint16 keys.
func NewConMapUint16Bool() *ConMapUint16Bool {
	return ToConMapUint16Bool(nil)
}

// ToConMapUint16Bool creates a new ConMapUint16Bool prepopulated
// with the data from the specified map[Uint16]Bool.
func ToConMapUint16Bool(data map[uint16]bool) *ConMapUint16Bool {
	if data == nil {
		data = make(map[uint16]bool)
	}
	return &ConMapUint16Bool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given uint16 key.
func (cm *ConMapUint16Bool) Get(k uint16) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Bool) GetOK(k uint16) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified uint16 key.
func (cm *ConMapUint16Bool) Set(k uint16, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Bool) Delete(k uint16) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given uint16 key.
func (cm *ConMapUint16Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Byte=BUILTINS"

// ConMapUint16Byte is a concurrent safe wrapper around a
// map[Uint16]Byte.
type ConMapUint16Byte struct {
	// M is the underlying map[Uint16]Byte.
	M map[uint16]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Byte creates a new concurrent safe map storing byte values,
// for uint16 keys.
func NewConMapUint16Byte() *ConMapUint16Byte {
	return ToConMapUint16Byte(nil)
}

// ToConMapUint16Byte creates a new ConMapUint16Byte prepopulated
// with the data from the specified map[Uint16]Byte.
func ToConMapUint16Byte(data map[uint16]byte) *ConMapUint16Byte {
	if data == nil {
		data = make(map[uint16]byte)
	}
	return &ConMapUint16Byte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given uint16 key.
func (cm *ConMapUint16Byte) Get(k uint16) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Byte) GetOK(k uint16) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified uint16 key.
func (cm *ConMapUint16Byte) Set(k uint16, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Byte) Delete(k uint16) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given uint16 key.
func (cm *ConMapUint16Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Complex128=BUILTINS"

// ConMapUint16Complex128 is a concurrent safe wrapper around a
// map[Uint16]Complex128.
type ConMapUint16Complex128 struct {
	// M is the underlying map[Uint16]Complex128.
	M map[uint16]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Complex128 creates a new concurrent safe map storing complex128 values,
// for uint16 keys.
func NewConMapUint16Complex128() *ConMapUint16Complex128 {
	return ToConMapUint16Complex128(nil)
}

// ToConMapUint16Complex128 creates a new ConMapUint16Complex128 prepopulated
// with the data from the specified map[Uint16]Complex128.
func ToConMapUint16Complex128(data map[uint16]complex128) *ConMapUint16Complex128 {
	if data == nil {
		data = make(map[uint16]complex128)
	}
	return &ConMapUint16Complex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given uint16 key.
func (cm *ConMapUint16Complex128) Get(k uint16) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Complex128) GetOK(k uint16) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified uint16 key.
func (cm *ConMapUint16Complex128) Set(k uint16, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Complex128) Delete(k uint16) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given uint16 key.
func (cm *ConMapUint16Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Complex64=BUILTINS"

// ConMapUint16Complex64 is a concurrent safe wrapper around a
// map[Uint16]Complex64.
type ConMapUint16Complex64 struct {
	// M is the underlying map[Uint16]Complex64.
	M map[uint16]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Complex64 creates a new concurrent safe map storing complex64 values,
// for uint16 keys.
func NewConMapUint16Complex64() *ConMapUint16Complex64 {
	return ToConMapUint16Complex64(nil)
}

// ToConMapUint16Complex64 creates a new ConMapUint16Complex64 prepopulated
// with the data from the specified map[Uint16]Complex64.
func ToConMapUint16Complex64(data map[uint16]complex64) *ConMapUint16Complex64 {
	if data == nil {
		data = make(map[uint16]complex64)
	}
	return &ConMapUint16Complex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given uint16 key.
func (cm *ConMapUint16Complex64) Get(k uint16) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Complex64) GetOK(k uint16) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified uint16 key.
func (cm *ConMapUint16Complex64) Set(k uint16, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Complex64) Delete(k uint16) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given uint16 key.
func (cm *ConMapUint16Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Error=BUILTINS"

// ConMapUint16Error is a concurrent safe wrapper around a
// map[Uint16]Error.
type ConMapUint16Error struct {
	// M is the underlying map[Uint16]Error.
	M map[uint16]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Error creates a new concurrent safe map storing error values,
// for uint16 keys.
func NewConMapUint16Error() *ConMapUint16Error {
	return ToConMapUint16Error(nil)
}

// ToConMapUint16Error creates a new ConMapUint16Error prepopulated
// with the data from the specified map[Uint16]Error.
func ToConMapUint16Error(data map[uint16]error) *ConMapUint16Error {
	if data == nil {
		data = make(map[uint16]error)
	}
	return &ConMapUint16Error{M: data}
}

//var nilError error

// Get gets the error value for the given uint16 key.
func (cm *ConMapUint16Error) Get(k uint16) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Error) GetOK(k uint16) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified uint16 key.
func (cm *ConMapUint16Error) Set(k uint16, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Error) Delete(k uint16) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given uint16 key.
func (cm *ConMapUint16Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Float32=BUILTINS"

// ConMapUint16Float32 is a concurrent safe wrapper around a
// map[Uint16]Float32.
type ConMapUint16Float32 struct {
	// M is the underlying map[Uint16]Float32.
	M map[uint16]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Float32 creates a new concurrent safe map storing float32 values,
// for uint16 keys.
func NewConMapUint16Float32() *ConMapUint16Float32 {
	return ToConMapUint16Float32(nil)
}

// ToConMapUint16Float32 creates a new ConMapUint16Float32 prepopulated
// with the data from the specified map[Uint16]Float32.
func ToConMapUint16Float32(data map[uint16]float32) *ConMapUint16Float32 {
	if data == nil {
		data = make(map[uint16]float32)
	}
	return &ConMapUint16Float32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given uint16 key.
func (cm *ConMapUint16Float32) Get(k uint16) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Float32) GetOK(k uint16) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified uint16 key.
func (cm *ConMapUint16Float32) Set(k uint16, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Float32) Delete(k uint16) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given uint16 key.
func (cm *ConMapUint16Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Float64=BUILTINS"

// ConMapUint16Float64 is a concurrent safe wrapper around a
// map[Uint16]Float64.
type ConMapUint16Float64 struct {
	// M is the underlying map[Uint16]Float64.
	M map[uint16]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Float64 creates a new concurrent safe map storing float64 values,
// for uint16 keys.
func NewConMapUint16Float64() *ConMapUint16Float64 {
	return ToConMapUint16Float64(nil)
}

// ToConMapUint16Float64 creates a new ConMapUint16Float64 prepopulated
// with the data from the specified map[Uint16]Float64.
func ToConMapUint16Float64(data map[uint16]float64) *ConMapUint16Float64 {
	if data == nil {
		data = make(map[uint16]float64)
	}
	return &ConMapUint16Float64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given uint16 key.
func (cm *ConMapUint16Float64) Get(k uint16) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Float64) GetOK(k uint16) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified uint16 key.
func (cm *ConMapUint16Float64) Set(k uint16, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Float64) Delete(k uint16) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given uint16 key.
func (cm *ConMapUint16Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Int=BUILTINS"

// ConMapUint16Int is a concurrent safe wrapper around a
// map[Uint16]Int.
type ConMapUint16Int struct {
	// M is the underlying map[Uint16]Int.
	M map[uint16]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Int creates a new concurrent safe map storing int values,
// for uint16 keys.
func NewConMapUint16Int() *ConMapUint16Int {
	return ToConMapUint16Int(nil)
}

// ToConMapUint16Int creates a new ConMapUint16Int prepopulated
// with the data from the specified map[Uint16]Int.
func ToConMapUint16Int(data map[uint16]int) *ConMapUint16Int {
	if data == nil {
		data = make(map[uint16]int)
	}
	return &ConMapUint16Int{M: data}
}

//var nilInt int

// Get gets the int value for the given uint16 key.
func (cm *ConMapUint16Int) Get(k uint16) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Int) GetOK(k uint16) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified uint16 key.
func (cm *ConMapUint16Int) Set(k uint16, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Int) Delete(k uint16) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given uint16 key.
func (cm *ConMapUint16Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Int16=BUILTINS"

// ConMapUint16Int16 is a concurrent safe wrapper around a
// map[Uint16]Int16.
type ConMapUint16Int16 struct {
	// M is the underlying map[Uint16]Int16.
	M map[uint16]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Int16 creates a new concurrent safe map storing int16 values,
// for uint16 keys.
func NewConMapUint16Int16() *ConMapUint16Int16 {
	return ToConMapUint16Int16(nil)
}

// ToConMapUint16Int16 creates a new ConMapUint16Int16 prepopulated
// with the data from the specified map[Uint16]Int16.
func ToConMapUint16Int16(data map[uint16]int16) *ConMapUint16Int16 {
	if data == nil {
		data = make(map[uint16]int16)
	}
	return &ConMapUint16Int16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given uint16 key.
func (cm *ConMapUint16Int16) Get(k uint16) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Int16) GetOK(k uint16) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified uint16 key.
func (cm *ConMapUint16Int16) Set(k uint16, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Int16) Delete(k uint16) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given uint16 key.
func (cm *ConMapUint16Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Int32=BUILTINS"

// ConMapUint16Int32 is a concurrent safe wrapper around a
// map[Uint16]Int32.
type ConMapUint16Int32 struct {
	// M is the underlying map[Uint16]Int32.
	M map[uint16]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Int32 creates a new concurrent safe map storing int32 values,
// for uint16 keys.
func NewConMapUint16Int32() *ConMapUint16Int32 {
	return ToConMapUint16Int32(nil)
}

// ToConMapUint16Int32 creates a new ConMapUint16Int32 prepopulated
// with the data from the specified map[Uint16]Int32.
func ToConMapUint16Int32(data map[uint16]int32) *ConMapUint16Int32 {
	if data == nil {
		data = make(map[uint16]int32)
	}
	return &ConMapUint16Int32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given uint16 key.
func (cm *ConMapUint16Int32) Get(k uint16) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Int32) GetOK(k uint16) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified uint16 key.
func (cm *ConMapUint16Int32) Set(k uint16, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Int32) Delete(k uint16) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given uint16 key.
func (cm *ConMapUint16Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Int64=BUILTINS"

// ConMapUint16Int64 is a concurrent safe wrapper around a
// map[Uint16]Int64.
type ConMapUint16Int64 struct {
	// M is the underlying map[Uint16]Int64.
	M map[uint16]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Int64 creates a new concurrent safe map storing int64 values,
// for uint16 keys.
func NewConMapUint16Int64() *ConMapUint16Int64 {
	return ToConMapUint16Int64(nil)
}

// ToConMapUint16Int64 creates a new ConMapUint16Int64 prepopulated
// with the data from the specified map[Uint16]Int64.
func ToConMapUint16Int64(data map[uint16]int64) *ConMapUint16Int64 {
	if data == nil {
		data = make(map[uint16]int64)
	}
	return &ConMapUint16Int64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given uint16 key.
func (cm *ConMapUint16Int64) Get(k uint16) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Int64) GetOK(k uint16) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified uint16 key.
func (cm *ConMapUint16Int64) Set(k uint16, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Int64) Delete(k uint16) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given uint16 key.
func (cm *ConMapUint16Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Int8=BUILTINS"

// ConMapUint16Int8 is a concurrent safe wrapper around a
// map[Uint16]Int8.
type ConMapUint16Int8 struct {
	// M is the underlying map[Uint16]Int8.
	M map[uint16]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Int8 creates a new concurrent safe map storing int8 values,
// for uint16 keys.
func NewConMapUint16Int8() *ConMapUint16Int8 {
	return ToConMapUint16Int8(nil)
}

// ToConMapUint16Int8 creates a new ConMapUint16Int8 prepopulated
// with the data from the specified map[Uint16]Int8.
func ToConMapUint16Int8(data map[uint16]int8) *ConMapUint16Int8 {
	if data == nil {
		data = make(map[uint16]int8)
	}
	return &ConMapUint16Int8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given uint16 key.
func (cm *ConMapUint16Int8) Get(k uint16) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Int8) GetOK(k uint16) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified uint16 key.
func (cm *ConMapUint16Int8) Set(k uint16, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Int8) Delete(k uint16) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given uint16 key.
func (cm *ConMapUint16Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Rune=BUILTINS"

// ConMapUint16Rune is a concurrent safe wrapper around a
// map[Uint16]Rune.
type ConMapUint16Rune struct {
	// M is the underlying map[Uint16]Rune.
	M map[uint16]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Rune creates a new concurrent safe map storing rune values,
// for uint16 keys.
func NewConMapUint16Rune() *ConMapUint16Rune {
	return ToConMapUint16Rune(nil)
}

// ToConMapUint16Rune creates a new ConMapUint16Rune prepopulated
// with the data from the specified map[Uint16]Rune.
func ToConMapUint16Rune(data map[uint16]rune) *ConMapUint16Rune {
	if data == nil {
		data = make(map[uint16]rune)
	}
	return &ConMapUint16Rune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given uint16 key.
func (cm *ConMapUint16Rune) Get(k uint16) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Rune) GetOK(k uint16) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified uint16 key.
func (cm *ConMapUint16Rune) Set(k uint16, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Rune) Delete(k uint16) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given uint16 key.
func (cm *ConMapUint16Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS String=BUILTINS"

// ConMapUint16String is a concurrent safe wrapper around a
// map[Uint16]String.
type ConMapUint16String struct {
	// M is the underlying map[Uint16]String.
	M map[uint16]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16String creates a new concurrent safe map storing string values,
// for uint16 keys.
func NewConMapUint16String() *ConMapUint16String {
	return ToConMapUint16String(nil)
}

// ToConMapUint16String creates a new ConMapUint16String prepopulated
// with the data from the specified map[Uint16]String.
func ToConMapUint16String(data map[uint16]string) *ConMapUint16String {
	if data == nil {
		data = make(map[uint16]string)
	}
	return &ConMapUint16String{M: data}
}

//var nilString string

// Get gets the string value for the given uint16 key.
func (cm *ConMapUint16String) Get(k uint16) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16String) GetOK(k uint16) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified uint16 key.
func (cm *ConMapUint16String) Set(k uint16, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16String) Delete(k uint16) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given uint16 key.
func (cm *ConMapUint16String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Uint=BUILTINS"

// ConMapUint16Uint is a concurrent safe wrapper around a
// map[Uint16]Uint.
type ConMapUint16Uint struct {
	// M is the underlying map[Uint16]Uint.
	M map[uint16]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Uint creates a new concurrent safe map storing uint values,
// for uint16 keys.
func NewConMapUint16Uint() *ConMapUint16Uint {
	return ToConMapUint16Uint(nil)
}

// ToConMapUint16Uint creates a new ConMapUint16Uint prepopulated
// with the data from the specified map[Uint16]Uint.
func ToConMapUint16Uint(data map[uint16]uint) *ConMapUint16Uint {
	if data == nil {
		data = make(map[uint16]uint)
	}
	return &ConMapUint16Uint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given uint16 key.
func (cm *ConMapUint16Uint) Get(k uint16) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Uint) GetOK(k uint16) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified uint16 key.
func (cm *ConMapUint16Uint) Set(k uint16, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Uint) Delete(k uint16) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given uint16 key.
func (cm *ConMapUint16Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Uint16=BUILTINS"

// ConMapUint16Uint16 is a concurrent safe wrapper around a
// map[Uint16]Uint16.
type ConMapUint16Uint16 struct {
	// M is the underlying map[Uint16]Uint16.
	M map[uint16]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Uint16 creates a new concurrent safe map storing uint16 values,
// for uint16 keys.
func NewConMapUint16Uint16() *ConMapUint16Uint16 {
	return ToConMapUint16Uint16(nil)
}

// ToConMapUint16Uint16 creates a new ConMapUint16Uint16 prepopulated
// with the data from the specified map[Uint16]Uint16.
func ToConMapUint16Uint16(data map[uint16]uint16) *ConMapUint16Uint16 {
	if data == nil {
		data = make(map[uint16]uint16)
	}
	return &ConMapUint16Uint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given uint16 key.
func (cm *ConMapUint16Uint16) Get(k uint16) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Uint16) GetOK(k uint16) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified uint16 key.
func (cm *ConMapUint16Uint16) Set(k uint16, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Uint16) Delete(k uint16) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given uint16 key.
func (cm *ConMapUint16Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Uint32=BUILTINS"

// ConMapUint16Uint32 is a concurrent safe wrapper around a
// map[Uint16]Uint32.
type ConMapUint16Uint32 struct {
	// M is the underlying map[Uint16]Uint32.
	M map[uint16]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Uint32 creates a new concurrent safe map storing uint32 values,
// for uint16 keys.
func NewConMapUint16Uint32() *ConMapUint16Uint32 {
	return ToConMapUint16Uint32(nil)
}

// ToConMapUint16Uint32 creates a new ConMapUint16Uint32 prepopulated
// with the data from the specified map[Uint16]Uint32.
func ToConMapUint16Uint32(data map[uint16]uint32) *ConMapUint16Uint32 {
	if data == nil {
		data = make(map[uint16]uint32)
	}
	return &ConMapUint16Uint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given uint16 key.
func (cm *ConMapUint16Uint32) Get(k uint16) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Uint32) GetOK(k uint16) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified uint16 key.
func (cm *ConMapUint16Uint32) Set(k uint16, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Uint32) Delete(k uint16) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given uint16 key.
func (cm *ConMapUint16Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Uint64=BUILTINS"

// ConMapUint16Uint64 is a concurrent safe wrapper around a
// map[Uint16]Uint64.
type ConMapUint16Uint64 struct {
	// M is the underlying map[Uint16]Uint64.
	M map[uint16]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Uint64 creates a new concurrent safe map storing uint64 values,
// for uint16 keys.
func NewConMapUint16Uint64() *ConMapUint16Uint64 {
	return ToConMapUint16Uint64(nil)
}

// ToConMapUint16Uint64 creates a new ConMapUint16Uint64 prepopulated
// with the data from the specified map[Uint16]Uint64.
func ToConMapUint16Uint64(data map[uint16]uint64) *ConMapUint16Uint64 {
	if data == nil {
		data = make(map[uint16]uint64)
	}
	return &ConMapUint16Uint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given uint16 key.
func (cm *ConMapUint16Uint64) Get(k uint16) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Uint64) GetOK(k uint16) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified uint16 key.
func (cm *ConMapUint16Uint64) Set(k uint16, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Uint64) Delete(k uint16) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given uint16 key.
func (cm *ConMapUint16Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Uint8=BUILTINS"

// ConMapUint16Uint8 is a concurrent safe wrapper around a
// map[Uint16]Uint8.
type ConMapUint16Uint8 struct {
	// M is the underlying map[Uint16]Uint8.
	M map[uint16]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Uint8 creates a new concurrent safe map storing uint8 values,
// for uint16 keys.
func NewConMapUint16Uint8() *ConMapUint16Uint8 {
	return ToConMapUint16Uint8(nil)
}

// ToConMapUint16Uint8 creates a new ConMapUint16Uint8 prepopulated
// with the data from the specified map[Uint16]Uint8.
func ToConMapUint16Uint8(data map[uint16]uint8) *ConMapUint16Uint8 {
	if data == nil {
		data = make(map[uint16]uint8)
	}
	return &ConMapUint16Uint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given uint16 key.
func (cm *ConMapUint16Uint8) Get(k uint16) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Uint8) GetOK(k uint16) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified uint16 key.
func (cm *ConMapUint16Uint8) Set(k uint16, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Uint8) Delete(k uint16) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given uint16 key.
func (cm *ConMapUint16Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint16=BUILTINS Uintptr=BUILTINS"

// ConMapUint16Uintptr is a concurrent safe wrapper around a
// map[Uint16]Uintptr.
type ConMapUint16Uintptr struct {
	// M is the underlying map[Uint16]Uintptr.
	M map[uint16]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint16Uintptr creates a new concurrent safe map storing uintptr values,
// for uint16 keys.
func NewConMapUint16Uintptr() *ConMapUint16Uintptr {
	return ToConMapUint16Uintptr(nil)
}

// ToConMapUint16Uintptr creates a new ConMapUint16Uintptr prepopulated
// with the data from the specified map[Uint16]Uintptr.
func ToConMapUint16Uintptr(data map[uint16]uintptr) *ConMapUint16Uintptr {
	if data == nil {
		data = make(map[uint16]uintptr)
	}
	return &ConMapUint16Uintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given uint16 key.
func (cm *ConMapUint16Uintptr) Get(k uint16) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given uint16 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint16Uintptr) GetOK(k uint16) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified uint16 key.
func (cm *ConMapUint16Uintptr) Set(k uint16, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint16 key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint16Uintptr) Delete(k uint16) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given uint16 key.
func (cm *ConMapUint16Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Bool=BUILTINS"

// ConMapUint32Bool is a concurrent safe wrapper around a
// map[Uint32]Bool.
type ConMapUint32Bool struct {
	// M is the underlying map[Uint32]Bool.
	M map[uint32]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Bool creates a new concurrent safe map storing bool values,
// for uint32 keys.
func NewConMapUint32Bool() *ConMapUint32Bool {
	return ToConMapUint32Bool(nil)
}

// ToConMapUint32Bool creates a new ConMapUint32Bool prepopulated
// with the data from the specified map[Uint32]Bool.
func ToConMapUint32Bool(data map[uint32]bool) *ConMapUint32Bool {
	if data == nil {
		data = make(map[uint32]bool)
	}
	return &ConMapUint32Bool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given uint32 key.
func (cm *ConMapUint32Bool) Get(k uint32) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Bool) GetOK(k uint32) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified uint32 key.
func (cm *ConMapUint32Bool) Set(k uint32, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Bool) Delete(k uint32) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given uint32 key.
func (cm *ConMapUint32Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Byte=BUILTINS"

// ConMapUint32Byte is a concurrent safe wrapper around a
// map[Uint32]Byte.
type ConMapUint32Byte struct {
	// M is the underlying map[Uint32]Byte.
	M map[uint32]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Byte creates a new concurrent safe map storing byte values,
// for uint32 keys.
func NewConMapUint32Byte() *ConMapUint32Byte {
	return ToConMapUint32Byte(nil)
}

// ToConMapUint32Byte creates a new ConMapUint32Byte prepopulated
// with the data from the specified map[Uint32]Byte.
func ToConMapUint32Byte(data map[uint32]byte) *ConMapUint32Byte {
	if data == nil {
		data = make(map[uint32]byte)
	}
	return &ConMapUint32Byte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given uint32 key.
func (cm *ConMapUint32Byte) Get(k uint32) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Byte) GetOK(k uint32) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified uint32 key.
func (cm *ConMapUint32Byte) Set(k uint32, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Byte) Delete(k uint32) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given uint32 key.
func (cm *ConMapUint32Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Complex128=BUILTINS"

// ConMapUint32Complex128 is a concurrent safe wrapper around a
// map[Uint32]Complex128.
type ConMapUint32Complex128 struct {
	// M is the underlying map[Uint32]Complex128.
	M map[uint32]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Complex128 creates a new concurrent safe map storing complex128 values,
// for uint32 keys.
func NewConMapUint32Complex128() *ConMapUint32Complex128 {
	return ToConMapUint32Complex128(nil)
}

// ToConMapUint32Complex128 creates a new ConMapUint32Complex128 prepopulated
// with the data from the specified map[Uint32]Complex128.
func ToConMapUint32Complex128(data map[uint32]complex128) *ConMapUint32Complex128 {
	if data == nil {
		data = make(map[uint32]complex128)
	}
	return &ConMapUint32Complex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given uint32 key.
func (cm *ConMapUint32Complex128) Get(k uint32) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Complex128) GetOK(k uint32) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified uint32 key.
func (cm *ConMapUint32Complex128) Set(k uint32, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Complex128) Delete(k uint32) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given uint32 key.
func (cm *ConMapUint32Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Complex64=BUILTINS"

// ConMapUint32Complex64 is a concurrent safe wrapper around a
// map[Uint32]Complex64.
type ConMapUint32Complex64 struct {
	// M is the underlying map[Uint32]Complex64.
	M map[uint32]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Complex64 creates a new concurrent safe map storing complex64 values,
// for uint32 keys.
func NewConMapUint32Complex64() *ConMapUint32Complex64 {
	return ToConMapUint32Complex64(nil)
}

// ToConMapUint32Complex64 creates a new ConMapUint32Complex64 prepopulated
// with the data from the specified map[Uint32]Complex64.
func ToConMapUint32Complex64(data map[uint32]complex64) *ConMapUint32Complex64 {
	if data == nil {
		data = make(map[uint32]complex64)
	}
	return &ConMapUint32Complex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given uint32 key.
func (cm *ConMapUint32Complex64) Get(k uint32) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Complex64) GetOK(k uint32) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified uint32 key.
func (cm *ConMapUint32Complex64) Set(k uint32, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Complex64) Delete(k uint32) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given uint32 key.
func (cm *ConMapUint32Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Error=BUILTINS"

// ConMapUint32Error is a concurrent safe wrapper around a
// map[Uint32]Error.
type ConMapUint32Error struct {
	// M is the underlying map[Uint32]Error.
	M map[uint32]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Error creates a new concurrent safe map storing error values,
// for uint32 keys.
func NewConMapUint32Error() *ConMapUint32Error {
	return ToConMapUint32Error(nil)
}

// ToConMapUint32Error creates a new ConMapUint32Error prepopulated
// with the data from the specified map[Uint32]Error.
func ToConMapUint32Error(data map[uint32]error) *ConMapUint32Error {
	if data == nil {
		data = make(map[uint32]error)
	}
	return &ConMapUint32Error{M: data}
}

//var nilError error

// Get gets the error value for the given uint32 key.
func (cm *ConMapUint32Error) Get(k uint32) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Error) GetOK(k uint32) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified uint32 key.
func (cm *ConMapUint32Error) Set(k uint32, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Error) Delete(k uint32) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given uint32 key.
func (cm *ConMapUint32Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Float32=BUILTINS"

// ConMapUint32Float32 is a concurrent safe wrapper around a
// map[Uint32]Float32.
type ConMapUint32Float32 struct {
	// M is the underlying map[Uint32]Float32.
	M map[uint32]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Float32 creates a new concurrent safe map storing float32 values,
// for uint32 keys.
func NewConMapUint32Float32() *ConMapUint32Float32 {
	return ToConMapUint32Float32(nil)
}

// ToConMapUint32Float32 creates a new ConMapUint32Float32 prepopulated
// with the data from the specified map[Uint32]Float32.
func ToConMapUint32Float32(data map[uint32]float32) *ConMapUint32Float32 {
	if data == nil {
		data = make(map[uint32]float32)
	}
	return &ConMapUint32Float32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given uint32 key.
func (cm *ConMapUint32Float32) Get(k uint32) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Float32) GetOK(k uint32) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified uint32 key.
func (cm *ConMapUint32Float32) Set(k uint32, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Float32) Delete(k uint32) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given uint32 key.
func (cm *ConMapUint32Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Float64=BUILTINS"

// ConMapUint32Float64 is a concurrent safe wrapper around a
// map[Uint32]Float64.
type ConMapUint32Float64 struct {
	// M is the underlying map[Uint32]Float64.
	M map[uint32]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Float64 creates a new concurrent safe map storing float64 values,
// for uint32 keys.
func NewConMapUint32Float64() *ConMapUint32Float64 {
	return ToConMapUint32Float64(nil)
}

// ToConMapUint32Float64 creates a new ConMapUint32Float64 prepopulated
// with the data from the specified map[Uint32]Float64.
func ToConMapUint32Float64(data map[uint32]float64) *ConMapUint32Float64 {
	if data == nil {
		data = make(map[uint32]float64)
	}
	return &ConMapUint32Float64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given uint32 key.
func (cm *ConMapUint32Float64) Get(k uint32) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Float64) GetOK(k uint32) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified uint32 key.
func (cm *ConMapUint32Float64) Set(k uint32, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Float64) Delete(k uint32) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given uint32 key.
func (cm *ConMapUint32Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Int=BUILTINS"

// ConMapUint32Int is a concurrent safe wrapper around a
// map[Uint32]Int.
type ConMapUint32Int struct {
	// M is the underlying map[Uint32]Int.
	M map[uint32]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Int creates a new concurrent safe map storing int values,
// for uint32 keys.
func NewConMapUint32Int() *ConMapUint32Int {
	return ToConMapUint32Int(nil)
}

// ToConMapUint32Int creates a new ConMapUint32Int prepopulated
// with the data from the specified map[Uint32]Int.
func ToConMapUint32Int(data map[uint32]int) *ConMapUint32Int {
	if data == nil {
		data = make(map[uint32]int)
	}
	return &ConMapUint32Int{M: data}
}

//var nilInt int

// Get gets the int value for the given uint32 key.
func (cm *ConMapUint32Int) Get(k uint32) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Int) GetOK(k uint32) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified uint32 key.
func (cm *ConMapUint32Int) Set(k uint32, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Int) Delete(k uint32) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given uint32 key.
func (cm *ConMapUint32Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Int16=BUILTINS"

// ConMapUint32Int16 is a concurrent safe wrapper around a
// map[Uint32]Int16.
type ConMapUint32Int16 struct {
	// M is the underlying map[Uint32]Int16.
	M map[uint32]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Int16 creates a new concurrent safe map storing int16 values,
// for uint32 keys.
func NewConMapUint32Int16() *ConMapUint32Int16 {
	return ToConMapUint32Int16(nil)
}

// ToConMapUint32Int16 creates a new ConMapUint32Int16 prepopulated
// with the data from the specified map[Uint32]Int16.
func ToConMapUint32Int16(data map[uint32]int16) *ConMapUint32Int16 {
	if data == nil {
		data = make(map[uint32]int16)
	}
	return &ConMapUint32Int16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given uint32 key.
func (cm *ConMapUint32Int16) Get(k uint32) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Int16) GetOK(k uint32) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified uint32 key.
func (cm *ConMapUint32Int16) Set(k uint32, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Int16) Delete(k uint32) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given uint32 key.
func (cm *ConMapUint32Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Int32=BUILTINS"

// ConMapUint32Int32 is a concurrent safe wrapper around a
// map[Uint32]Int32.
type ConMapUint32Int32 struct {
	// M is the underlying map[Uint32]Int32.
	M map[uint32]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Int32 creates a new concurrent safe map storing int32 values,
// for uint32 keys.
func NewConMapUint32Int32() *ConMapUint32Int32 {
	return ToConMapUint32Int32(nil)
}

// ToConMapUint32Int32 creates a new ConMapUint32Int32 prepopulated
// with the data from the specified map[Uint32]Int32.
func ToConMapUint32Int32(data map[uint32]int32) *ConMapUint32Int32 {
	if data == nil {
		data = make(map[uint32]int32)
	}
	return &ConMapUint32Int32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given uint32 key.
func (cm *ConMapUint32Int32) Get(k uint32) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Int32) GetOK(k uint32) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified uint32 key.
func (cm *ConMapUint32Int32) Set(k uint32, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Int32) Delete(k uint32) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given uint32 key.
func (cm *ConMapUint32Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Int64=BUILTINS"

// ConMapUint32Int64 is a concurrent safe wrapper around a
// map[Uint32]Int64.
type ConMapUint32Int64 struct {
	// M is the underlying map[Uint32]Int64.
	M map[uint32]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Int64 creates a new concurrent safe map storing int64 values,
// for uint32 keys.
func NewConMapUint32Int64() *ConMapUint32Int64 {
	return ToConMapUint32Int64(nil)
}

// ToConMapUint32Int64 creates a new ConMapUint32Int64 prepopulated
// with the data from the specified map[Uint32]Int64.
func ToConMapUint32Int64(data map[uint32]int64) *ConMapUint32Int64 {
	if data == nil {
		data = make(map[uint32]int64)
	}
	return &ConMapUint32Int64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given uint32 key.
func (cm *ConMapUint32Int64) Get(k uint32) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Int64) GetOK(k uint32) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified uint32 key.
func (cm *ConMapUint32Int64) Set(k uint32, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Int64) Delete(k uint32) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given uint32 key.
func (cm *ConMapUint32Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Int8=BUILTINS"

// ConMapUint32Int8 is a concurrent safe wrapper around a
// map[Uint32]Int8.
type ConMapUint32Int8 struct {
	// M is the underlying map[Uint32]Int8.
	M map[uint32]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Int8 creates a new concurrent safe map storing int8 values,
// for uint32 keys.
func NewConMapUint32Int8() *ConMapUint32Int8 {
	return ToConMapUint32Int8(nil)
}

// ToConMapUint32Int8 creates a new ConMapUint32Int8 prepopulated
// with the data from the specified map[Uint32]Int8.
func ToConMapUint32Int8(data map[uint32]int8) *ConMapUint32Int8 {
	if data == nil {
		data = make(map[uint32]int8)
	}
	return &ConMapUint32Int8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given uint32 key.
func (cm *ConMapUint32Int8) Get(k uint32) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Int8) GetOK(k uint32) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified uint32 key.
func (cm *ConMapUint32Int8) Set(k uint32, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Int8) Delete(k uint32) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given uint32 key.
func (cm *ConMapUint32Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Rune=BUILTINS"

// ConMapUint32Rune is a concurrent safe wrapper around a
// map[Uint32]Rune.
type ConMapUint32Rune struct {
	// M is the underlying map[Uint32]Rune.
	M map[uint32]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Rune creates a new concurrent safe map storing rune values,
// for uint32 keys.
func NewConMapUint32Rune() *ConMapUint32Rune {
	return ToConMapUint32Rune(nil)
}

// ToConMapUint32Rune creates a new ConMapUint32Rune prepopulated
// with the data from the specified map[Uint32]Rune.
func ToConMapUint32Rune(data map[uint32]rune) *ConMapUint32Rune {
	if data == nil {
		data = make(map[uint32]rune)
	}
	return &ConMapUint32Rune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given uint32 key.
func (cm *ConMapUint32Rune) Get(k uint32) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Rune) GetOK(k uint32) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified uint32 key.
func (cm *ConMapUint32Rune) Set(k uint32, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Rune) Delete(k uint32) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given uint32 key.
func (cm *ConMapUint32Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS String=BUILTINS"

// ConMapUint32String is a concurrent safe wrapper around a
// map[Uint32]String.
type ConMapUint32String struct {
	// M is the underlying map[Uint32]String.
	M map[uint32]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32String creates a new concurrent safe map storing string values,
// for uint32 keys.
func NewConMapUint32String() *ConMapUint32String {
	return ToConMapUint32String(nil)
}

// ToConMapUint32String creates a new ConMapUint32String prepopulated
// with the data from the specified map[Uint32]String.
func ToConMapUint32String(data map[uint32]string) *ConMapUint32String {
	if data == nil {
		data = make(map[uint32]string)
	}
	return &ConMapUint32String{M: data}
}

//var nilString string

// Get gets the string value for the given uint32 key.
func (cm *ConMapUint32String) Get(k uint32) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32String) GetOK(k uint32) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified uint32 key.
func (cm *ConMapUint32String) Set(k uint32, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32String) Delete(k uint32) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given uint32 key.
func (cm *ConMapUint32String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Uint=BUILTINS"

// ConMapUint32Uint is a concurrent safe wrapper around a
// map[Uint32]Uint.
type ConMapUint32Uint struct {
	// M is the underlying map[Uint32]Uint.
	M map[uint32]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Uint creates a new concurrent safe map storing uint values,
// for uint32 keys.
func NewConMapUint32Uint() *ConMapUint32Uint {
	return ToConMapUint32Uint(nil)
}

// ToConMapUint32Uint creates a new ConMapUint32Uint prepopulated
// with the data from the specified map[Uint32]Uint.
func ToConMapUint32Uint(data map[uint32]uint) *ConMapUint32Uint {
	if data == nil {
		data = make(map[uint32]uint)
	}
	return &ConMapUint32Uint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given uint32 key.
func (cm *ConMapUint32Uint) Get(k uint32) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Uint) GetOK(k uint32) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified uint32 key.
func (cm *ConMapUint32Uint) Set(k uint32, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Uint) Delete(k uint32) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given uint32 key.
func (cm *ConMapUint32Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Uint16=BUILTINS"

// ConMapUint32Uint16 is a concurrent safe wrapper around a
// map[Uint32]Uint16.
type ConMapUint32Uint16 struct {
	// M is the underlying map[Uint32]Uint16.
	M map[uint32]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Uint16 creates a new concurrent safe map storing uint16 values,
// for uint32 keys.
func NewConMapUint32Uint16() *ConMapUint32Uint16 {
	return ToConMapUint32Uint16(nil)
}

// ToConMapUint32Uint16 creates a new ConMapUint32Uint16 prepopulated
// with the data from the specified map[Uint32]Uint16.
func ToConMapUint32Uint16(data map[uint32]uint16) *ConMapUint32Uint16 {
	if data == nil {
		data = make(map[uint32]uint16)
	}
	return &ConMapUint32Uint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given uint32 key.
func (cm *ConMapUint32Uint16) Get(k uint32) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Uint16) GetOK(k uint32) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified uint32 key.
func (cm *ConMapUint32Uint16) Set(k uint32, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Uint16) Delete(k uint32) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given uint32 key.
func (cm *ConMapUint32Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Uint32=BUILTINS"

// ConMapUint32Uint32 is a concurrent safe wrapper around a
// map[Uint32]Uint32.
type ConMapUint32Uint32 struct {
	// M is the underlying map[Uint32]Uint32.
	M map[uint32]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Uint32 creates a new concurrent safe map storing uint32 values,
// for uint32 keys.
func NewConMapUint32Uint32() *ConMapUint32Uint32 {
	return ToConMapUint32Uint32(nil)
}

// ToConMapUint32Uint32 creates a new ConMapUint32Uint32 prepopulated
// with the data from the specified map[Uint32]Uint32.
func ToConMapUint32Uint32(data map[uint32]uint32) *ConMapUint32Uint32 {
	if data == nil {
		data = make(map[uint32]uint32)
	}
	return &ConMapUint32Uint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given uint32 key.
func (cm *ConMapUint32Uint32) Get(k uint32) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Uint32) GetOK(k uint32) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified uint32 key.
func (cm *ConMapUint32Uint32) Set(k uint32, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Uint32) Delete(k uint32) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given uint32 key.
func (cm *ConMapUint32Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Uint64=BUILTINS"

// ConMapUint32Uint64 is a concurrent safe wrapper around a
// map[Uint32]Uint64.
type ConMapUint32Uint64 struct {
	// M is the underlying map[Uint32]Uint64.
	M map[uint32]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Uint64 creates a new concurrent safe map storing uint64 values,
// for uint32 keys.
func NewConMapUint32Uint64() *ConMapUint32Uint64 {
	return ToConMapUint32Uint64(nil)
}

// ToConMapUint32Uint64 creates a new ConMapUint32Uint64 prepopulated
// with the data from the specified map[Uint32]Uint64.
func ToConMapUint32Uint64(data map[uint32]uint64) *ConMapUint32Uint64 {
	if data == nil {
		data = make(map[uint32]uint64)
	}
	return &ConMapUint32Uint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given uint32 key.
func (cm *ConMapUint32Uint64) Get(k uint32) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Uint64) GetOK(k uint32) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified uint32 key.
func (cm *ConMapUint32Uint64) Set(k uint32, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Uint64) Delete(k uint32) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given uint32 key.
func (cm *ConMapUint32Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Uint8=BUILTINS"

// ConMapUint32Uint8 is a concurrent safe wrapper around a
// map[Uint32]Uint8.
type ConMapUint32Uint8 struct {
	// M is the underlying map[Uint32]Uint8.
	M map[uint32]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Uint8 creates a new concurrent safe map storing uint8 values,
// for uint32 keys.
func NewConMapUint32Uint8() *ConMapUint32Uint8 {
	return ToConMapUint32Uint8(nil)
}

// ToConMapUint32Uint8 creates a new ConMapUint32Uint8 prepopulated
// with the data from the specified map[Uint32]Uint8.
func ToConMapUint32Uint8(data map[uint32]uint8) *ConMapUint32Uint8 {
	if data == nil {
		data = make(map[uint32]uint8)
	}
	return &ConMapUint32Uint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given uint32 key.
func (cm *ConMapUint32Uint8) Get(k uint32) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Uint8) GetOK(k uint32) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified uint32 key.
func (cm *ConMapUint32Uint8) Set(k uint32, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Uint8) Delete(k uint32) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given uint32 key.
func (cm *ConMapUint32Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint32=BUILTINS Uintptr=BUILTINS"

// ConMapUint32Uintptr is a concurrent safe wrapper around a
// map[Uint32]Uintptr.
type ConMapUint32Uintptr struct {
	// M is the underlying map[Uint32]Uintptr.
	M map[uint32]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint32Uintptr creates a new concurrent safe map storing uintptr values,
// for uint32 keys.
func NewConMapUint32Uintptr() *ConMapUint32Uintptr {
	return ToConMapUint32Uintptr(nil)
}

// ToConMapUint32Uintptr creates a new ConMapUint32Uintptr prepopulated
// with the data from the specified map[Uint32]Uintptr.
func ToConMapUint32Uintptr(data map[uint32]uintptr) *ConMapUint32Uintptr {
	if data == nil {
		data = make(map[uint32]uintptr)
	}
	return &ConMapUint32Uintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given uint32 key.
func (cm *ConMapUint32Uintptr) Get(k uint32) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given uint32 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint32Uintptr) GetOK(k uint32) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified uint32 key.
func (cm *ConMapUint32Uintptr) Set(k uint32, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint32 key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint32Uintptr) Delete(k uint32) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given uint32 key.
func (cm *ConMapUint32Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Bool=BUILTINS"

// ConMapUint64Bool is a concurrent safe wrapper around a
// map[Uint64]Bool.
type ConMapUint64Bool struct {
	// M is the underlying map[Uint64]Bool.
	M map[uint64]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Bool creates a new concurrent safe map storing bool values,
// for uint64 keys.
func NewConMapUint64Bool() *ConMapUint64Bool {
	return ToConMapUint64Bool(nil)
}

// ToConMapUint64Bool creates a new ConMapUint64Bool prepopulated
// with the data from the specified map[Uint64]Bool.
func ToConMapUint64Bool(data map[uint64]bool) *ConMapUint64Bool {
	if data == nil {
		data = make(map[uint64]bool)
	}
	return &ConMapUint64Bool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given uint64 key.
func (cm *ConMapUint64Bool) Get(k uint64) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Bool) GetOK(k uint64) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified uint64 key.
func (cm *ConMapUint64Bool) Set(k uint64, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Bool) Delete(k uint64) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given uint64 key.
func (cm *ConMapUint64Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Byte=BUILTINS"

// ConMapUint64Byte is a concurrent safe wrapper around a
// map[Uint64]Byte.
type ConMapUint64Byte struct {
	// M is the underlying map[Uint64]Byte.
	M map[uint64]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Byte creates a new concurrent safe map storing byte values,
// for uint64 keys.
func NewConMapUint64Byte() *ConMapUint64Byte {
	return ToConMapUint64Byte(nil)
}

// ToConMapUint64Byte creates a new ConMapUint64Byte prepopulated
// with the data from the specified map[Uint64]Byte.
func ToConMapUint64Byte(data map[uint64]byte) *ConMapUint64Byte {
	if data == nil {
		data = make(map[uint64]byte)
	}
	return &ConMapUint64Byte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given uint64 key.
func (cm *ConMapUint64Byte) Get(k uint64) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Byte) GetOK(k uint64) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified uint64 key.
func (cm *ConMapUint64Byte) Set(k uint64, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Byte) Delete(k uint64) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given uint64 key.
func (cm *ConMapUint64Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Complex128=BUILTINS"

// ConMapUint64Complex128 is a concurrent safe wrapper around a
// map[Uint64]Complex128.
type ConMapUint64Complex128 struct {
	// M is the underlying map[Uint64]Complex128.
	M map[uint64]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Complex128 creates a new concurrent safe map storing complex128 values,
// for uint64 keys.
func NewConMapUint64Complex128() *ConMapUint64Complex128 {
	return ToConMapUint64Complex128(nil)
}

// ToConMapUint64Complex128 creates a new ConMapUint64Complex128 prepopulated
// with the data from the specified map[Uint64]Complex128.
func ToConMapUint64Complex128(data map[uint64]complex128) *ConMapUint64Complex128 {
	if data == nil {
		data = make(map[uint64]complex128)
	}
	return &ConMapUint64Complex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given uint64 key.
func (cm *ConMapUint64Complex128) Get(k uint64) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Complex128) GetOK(k uint64) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified uint64 key.
func (cm *ConMapUint64Complex128) Set(k uint64, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Complex128) Delete(k uint64) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given uint64 key.
func (cm *ConMapUint64Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Complex64=BUILTINS"

// ConMapUint64Complex64 is a concurrent safe wrapper around a
// map[Uint64]Complex64.
type ConMapUint64Complex64 struct {
	// M is the underlying map[Uint64]Complex64.
	M map[uint64]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Complex64 creates a new concurrent safe map storing complex64 values,
// for uint64 keys.
func NewConMapUint64Complex64() *ConMapUint64Complex64 {
	return ToConMapUint64Complex64(nil)
}

// ToConMapUint64Complex64 creates a new ConMapUint64Complex64 prepopulated
// with the data from the specified map[Uint64]Complex64.
func ToConMapUint64Complex64(data map[uint64]complex64) *ConMapUint64Complex64 {
	if data == nil {
		data = make(map[uint64]complex64)
	}
	return &ConMapUint64Complex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given uint64 key.
func (cm *ConMapUint64Complex64) Get(k uint64) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Complex64) GetOK(k uint64) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified uint64 key.
func (cm *ConMapUint64Complex64) Set(k uint64, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Complex64) Delete(k uint64) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given uint64 key.
func (cm *ConMapUint64Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Error=BUILTINS"

// ConMapUint64Error is a concurrent safe wrapper around a
// map[Uint64]Error.
type ConMapUint64Error struct {
	// M is the underlying map[Uint64]Error.
	M map[uint64]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Error creates a new concurrent safe map storing error values,
// for uint64 keys.
func NewConMapUint64Error() *ConMapUint64Error {
	return ToConMapUint64Error(nil)
}

// ToConMapUint64Error creates a new ConMapUint64Error prepopulated
// with the data from the specified map[Uint64]Error.
func ToConMapUint64Error(data map[uint64]error) *ConMapUint64Error {
	if data == nil {
		data = make(map[uint64]error)
	}
	return &ConMapUint64Error{M: data}
}

//var nilError error

// Get gets the error value for the given uint64 key.
func (cm *ConMapUint64Error) Get(k uint64) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Error) GetOK(k uint64) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified uint64 key.
func (cm *ConMapUint64Error) Set(k uint64, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Error) Delete(k uint64) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given uint64 key.
func (cm *ConMapUint64Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Float32=BUILTINS"

// ConMapUint64Float32 is a concurrent safe wrapper around a
// map[Uint64]Float32.
type ConMapUint64Float32 struct {
	// M is the underlying map[Uint64]Float32.
	M map[uint64]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Float32 creates a new concurrent safe map storing float32 values,
// for uint64 keys.
func NewConMapUint64Float32() *ConMapUint64Float32 {
	return ToConMapUint64Float32(nil)
}

// ToConMapUint64Float32 creates a new ConMapUint64Float32 prepopulated
// with the data from the specified map[Uint64]Float32.
func ToConMapUint64Float32(data map[uint64]float32) *ConMapUint64Float32 {
	if data == nil {
		data = make(map[uint64]float32)
	}
	return &ConMapUint64Float32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given uint64 key.
func (cm *ConMapUint64Float32) Get(k uint64) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Float32) GetOK(k uint64) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified uint64 key.
func (cm *ConMapUint64Float32) Set(k uint64, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Float32) Delete(k uint64) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given uint64 key.
func (cm *ConMapUint64Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Float64=BUILTINS"

// ConMapUint64Float64 is a concurrent safe wrapper around a
// map[Uint64]Float64.
type ConMapUint64Float64 struct {
	// M is the underlying map[Uint64]Float64.
	M map[uint64]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Float64 creates a new concurrent safe map storing float64 values,
// for uint64 keys.
func NewConMapUint64Float64() *ConMapUint64Float64 {
	return ToConMapUint64Float64(nil)
}

// ToConMapUint64Float64 creates a new ConMapUint64Float64 prepopulated
// with the data from the specified map[Uint64]Float64.
func ToConMapUint64Float64(data map[uint64]float64) *ConMapUint64Float64 {
	if data == nil {
		data = make(map[uint64]float64)
	}
	return &ConMapUint64Float64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given uint64 key.
func (cm *ConMapUint64Float64) Get(k uint64) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Float64) GetOK(k uint64) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified uint64 key.
func (cm *ConMapUint64Float64) Set(k uint64, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Float64) Delete(k uint64) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given uint64 key.
func (cm *ConMapUint64Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Int=BUILTINS"

// ConMapUint64Int is a concurrent safe wrapper around a
// map[Uint64]Int.
type ConMapUint64Int struct {
	// M is the underlying map[Uint64]Int.
	M map[uint64]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Int creates a new concurrent safe map storing int values,
// for uint64 keys.
func NewConMapUint64Int() *ConMapUint64Int {
	return ToConMapUint64Int(nil)
}

// ToConMapUint64Int creates a new ConMapUint64Int prepopulated
// with the data from the specified map[Uint64]Int.
func ToConMapUint64Int(data map[uint64]int) *ConMapUint64Int {
	if data == nil {
		data = make(map[uint64]int)
	}
	return &ConMapUint64Int{M: data}
}

//var nilInt int

// Get gets the int value for the given uint64 key.
func (cm *ConMapUint64Int) Get(k uint64) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Int) GetOK(k uint64) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified uint64 key.
func (cm *ConMapUint64Int) Set(k uint64, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Int) Delete(k uint64) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given uint64 key.
func (cm *ConMapUint64Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Int16=BUILTINS"

// ConMapUint64Int16 is a concurrent safe wrapper around a
// map[Uint64]Int16.
type ConMapUint64Int16 struct {
	// M is the underlying map[Uint64]Int16.
	M map[uint64]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Int16 creates a new concurrent safe map storing int16 values,
// for uint64 keys.
func NewConMapUint64Int16() *ConMapUint64Int16 {
	return ToConMapUint64Int16(nil)
}

// ToConMapUint64Int16 creates a new ConMapUint64Int16 prepopulated
// with the data from the specified map[Uint64]Int16.
func ToConMapUint64Int16(data map[uint64]int16) *ConMapUint64Int16 {
	if data == nil {
		data = make(map[uint64]int16)
	}
	return &ConMapUint64Int16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given uint64 key.
func (cm *ConMapUint64Int16) Get(k uint64) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Int16) GetOK(k uint64) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified uint64 key.
func (cm *ConMapUint64Int16) Set(k uint64, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Int16) Delete(k uint64) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given uint64 key.
func (cm *ConMapUint64Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Int32=BUILTINS"

// ConMapUint64Int32 is a concurrent safe wrapper around a
// map[Uint64]Int32.
type ConMapUint64Int32 struct {
	// M is the underlying map[Uint64]Int32.
	M map[uint64]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Int32 creates a new concurrent safe map storing int32 values,
// for uint64 keys.
func NewConMapUint64Int32() *ConMapUint64Int32 {
	return ToConMapUint64Int32(nil)
}

// ToConMapUint64Int32 creates a new ConMapUint64Int32 prepopulated
// with the data from the specified map[Uint64]Int32.
func ToConMapUint64Int32(data map[uint64]int32) *ConMapUint64Int32 {
	if data == nil {
		data = make(map[uint64]int32)
	}
	return &ConMapUint64Int32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given uint64 key.
func (cm *ConMapUint64Int32) Get(k uint64) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Int32) GetOK(k uint64) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified uint64 key.
func (cm *ConMapUint64Int32) Set(k uint64, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Int32) Delete(k uint64) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given uint64 key.
func (cm *ConMapUint64Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Int64=BUILTINS"

// ConMapUint64Int64 is a concurrent safe wrapper around a
// map[Uint64]Int64.
type ConMapUint64Int64 struct {
	// M is the underlying map[Uint64]Int64.
	M map[uint64]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Int64 creates a new concurrent safe map storing int64 values,
// for uint64 keys.
func NewConMapUint64Int64() *ConMapUint64Int64 {
	return ToConMapUint64Int64(nil)
}

// ToConMapUint64Int64 creates a new ConMapUint64Int64 prepopulated
// with the data from the specified map[Uint64]Int64.
func ToConMapUint64Int64(data map[uint64]int64) *ConMapUint64Int64 {
	if data == nil {
		data = make(map[uint64]int64)
	}
	return &ConMapUint64Int64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given uint64 key.
func (cm *ConMapUint64Int64) Get(k uint64) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Int64) GetOK(k uint64) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified uint64 key.
func (cm *ConMapUint64Int64) Set(k uint64, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Int64) Delete(k uint64) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given uint64 key.
func (cm *ConMapUint64Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Int8=BUILTINS"

// ConMapUint64Int8 is a concurrent safe wrapper around a
// map[Uint64]Int8.
type ConMapUint64Int8 struct {
	// M is the underlying map[Uint64]Int8.
	M map[uint64]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Int8 creates a new concurrent safe map storing int8 values,
// for uint64 keys.
func NewConMapUint64Int8() *ConMapUint64Int8 {
	return ToConMapUint64Int8(nil)
}

// ToConMapUint64Int8 creates a new ConMapUint64Int8 prepopulated
// with the data from the specified map[Uint64]Int8.
func ToConMapUint64Int8(data map[uint64]int8) *ConMapUint64Int8 {
	if data == nil {
		data = make(map[uint64]int8)
	}
	return &ConMapUint64Int8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given uint64 key.
func (cm *ConMapUint64Int8) Get(k uint64) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Int8) GetOK(k uint64) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified uint64 key.
func (cm *ConMapUint64Int8) Set(k uint64, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Int8) Delete(k uint64) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given uint64 key.
func (cm *ConMapUint64Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Rune=BUILTINS"

// ConMapUint64Rune is a concurrent safe wrapper around a
// map[Uint64]Rune.
type ConMapUint64Rune struct {
	// M is the underlying map[Uint64]Rune.
	M map[uint64]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Rune creates a new concurrent safe map storing rune values,
// for uint64 keys.
func NewConMapUint64Rune() *ConMapUint64Rune {
	return ToConMapUint64Rune(nil)
}

// ToConMapUint64Rune creates a new ConMapUint64Rune prepopulated
// with the data from the specified map[Uint64]Rune.
func ToConMapUint64Rune(data map[uint64]rune) *ConMapUint64Rune {
	if data == nil {
		data = make(map[uint64]rune)
	}
	return &ConMapUint64Rune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given uint64 key.
func (cm *ConMapUint64Rune) Get(k uint64) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Rune) GetOK(k uint64) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified uint64 key.
func (cm *ConMapUint64Rune) Set(k uint64, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Rune) Delete(k uint64) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given uint64 key.
func (cm *ConMapUint64Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS String=BUILTINS"

// ConMapUint64String is a concurrent safe wrapper around a
// map[Uint64]String.
type ConMapUint64String struct {
	// M is the underlying map[Uint64]String.
	M map[uint64]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64String creates a new concurrent safe map storing string values,
// for uint64 keys.
func NewConMapUint64String() *ConMapUint64String {
	return ToConMapUint64String(nil)
}

// ToConMapUint64String creates a new ConMapUint64String prepopulated
// with the data from the specified map[Uint64]String.
func ToConMapUint64String(data map[uint64]string) *ConMapUint64String {
	if data == nil {
		data = make(map[uint64]string)
	}
	return &ConMapUint64String{M: data}
}

//var nilString string

// Get gets the string value for the given uint64 key.
func (cm *ConMapUint64String) Get(k uint64) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64String) GetOK(k uint64) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified uint64 key.
func (cm *ConMapUint64String) Set(k uint64, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64String) Delete(k uint64) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given uint64 key.
func (cm *ConMapUint64String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Uint=BUILTINS"

// ConMapUint64Uint is a concurrent safe wrapper around a
// map[Uint64]Uint.
type ConMapUint64Uint struct {
	// M is the underlying map[Uint64]Uint.
	M map[uint64]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Uint creates a new concurrent safe map storing uint values,
// for uint64 keys.
func NewConMapUint64Uint() *ConMapUint64Uint {
	return ToConMapUint64Uint(nil)
}

// ToConMapUint64Uint creates a new ConMapUint64Uint prepopulated
// with the data from the specified map[Uint64]Uint.
func ToConMapUint64Uint(data map[uint64]uint) *ConMapUint64Uint {
	if data == nil {
		data = make(map[uint64]uint)
	}
	return &ConMapUint64Uint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given uint64 key.
func (cm *ConMapUint64Uint) Get(k uint64) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Uint) GetOK(k uint64) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified uint64 key.
func (cm *ConMapUint64Uint) Set(k uint64, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Uint) Delete(k uint64) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given uint64 key.
func (cm *ConMapUint64Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Uint16=BUILTINS"

// ConMapUint64Uint16 is a concurrent safe wrapper around a
// map[Uint64]Uint16.
type ConMapUint64Uint16 struct {
	// M is the underlying map[Uint64]Uint16.
	M map[uint64]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Uint16 creates a new concurrent safe map storing uint16 values,
// for uint64 keys.
func NewConMapUint64Uint16() *ConMapUint64Uint16 {
	return ToConMapUint64Uint16(nil)
}

// ToConMapUint64Uint16 creates a new ConMapUint64Uint16 prepopulated
// with the data from the specified map[Uint64]Uint16.
func ToConMapUint64Uint16(data map[uint64]uint16) *ConMapUint64Uint16 {
	if data == nil {
		data = make(map[uint64]uint16)
	}
	return &ConMapUint64Uint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given uint64 key.
func (cm *ConMapUint64Uint16) Get(k uint64) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Uint16) GetOK(k uint64) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified uint64 key.
func (cm *ConMapUint64Uint16) Set(k uint64, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Uint16) Delete(k uint64) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given uint64 key.
func (cm *ConMapUint64Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Uint32=BUILTINS"

// ConMapUint64Uint32 is a concurrent safe wrapper around a
// map[Uint64]Uint32.
type ConMapUint64Uint32 struct {
	// M is the underlying map[Uint64]Uint32.
	M map[uint64]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Uint32 creates a new concurrent safe map storing uint32 values,
// for uint64 keys.
func NewConMapUint64Uint32() *ConMapUint64Uint32 {
	return ToConMapUint64Uint32(nil)
}

// ToConMapUint64Uint32 creates a new ConMapUint64Uint32 prepopulated
// with the data from the specified map[Uint64]Uint32.
func ToConMapUint64Uint32(data map[uint64]uint32) *ConMapUint64Uint32 {
	if data == nil {
		data = make(map[uint64]uint32)
	}
	return &ConMapUint64Uint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given uint64 key.
func (cm *ConMapUint64Uint32) Get(k uint64) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Uint32) GetOK(k uint64) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified uint64 key.
func (cm *ConMapUint64Uint32) Set(k uint64, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Uint32) Delete(k uint64) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given uint64 key.
func (cm *ConMapUint64Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Uint64=BUILTINS"

// ConMapUint64Uint64 is a concurrent safe wrapper around a
// map[Uint64]Uint64.
type ConMapUint64Uint64 struct {
	// M is the underlying map[Uint64]Uint64.
	M map[uint64]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Uint64 creates a new concurrent safe map storing uint64 values,
// for uint64 keys.
func NewConMapUint64Uint64() *ConMapUint64Uint64 {
	return ToConMapUint64Uint64(nil)
}

// ToConMapUint64Uint64 creates a new ConMapUint64Uint64 prepopulated
// with the data from the specified map[Uint64]Uint64.
func ToConMapUint64Uint64(data map[uint64]uint64) *ConMapUint64Uint64 {
	if data == nil {
		data = make(map[uint64]uint64)
	}
	return &ConMapUint64Uint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given uint64 key.
func (cm *ConMapUint64Uint64) Get(k uint64) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Uint64) GetOK(k uint64) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified uint64 key.
func (cm *ConMapUint64Uint64) Set(k uint64, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Uint64) Delete(k uint64) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given uint64 key.
func (cm *ConMapUint64Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Uint8=BUILTINS"

// ConMapUint64Uint8 is a concurrent safe wrapper around a
// map[Uint64]Uint8.
type ConMapUint64Uint8 struct {
	// M is the underlying map[Uint64]Uint8.
	M map[uint64]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Uint8 creates a new concurrent safe map storing uint8 values,
// for uint64 keys.
func NewConMapUint64Uint8() *ConMapUint64Uint8 {
	return ToConMapUint64Uint8(nil)
}

// ToConMapUint64Uint8 creates a new ConMapUint64Uint8 prepopulated
// with the data from the specified map[Uint64]Uint8.
func ToConMapUint64Uint8(data map[uint64]uint8) *ConMapUint64Uint8 {
	if data == nil {
		data = make(map[uint64]uint8)
	}
	return &ConMapUint64Uint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given uint64 key.
func (cm *ConMapUint64Uint8) Get(k uint64) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Uint8) GetOK(k uint64) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified uint64 key.
func (cm *ConMapUint64Uint8) Set(k uint64, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Uint8) Delete(k uint64) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given uint64 key.
func (cm *ConMapUint64Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint64=BUILTINS Uintptr=BUILTINS"

// ConMapUint64Uintptr is a concurrent safe wrapper around a
// map[Uint64]Uintptr.
type ConMapUint64Uintptr struct {
	// M is the underlying map[Uint64]Uintptr.
	M map[uint64]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint64Uintptr creates a new concurrent safe map storing uintptr values,
// for uint64 keys.
func NewConMapUint64Uintptr() *ConMapUint64Uintptr {
	return ToConMapUint64Uintptr(nil)
}

// ToConMapUint64Uintptr creates a new ConMapUint64Uintptr prepopulated
// with the data from the specified map[Uint64]Uintptr.
func ToConMapUint64Uintptr(data map[uint64]uintptr) *ConMapUint64Uintptr {
	if data == nil {
		data = make(map[uint64]uintptr)
	}
	return &ConMapUint64Uintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given uint64 key.
func (cm *ConMapUint64Uintptr) Get(k uint64) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given uint64 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint64Uintptr) GetOK(k uint64) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified uint64 key.
func (cm *ConMapUint64Uintptr) Set(k uint64, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint64 key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint64Uintptr) Delete(k uint64) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given uint64 key.
func (cm *ConMapUint64Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Bool=BUILTINS"

// ConMapUint8Bool is a concurrent safe wrapper around a
// map[Uint8]Bool.
type ConMapUint8Bool struct {
	// M is the underlying map[Uint8]Bool.
	M map[uint8]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Bool creates a new concurrent safe map storing bool values,
// for uint8 keys.
func NewConMapUint8Bool() *ConMapUint8Bool {
	return ToConMapUint8Bool(nil)
}

// ToConMapUint8Bool creates a new ConMapUint8Bool prepopulated
// with the data from the specified map[Uint8]Bool.
func ToConMapUint8Bool(data map[uint8]bool) *ConMapUint8Bool {
	if data == nil {
		data = make(map[uint8]bool)
	}
	return &ConMapUint8Bool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given uint8 key.
func (cm *ConMapUint8Bool) Get(k uint8) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Bool) GetOK(k uint8) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified uint8 key.
func (cm *ConMapUint8Bool) Set(k uint8, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Bool) Delete(k uint8) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given uint8 key.
func (cm *ConMapUint8Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Byte=BUILTINS"

// ConMapUint8Byte is a concurrent safe wrapper around a
// map[Uint8]Byte.
type ConMapUint8Byte struct {
	// M is the underlying map[Uint8]Byte.
	M map[uint8]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Byte creates a new concurrent safe map storing byte values,
// for uint8 keys.
func NewConMapUint8Byte() *ConMapUint8Byte {
	return ToConMapUint8Byte(nil)
}

// ToConMapUint8Byte creates a new ConMapUint8Byte prepopulated
// with the data from the specified map[Uint8]Byte.
func ToConMapUint8Byte(data map[uint8]byte) *ConMapUint8Byte {
	if data == nil {
		data = make(map[uint8]byte)
	}
	return &ConMapUint8Byte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given uint8 key.
func (cm *ConMapUint8Byte) Get(k uint8) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Byte) GetOK(k uint8) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified uint8 key.
func (cm *ConMapUint8Byte) Set(k uint8, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Byte) Delete(k uint8) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given uint8 key.
func (cm *ConMapUint8Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Complex128=BUILTINS"

// ConMapUint8Complex128 is a concurrent safe wrapper around a
// map[Uint8]Complex128.
type ConMapUint8Complex128 struct {
	// M is the underlying map[Uint8]Complex128.
	M map[uint8]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Complex128 creates a new concurrent safe map storing complex128 values,
// for uint8 keys.
func NewConMapUint8Complex128() *ConMapUint8Complex128 {
	return ToConMapUint8Complex128(nil)
}

// ToConMapUint8Complex128 creates a new ConMapUint8Complex128 prepopulated
// with the data from the specified map[Uint8]Complex128.
func ToConMapUint8Complex128(data map[uint8]complex128) *ConMapUint8Complex128 {
	if data == nil {
		data = make(map[uint8]complex128)
	}
	return &ConMapUint8Complex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given uint8 key.
func (cm *ConMapUint8Complex128) Get(k uint8) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Complex128) GetOK(k uint8) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified uint8 key.
func (cm *ConMapUint8Complex128) Set(k uint8, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Complex128) Delete(k uint8) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given uint8 key.
func (cm *ConMapUint8Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Complex64=BUILTINS"

// ConMapUint8Complex64 is a concurrent safe wrapper around a
// map[Uint8]Complex64.
type ConMapUint8Complex64 struct {
	// M is the underlying map[Uint8]Complex64.
	M map[uint8]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Complex64 creates a new concurrent safe map storing complex64 values,
// for uint8 keys.
func NewConMapUint8Complex64() *ConMapUint8Complex64 {
	return ToConMapUint8Complex64(nil)
}

// ToConMapUint8Complex64 creates a new ConMapUint8Complex64 prepopulated
// with the data from the specified map[Uint8]Complex64.
func ToConMapUint8Complex64(data map[uint8]complex64) *ConMapUint8Complex64 {
	if data == nil {
		data = make(map[uint8]complex64)
	}
	return &ConMapUint8Complex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given uint8 key.
func (cm *ConMapUint8Complex64) Get(k uint8) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Complex64) GetOK(k uint8) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified uint8 key.
func (cm *ConMapUint8Complex64) Set(k uint8, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Complex64) Delete(k uint8) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given uint8 key.
func (cm *ConMapUint8Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Error=BUILTINS"

// ConMapUint8Error is a concurrent safe wrapper around a
// map[Uint8]Error.
type ConMapUint8Error struct {
	// M is the underlying map[Uint8]Error.
	M map[uint8]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Error creates a new concurrent safe map storing error values,
// for uint8 keys.
func NewConMapUint8Error() *ConMapUint8Error {
	return ToConMapUint8Error(nil)
}

// ToConMapUint8Error creates a new ConMapUint8Error prepopulated
// with the data from the specified map[Uint8]Error.
func ToConMapUint8Error(data map[uint8]error) *ConMapUint8Error {
	if data == nil {
		data = make(map[uint8]error)
	}
	return &ConMapUint8Error{M: data}
}

//var nilError error

// Get gets the error value for the given uint8 key.
func (cm *ConMapUint8Error) Get(k uint8) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Error) GetOK(k uint8) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified uint8 key.
func (cm *ConMapUint8Error) Set(k uint8, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Error) Delete(k uint8) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given uint8 key.
func (cm *ConMapUint8Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Float32=BUILTINS"

// ConMapUint8Float32 is a concurrent safe wrapper around a
// map[Uint8]Float32.
type ConMapUint8Float32 struct {
	// M is the underlying map[Uint8]Float32.
	M map[uint8]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Float32 creates a new concurrent safe map storing float32 values,
// for uint8 keys.
func NewConMapUint8Float32() *ConMapUint8Float32 {
	return ToConMapUint8Float32(nil)
}

// ToConMapUint8Float32 creates a new ConMapUint8Float32 prepopulated
// with the data from the specified map[Uint8]Float32.
func ToConMapUint8Float32(data map[uint8]float32) *ConMapUint8Float32 {
	if data == nil {
		data = make(map[uint8]float32)
	}
	return &ConMapUint8Float32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given uint8 key.
func (cm *ConMapUint8Float32) Get(k uint8) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Float32) GetOK(k uint8) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified uint8 key.
func (cm *ConMapUint8Float32) Set(k uint8, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Float32) Delete(k uint8) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given uint8 key.
func (cm *ConMapUint8Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Float64=BUILTINS"

// ConMapUint8Float64 is a concurrent safe wrapper around a
// map[Uint8]Float64.
type ConMapUint8Float64 struct {
	// M is the underlying map[Uint8]Float64.
	M map[uint8]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Float64 creates a new concurrent safe map storing float64 values,
// for uint8 keys.
func NewConMapUint8Float64() *ConMapUint8Float64 {
	return ToConMapUint8Float64(nil)
}

// ToConMapUint8Float64 creates a new ConMapUint8Float64 prepopulated
// with the data from the specified map[Uint8]Float64.
func ToConMapUint8Float64(data map[uint8]float64) *ConMapUint8Float64 {
	if data == nil {
		data = make(map[uint8]float64)
	}
	return &ConMapUint8Float64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given uint8 key.
func (cm *ConMapUint8Float64) Get(k uint8) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Float64) GetOK(k uint8) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified uint8 key.
func (cm *ConMapUint8Float64) Set(k uint8, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Float64) Delete(k uint8) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given uint8 key.
func (cm *ConMapUint8Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Int=BUILTINS"

// ConMapUint8Int is a concurrent safe wrapper around a
// map[Uint8]Int.
type ConMapUint8Int struct {
	// M is the underlying map[Uint8]Int.
	M map[uint8]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Int creates a new concurrent safe map storing int values,
// for uint8 keys.
func NewConMapUint8Int() *ConMapUint8Int {
	return ToConMapUint8Int(nil)
}

// ToConMapUint8Int creates a new ConMapUint8Int prepopulated
// with the data from the specified map[Uint8]Int.
func ToConMapUint8Int(data map[uint8]int) *ConMapUint8Int {
	if data == nil {
		data = make(map[uint8]int)
	}
	return &ConMapUint8Int{M: data}
}

//var nilInt int

// Get gets the int value for the given uint8 key.
func (cm *ConMapUint8Int) Get(k uint8) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Int) GetOK(k uint8) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified uint8 key.
func (cm *ConMapUint8Int) Set(k uint8, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Int) Delete(k uint8) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given uint8 key.
func (cm *ConMapUint8Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Int16=BUILTINS"

// ConMapUint8Int16 is a concurrent safe wrapper around a
// map[Uint8]Int16.
type ConMapUint8Int16 struct {
	// M is the underlying map[Uint8]Int16.
	M map[uint8]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Int16 creates a new concurrent safe map storing int16 values,
// for uint8 keys.
func NewConMapUint8Int16() *ConMapUint8Int16 {
	return ToConMapUint8Int16(nil)
}

// ToConMapUint8Int16 creates a new ConMapUint8Int16 prepopulated
// with the data from the specified map[Uint8]Int16.
func ToConMapUint8Int16(data map[uint8]int16) *ConMapUint8Int16 {
	if data == nil {
		data = make(map[uint8]int16)
	}
	return &ConMapUint8Int16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given uint8 key.
func (cm *ConMapUint8Int16) Get(k uint8) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Int16) GetOK(k uint8) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified uint8 key.
func (cm *ConMapUint8Int16) Set(k uint8, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Int16) Delete(k uint8) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given uint8 key.
func (cm *ConMapUint8Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Int32=BUILTINS"

// ConMapUint8Int32 is a concurrent safe wrapper around a
// map[Uint8]Int32.
type ConMapUint8Int32 struct {
	// M is the underlying map[Uint8]Int32.
	M map[uint8]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Int32 creates a new concurrent safe map storing int32 values,
// for uint8 keys.
func NewConMapUint8Int32() *ConMapUint8Int32 {
	return ToConMapUint8Int32(nil)
}

// ToConMapUint8Int32 creates a new ConMapUint8Int32 prepopulated
// with the data from the specified map[Uint8]Int32.
func ToConMapUint8Int32(data map[uint8]int32) *ConMapUint8Int32 {
	if data == nil {
		data = make(map[uint8]int32)
	}
	return &ConMapUint8Int32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given uint8 key.
func (cm *ConMapUint8Int32) Get(k uint8) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Int32) GetOK(k uint8) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified uint8 key.
func (cm *ConMapUint8Int32) Set(k uint8, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Int32) Delete(k uint8) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given uint8 key.
func (cm *ConMapUint8Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Int64=BUILTINS"

// ConMapUint8Int64 is a concurrent safe wrapper around a
// map[Uint8]Int64.
type ConMapUint8Int64 struct {
	// M is the underlying map[Uint8]Int64.
	M map[uint8]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Int64 creates a new concurrent safe map storing int64 values,
// for uint8 keys.
func NewConMapUint8Int64() *ConMapUint8Int64 {
	return ToConMapUint8Int64(nil)
}

// ToConMapUint8Int64 creates a new ConMapUint8Int64 prepopulated
// with the data from the specified map[Uint8]Int64.
func ToConMapUint8Int64(data map[uint8]int64) *ConMapUint8Int64 {
	if data == nil {
		data = make(map[uint8]int64)
	}
	return &ConMapUint8Int64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given uint8 key.
func (cm *ConMapUint8Int64) Get(k uint8) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Int64) GetOK(k uint8) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified uint8 key.
func (cm *ConMapUint8Int64) Set(k uint8, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Int64) Delete(k uint8) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given uint8 key.
func (cm *ConMapUint8Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Int8=BUILTINS"

// ConMapUint8Int8 is a concurrent safe wrapper around a
// map[Uint8]Int8.
type ConMapUint8Int8 struct {
	// M is the underlying map[Uint8]Int8.
	M map[uint8]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Int8 creates a new concurrent safe map storing int8 values,
// for uint8 keys.
func NewConMapUint8Int8() *ConMapUint8Int8 {
	return ToConMapUint8Int8(nil)
}

// ToConMapUint8Int8 creates a new ConMapUint8Int8 prepopulated
// with the data from the specified map[Uint8]Int8.
func ToConMapUint8Int8(data map[uint8]int8) *ConMapUint8Int8 {
	if data == nil {
		data = make(map[uint8]int8)
	}
	return &ConMapUint8Int8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given uint8 key.
func (cm *ConMapUint8Int8) Get(k uint8) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Int8) GetOK(k uint8) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified uint8 key.
func (cm *ConMapUint8Int8) Set(k uint8, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Int8) Delete(k uint8) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given uint8 key.
func (cm *ConMapUint8Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Rune=BUILTINS"

// ConMapUint8Rune is a concurrent safe wrapper around a
// map[Uint8]Rune.
type ConMapUint8Rune struct {
	// M is the underlying map[Uint8]Rune.
	M map[uint8]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Rune creates a new concurrent safe map storing rune values,
// for uint8 keys.
func NewConMapUint8Rune() *ConMapUint8Rune {
	return ToConMapUint8Rune(nil)
}

// ToConMapUint8Rune creates a new ConMapUint8Rune prepopulated
// with the data from the specified map[Uint8]Rune.
func ToConMapUint8Rune(data map[uint8]rune) *ConMapUint8Rune {
	if data == nil {
		data = make(map[uint8]rune)
	}
	return &ConMapUint8Rune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given uint8 key.
func (cm *ConMapUint8Rune) Get(k uint8) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Rune) GetOK(k uint8) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified uint8 key.
func (cm *ConMapUint8Rune) Set(k uint8, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Rune) Delete(k uint8) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given uint8 key.
func (cm *ConMapUint8Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS String=BUILTINS"

// ConMapUint8String is a concurrent safe wrapper around a
// map[Uint8]String.
type ConMapUint8String struct {
	// M is the underlying map[Uint8]String.
	M map[uint8]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8String creates a new concurrent safe map storing string values,
// for uint8 keys.
func NewConMapUint8String() *ConMapUint8String {
	return ToConMapUint8String(nil)
}

// ToConMapUint8String creates a new ConMapUint8String prepopulated
// with the data from the specified map[Uint8]String.
func ToConMapUint8String(data map[uint8]string) *ConMapUint8String {
	if data == nil {
		data = make(map[uint8]string)
	}
	return &ConMapUint8String{M: data}
}

//var nilString string

// Get gets the string value for the given uint8 key.
func (cm *ConMapUint8String) Get(k uint8) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8String) GetOK(k uint8) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified uint8 key.
func (cm *ConMapUint8String) Set(k uint8, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8String) Delete(k uint8) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given uint8 key.
func (cm *ConMapUint8String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Uint=BUILTINS"

// ConMapUint8Uint is a concurrent safe wrapper around a
// map[Uint8]Uint.
type ConMapUint8Uint struct {
	// M is the underlying map[Uint8]Uint.
	M map[uint8]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Uint creates a new concurrent safe map storing uint values,
// for uint8 keys.
func NewConMapUint8Uint() *ConMapUint8Uint {
	return ToConMapUint8Uint(nil)
}

// ToConMapUint8Uint creates a new ConMapUint8Uint prepopulated
// with the data from the specified map[Uint8]Uint.
func ToConMapUint8Uint(data map[uint8]uint) *ConMapUint8Uint {
	if data == nil {
		data = make(map[uint8]uint)
	}
	return &ConMapUint8Uint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given uint8 key.
func (cm *ConMapUint8Uint) Get(k uint8) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Uint) GetOK(k uint8) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified uint8 key.
func (cm *ConMapUint8Uint) Set(k uint8, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Uint) Delete(k uint8) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given uint8 key.
func (cm *ConMapUint8Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Uint16=BUILTINS"

// ConMapUint8Uint16 is a concurrent safe wrapper around a
// map[Uint8]Uint16.
type ConMapUint8Uint16 struct {
	// M is the underlying map[Uint8]Uint16.
	M map[uint8]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Uint16 creates a new concurrent safe map storing uint16 values,
// for uint8 keys.
func NewConMapUint8Uint16() *ConMapUint8Uint16 {
	return ToConMapUint8Uint16(nil)
}

// ToConMapUint8Uint16 creates a new ConMapUint8Uint16 prepopulated
// with the data from the specified map[Uint8]Uint16.
func ToConMapUint8Uint16(data map[uint8]uint16) *ConMapUint8Uint16 {
	if data == nil {
		data = make(map[uint8]uint16)
	}
	return &ConMapUint8Uint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given uint8 key.
func (cm *ConMapUint8Uint16) Get(k uint8) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Uint16) GetOK(k uint8) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified uint8 key.
func (cm *ConMapUint8Uint16) Set(k uint8, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Uint16) Delete(k uint8) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given uint8 key.
func (cm *ConMapUint8Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Uint32=BUILTINS"

// ConMapUint8Uint32 is a concurrent safe wrapper around a
// map[Uint8]Uint32.
type ConMapUint8Uint32 struct {
	// M is the underlying map[Uint8]Uint32.
	M map[uint8]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Uint32 creates a new concurrent safe map storing uint32 values,
// for uint8 keys.
func NewConMapUint8Uint32() *ConMapUint8Uint32 {
	return ToConMapUint8Uint32(nil)
}

// ToConMapUint8Uint32 creates a new ConMapUint8Uint32 prepopulated
// with the data from the specified map[Uint8]Uint32.
func ToConMapUint8Uint32(data map[uint8]uint32) *ConMapUint8Uint32 {
	if data == nil {
		data = make(map[uint8]uint32)
	}
	return &ConMapUint8Uint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given uint8 key.
func (cm *ConMapUint8Uint32) Get(k uint8) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Uint32) GetOK(k uint8) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified uint8 key.
func (cm *ConMapUint8Uint32) Set(k uint8, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Uint32) Delete(k uint8) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given uint8 key.
func (cm *ConMapUint8Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Uint64=BUILTINS"

// ConMapUint8Uint64 is a concurrent safe wrapper around a
// map[Uint8]Uint64.
type ConMapUint8Uint64 struct {
	// M is the underlying map[Uint8]Uint64.
	M map[uint8]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Uint64 creates a new concurrent safe map storing uint64 values,
// for uint8 keys.
func NewConMapUint8Uint64() *ConMapUint8Uint64 {
	return ToConMapUint8Uint64(nil)
}

// ToConMapUint8Uint64 creates a new ConMapUint8Uint64 prepopulated
// with the data from the specified map[Uint8]Uint64.
func ToConMapUint8Uint64(data map[uint8]uint64) *ConMapUint8Uint64 {
	if data == nil {
		data = make(map[uint8]uint64)
	}
	return &ConMapUint8Uint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given uint8 key.
func (cm *ConMapUint8Uint64) Get(k uint8) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Uint64) GetOK(k uint8) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified uint8 key.
func (cm *ConMapUint8Uint64) Set(k uint8, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Uint64) Delete(k uint8) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given uint8 key.
func (cm *ConMapUint8Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Uint8=BUILTINS"

// ConMapUint8Uint8 is a concurrent safe wrapper around a
// map[Uint8]Uint8.
type ConMapUint8Uint8 struct {
	// M is the underlying map[Uint8]Uint8.
	M map[uint8]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Uint8 creates a new concurrent safe map storing uint8 values,
// for uint8 keys.
func NewConMapUint8Uint8() *ConMapUint8Uint8 {
	return ToConMapUint8Uint8(nil)
}

// ToConMapUint8Uint8 creates a new ConMapUint8Uint8 prepopulated
// with the data from the specified map[Uint8]Uint8.
func ToConMapUint8Uint8(data map[uint8]uint8) *ConMapUint8Uint8 {
	if data == nil {
		data = make(map[uint8]uint8)
	}
	return &ConMapUint8Uint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given uint8 key.
func (cm *ConMapUint8Uint8) Get(k uint8) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Uint8) GetOK(k uint8) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified uint8 key.
func (cm *ConMapUint8Uint8) Set(k uint8, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Uint8) Delete(k uint8) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given uint8 key.
func (cm *ConMapUint8Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uint8=BUILTINS Uintptr=BUILTINS"

// ConMapUint8Uintptr is a concurrent safe wrapper around a
// map[Uint8]Uintptr.
type ConMapUint8Uintptr struct {
	// M is the underlying map[Uint8]Uintptr.
	M map[uint8]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUint8Uintptr creates a new concurrent safe map storing uintptr values,
// for uint8 keys.
func NewConMapUint8Uintptr() *ConMapUint8Uintptr {
	return ToConMapUint8Uintptr(nil)
}

// ToConMapUint8Uintptr creates a new ConMapUint8Uintptr prepopulated
// with the data from the specified map[Uint8]Uintptr.
func ToConMapUint8Uintptr(data map[uint8]uintptr) *ConMapUint8Uintptr {
	if data == nil {
		data = make(map[uint8]uintptr)
	}
	return &ConMapUint8Uintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given uint8 key.
func (cm *ConMapUint8Uintptr) Get(k uint8) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given uint8 key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUint8Uintptr) GetOK(k uint8) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified uint8 key.
func (cm *ConMapUint8Uintptr) Set(k uint8, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uint8 key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUint8Uintptr) Delete(k uint8) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given uint8 key.
func (cm *ConMapUint8Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Bool=BUILTINS"

// ConMapUintptrBool is a concurrent safe wrapper around a
// map[Uintptr]Bool.
type ConMapUintptrBool struct {
	// M is the underlying map[Uintptr]Bool.
	M map[uintptr]bool
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrBool creates a new concurrent safe map storing bool values,
// for uintptr keys.
func NewConMapUintptrBool() *ConMapUintptrBool {
	return ToConMapUintptrBool(nil)
}

// ToConMapUintptrBool creates a new ConMapUintptrBool prepopulated
// with the data from the specified map[Uintptr]Bool.
func ToConMapUintptrBool(data map[uintptr]bool) *ConMapUintptrBool {
	if data == nil {
		data = make(map[uintptr]bool)
	}
	return &ConMapUintptrBool{M: data}
}

//var nilBool bool

// Get gets the bool value for the given uintptr key.
func (cm *ConMapUintptrBool) Get(k uintptr) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the bool value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrBool) GetOK(k uintptr) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the bool value for the specified uintptr key.
func (cm *ConMapUintptrBool) Set(k uintptr, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its bool
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrBool) Delete(k uintptr) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the bool value for the given uintptr key.
func (cm *ConMapUintptrBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Byte=BUILTINS"

// ConMapUintptrByte is a concurrent safe wrapper around a
// map[Uintptr]Byte.
type ConMapUintptrByte struct {
	// M is the underlying map[Uintptr]Byte.
	M map[uintptr]byte
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrByte creates a new concurrent safe map storing byte values,
// for uintptr keys.
func NewConMapUintptrByte() *ConMapUintptrByte {
	return ToConMapUintptrByte(nil)
}

// ToConMapUintptrByte creates a new ConMapUintptrByte prepopulated
// with the data from the specified map[Uintptr]Byte.
func ToConMapUintptrByte(data map[uintptr]byte) *ConMapUintptrByte {
	if data == nil {
		data = make(map[uintptr]byte)
	}
	return &ConMapUintptrByte{M: data}
}

//var nilByte byte

// Get gets the byte value for the given uintptr key.
func (cm *ConMapUintptrByte) Get(k uintptr) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the byte value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrByte) GetOK(k uintptr) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the byte value for the specified uintptr key.
func (cm *ConMapUintptrByte) Set(k uintptr, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its byte
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrByte) Delete(k uintptr) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the byte value for the given uintptr key.
func (cm *ConMapUintptrByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Complex128=BUILTINS"

// ConMapUintptrComplex128 is a concurrent safe wrapper around a
// map[Uintptr]Complex128.
type ConMapUintptrComplex128 struct {
	// M is the underlying map[Uintptr]Complex128.
	M map[uintptr]complex128
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrComplex128 creates a new concurrent safe map storing complex128 values,
// for uintptr keys.
func NewConMapUintptrComplex128() *ConMapUintptrComplex128 {
	return ToConMapUintptrComplex128(nil)
}

// ToConMapUintptrComplex128 creates a new ConMapUintptrComplex128 prepopulated
// with the data from the specified map[Uintptr]Complex128.
func ToConMapUintptrComplex128(data map[uintptr]complex128) *ConMapUintptrComplex128 {
	if data == nil {
		data = make(map[uintptr]complex128)
	}
	return &ConMapUintptrComplex128{M: data}
}

//var nilComplex128 complex128

// Get gets the complex128 value for the given uintptr key.
func (cm *ConMapUintptrComplex128) Get(k uintptr) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex128 value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrComplex128) GetOK(k uintptr) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex128 value for the specified uintptr key.
func (cm *ConMapUintptrComplex128) Set(k uintptr, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its complex128
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrComplex128) Delete(k uintptr) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex128 value for the given uintptr key.
func (cm *ConMapUintptrComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Complex64=BUILTINS"

// ConMapUintptrComplex64 is a concurrent safe wrapper around a
// map[Uintptr]Complex64.
type ConMapUintptrComplex64 struct {
	// M is the underlying map[Uintptr]Complex64.
	M map[uintptr]complex64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrComplex64 creates a new concurrent safe map storing complex64 values,
// for uintptr keys.
func NewConMapUintptrComplex64() *ConMapUintptrComplex64 {
	return ToConMapUintptrComplex64(nil)
}

// ToConMapUintptrComplex64 creates a new ConMapUintptrComplex64 prepopulated
// with the data from the specified map[Uintptr]Complex64.
func ToConMapUintptrComplex64(data map[uintptr]complex64) *ConMapUintptrComplex64 {
	if data == nil {
		data = make(map[uintptr]complex64)
	}
	return &ConMapUintptrComplex64{M: data}
}

//var nilComplex64 complex64

// Get gets the complex64 value for the given uintptr key.
func (cm *ConMapUintptrComplex64) Get(k uintptr) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the complex64 value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrComplex64) GetOK(k uintptr) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the complex64 value for the specified uintptr key.
func (cm *ConMapUintptrComplex64) Set(k uintptr, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its complex64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrComplex64) Delete(k uintptr) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the complex64 value for the given uintptr key.
func (cm *ConMapUintptrComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Error=BUILTINS"

// ConMapUintptrError is a concurrent safe wrapper around a
// map[Uintptr]Error.
type ConMapUintptrError struct {
	// M is the underlying map[Uintptr]Error.
	M map[uintptr]error
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrError creates a new concurrent safe map storing error values,
// for uintptr keys.
func NewConMapUintptrError() *ConMapUintptrError {
	return ToConMapUintptrError(nil)
}

// ToConMapUintptrError creates a new ConMapUintptrError prepopulated
// with the data from the specified map[Uintptr]Error.
func ToConMapUintptrError(data map[uintptr]error) *ConMapUintptrError {
	if data == nil {
		data = make(map[uintptr]error)
	}
	return &ConMapUintptrError{M: data}
}

//var nilError error

// Get gets the error value for the given uintptr key.
func (cm *ConMapUintptrError) Get(k uintptr) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the error value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrError) GetOK(k uintptr) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the error value for the specified uintptr key.
func (cm *ConMapUintptrError) Set(k uintptr, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its error
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrError) Delete(k uintptr) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the error value for the given uintptr key.
func (cm *ConMapUintptrError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Float32=BUILTINS"

// ConMapUintptrFloat32 is a concurrent safe wrapper around a
// map[Uintptr]Float32.
type ConMapUintptrFloat32 struct {
	// M is the underlying map[Uintptr]Float32.
	M map[uintptr]float32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrFloat32 creates a new concurrent safe map storing float32 values,
// for uintptr keys.
func NewConMapUintptrFloat32() *ConMapUintptrFloat32 {
	return ToConMapUintptrFloat32(nil)
}

// ToConMapUintptrFloat32 creates a new ConMapUintptrFloat32 prepopulated
// with the data from the specified map[Uintptr]Float32.
func ToConMapUintptrFloat32(data map[uintptr]float32) *ConMapUintptrFloat32 {
	if data == nil {
		data = make(map[uintptr]float32)
	}
	return &ConMapUintptrFloat32{M: data}
}

//var nilFloat32 float32

// Get gets the float32 value for the given uintptr key.
func (cm *ConMapUintptrFloat32) Get(k uintptr) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float32 value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrFloat32) GetOK(k uintptr) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float32 value for the specified uintptr key.
func (cm *ConMapUintptrFloat32) Set(k uintptr, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its float32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrFloat32) Delete(k uintptr) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float32 value for the given uintptr key.
func (cm *ConMapUintptrFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Float64=BUILTINS"

// ConMapUintptrFloat64 is a concurrent safe wrapper around a
// map[Uintptr]Float64.
type ConMapUintptrFloat64 struct {
	// M is the underlying map[Uintptr]Float64.
	M map[uintptr]float64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrFloat64 creates a new concurrent safe map storing float64 values,
// for uintptr keys.
func NewConMapUintptrFloat64() *ConMapUintptrFloat64 {
	return ToConMapUintptrFloat64(nil)
}

// ToConMapUintptrFloat64 creates a new ConMapUintptrFloat64 prepopulated
// with the data from the specified map[Uintptr]Float64.
func ToConMapUintptrFloat64(data map[uintptr]float64) *ConMapUintptrFloat64 {
	if data == nil {
		data = make(map[uintptr]float64)
	}
	return &ConMapUintptrFloat64{M: data}
}

//var nilFloat64 float64

// Get gets the float64 value for the given uintptr key.
func (cm *ConMapUintptrFloat64) Get(k uintptr) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the float64 value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrFloat64) GetOK(k uintptr) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the float64 value for the specified uintptr key.
func (cm *ConMapUintptrFloat64) Set(k uintptr, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its float64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrFloat64) Delete(k uintptr) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the float64 value for the given uintptr key.
func (cm *ConMapUintptrFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Int=BUILTINS"

// ConMapUintptrInt is a concurrent safe wrapper around a
// map[Uintptr]Int.
type ConMapUintptrInt struct {
	// M is the underlying map[Uintptr]Int.
	M map[uintptr]int
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrInt creates a new concurrent safe map storing int values,
// for uintptr keys.
func NewConMapUintptrInt() *ConMapUintptrInt {
	return ToConMapUintptrInt(nil)
}

// ToConMapUintptrInt creates a new ConMapUintptrInt prepopulated
// with the data from the specified map[Uintptr]Int.
func ToConMapUintptrInt(data map[uintptr]int) *ConMapUintptrInt {
	if data == nil {
		data = make(map[uintptr]int)
	}
	return &ConMapUintptrInt{M: data}
}

//var nilInt int

// Get gets the int value for the given uintptr key.
func (cm *ConMapUintptrInt) Get(k uintptr) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrInt) GetOK(k uintptr) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int value for the specified uintptr key.
func (cm *ConMapUintptrInt) Set(k uintptr, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its int
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrInt) Delete(k uintptr) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int value for the given uintptr key.
func (cm *ConMapUintptrInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Int16=BUILTINS"

// ConMapUintptrInt16 is a concurrent safe wrapper around a
// map[Uintptr]Int16.
type ConMapUintptrInt16 struct {
	// M is the underlying map[Uintptr]Int16.
	M map[uintptr]int16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrInt16 creates a new concurrent safe map storing int16 values,
// for uintptr keys.
func NewConMapUintptrInt16() *ConMapUintptrInt16 {
	return ToConMapUintptrInt16(nil)
}

// ToConMapUintptrInt16 creates a new ConMapUintptrInt16 prepopulated
// with the data from the specified map[Uintptr]Int16.
func ToConMapUintptrInt16(data map[uintptr]int16) *ConMapUintptrInt16 {
	if data == nil {
		data = make(map[uintptr]int16)
	}
	return &ConMapUintptrInt16{M: data}
}

//var nilInt16 int16

// Get gets the int16 value for the given uintptr key.
func (cm *ConMapUintptrInt16) Get(k uintptr) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int16 value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrInt16) GetOK(k uintptr) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int16 value for the specified uintptr key.
func (cm *ConMapUintptrInt16) Set(k uintptr, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its int16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrInt16) Delete(k uintptr) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int16 value for the given uintptr key.
func (cm *ConMapUintptrInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Int32=BUILTINS"

// ConMapUintptrInt32 is a concurrent safe wrapper around a
// map[Uintptr]Int32.
type ConMapUintptrInt32 struct {
	// M is the underlying map[Uintptr]Int32.
	M map[uintptr]int32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrInt32 creates a new concurrent safe map storing int32 values,
// for uintptr keys.
func NewConMapUintptrInt32() *ConMapUintptrInt32 {
	return ToConMapUintptrInt32(nil)
}

// ToConMapUintptrInt32 creates a new ConMapUintptrInt32 prepopulated
// with the data from the specified map[Uintptr]Int32.
func ToConMapUintptrInt32(data map[uintptr]int32) *ConMapUintptrInt32 {
	if data == nil {
		data = make(map[uintptr]int32)
	}
	return &ConMapUintptrInt32{M: data}
}

//var nilInt32 int32

// Get gets the int32 value for the given uintptr key.
func (cm *ConMapUintptrInt32) Get(k uintptr) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int32 value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrInt32) GetOK(k uintptr) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int32 value for the specified uintptr key.
func (cm *ConMapUintptrInt32) Set(k uintptr, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its int32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrInt32) Delete(k uintptr) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int32 value for the given uintptr key.
func (cm *ConMapUintptrInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Int64=BUILTINS"

// ConMapUintptrInt64 is a concurrent safe wrapper around a
// map[Uintptr]Int64.
type ConMapUintptrInt64 struct {
	// M is the underlying map[Uintptr]Int64.
	M map[uintptr]int64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrInt64 creates a new concurrent safe map storing int64 values,
// for uintptr keys.
func NewConMapUintptrInt64() *ConMapUintptrInt64 {
	return ToConMapUintptrInt64(nil)
}

// ToConMapUintptrInt64 creates a new ConMapUintptrInt64 prepopulated
// with the data from the specified map[Uintptr]Int64.
func ToConMapUintptrInt64(data map[uintptr]int64) *ConMapUintptrInt64 {
	if data == nil {
		data = make(map[uintptr]int64)
	}
	return &ConMapUintptrInt64{M: data}
}

//var nilInt64 int64

// Get gets the int64 value for the given uintptr key.
func (cm *ConMapUintptrInt64) Get(k uintptr) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int64 value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrInt64) GetOK(k uintptr) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int64 value for the specified uintptr key.
func (cm *ConMapUintptrInt64) Set(k uintptr, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its int64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrInt64) Delete(k uintptr) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int64 value for the given uintptr key.
func (cm *ConMapUintptrInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Int8=BUILTINS"

// ConMapUintptrInt8 is a concurrent safe wrapper around a
// map[Uintptr]Int8.
type ConMapUintptrInt8 struct {
	// M is the underlying map[Uintptr]Int8.
	M map[uintptr]int8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrInt8 creates a new concurrent safe map storing int8 values,
// for uintptr keys.
func NewConMapUintptrInt8() *ConMapUintptrInt8 {
	return ToConMapUintptrInt8(nil)
}

// ToConMapUintptrInt8 creates a new ConMapUintptrInt8 prepopulated
// with the data from the specified map[Uintptr]Int8.
func ToConMapUintptrInt8(data map[uintptr]int8) *ConMapUintptrInt8 {
	if data == nil {
		data = make(map[uintptr]int8)
	}
	return &ConMapUintptrInt8{M: data}
}

//var nilInt8 int8

// Get gets the int8 value for the given uintptr key.
func (cm *ConMapUintptrInt8) Get(k uintptr) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the int8 value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrInt8) GetOK(k uintptr) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the int8 value for the specified uintptr key.
func (cm *ConMapUintptrInt8) Set(k uintptr, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its int8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrInt8) Delete(k uintptr) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the int8 value for the given uintptr key.
func (cm *ConMapUintptrInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Rune=BUILTINS"

// ConMapUintptrRune is a concurrent safe wrapper around a
// map[Uintptr]Rune.
type ConMapUintptrRune struct {
	// M is the underlying map[Uintptr]Rune.
	M map[uintptr]rune
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrRune creates a new concurrent safe map storing rune values,
// for uintptr keys.
func NewConMapUintptrRune() *ConMapUintptrRune {
	return ToConMapUintptrRune(nil)
}

// ToConMapUintptrRune creates a new ConMapUintptrRune prepopulated
// with the data from the specified map[Uintptr]Rune.
func ToConMapUintptrRune(data map[uintptr]rune) *ConMapUintptrRune {
	if data == nil {
		data = make(map[uintptr]rune)
	}
	return &ConMapUintptrRune{M: data}
}

//var nilRune rune

// Get gets the rune value for the given uintptr key.
func (cm *ConMapUintptrRune) Get(k uintptr) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the rune value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrRune) GetOK(k uintptr) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the rune value for the specified uintptr key.
func (cm *ConMapUintptrRune) Set(k uintptr, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its rune
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrRune) Delete(k uintptr) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the rune value for the given uintptr key.
func (cm *ConMapUintptrRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS String=BUILTINS"

// ConMapUintptrString is a concurrent safe wrapper around a
// map[Uintptr]String.
type ConMapUintptrString struct {
	// M is the underlying map[Uintptr]String.
	M map[uintptr]string
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrString creates a new concurrent safe map storing string values,
// for uintptr keys.
func NewConMapUintptrString() *ConMapUintptrString {
	return ToConMapUintptrString(nil)
}

// ToConMapUintptrString creates a new ConMapUintptrString prepopulated
// with the data from the specified map[Uintptr]String.
func ToConMapUintptrString(data map[uintptr]string) *ConMapUintptrString {
	if data == nil {
		data = make(map[uintptr]string)
	}
	return &ConMapUintptrString{M: data}
}

//var nilString string

// Get gets the string value for the given uintptr key.
func (cm *ConMapUintptrString) Get(k uintptr) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the string value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrString) GetOK(k uintptr) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the string value for the specified uintptr key.
func (cm *ConMapUintptrString) Set(k uintptr, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its string
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrString) Delete(k uintptr) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the string value for the given uintptr key.
func (cm *ConMapUintptrString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Uint=BUILTINS"

// ConMapUintptrUint is a concurrent safe wrapper around a
// map[Uintptr]Uint.
type ConMapUintptrUint struct {
	// M is the underlying map[Uintptr]Uint.
	M map[uintptr]uint
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrUint creates a new concurrent safe map storing uint values,
// for uintptr keys.
func NewConMapUintptrUint() *ConMapUintptrUint {
	return ToConMapUintptrUint(nil)
}

// ToConMapUintptrUint creates a new ConMapUintptrUint prepopulated
// with the data from the specified map[Uintptr]Uint.
func ToConMapUintptrUint(data map[uintptr]uint) *ConMapUintptrUint {
	if data == nil {
		data = make(map[uintptr]uint)
	}
	return &ConMapUintptrUint{M: data}
}

//var nilUint uint

// Get gets the uint value for the given uintptr key.
func (cm *ConMapUintptrUint) Get(k uintptr) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrUint) GetOK(k uintptr) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint value for the specified uintptr key.
func (cm *ConMapUintptrUint) Set(k uintptr, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its uint
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrUint) Delete(k uintptr) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint value for the given uintptr key.
func (cm *ConMapUintptrUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Uint16=BUILTINS"

// ConMapUintptrUint16 is a concurrent safe wrapper around a
// map[Uintptr]Uint16.
type ConMapUintptrUint16 struct {
	// M is the underlying map[Uintptr]Uint16.
	M map[uintptr]uint16
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrUint16 creates a new concurrent safe map storing uint16 values,
// for uintptr keys.
func NewConMapUintptrUint16() *ConMapUintptrUint16 {
	return ToConMapUintptrUint16(nil)
}

// ToConMapUintptrUint16 creates a new ConMapUintptrUint16 prepopulated
// with the data from the specified map[Uintptr]Uint16.
func ToConMapUintptrUint16(data map[uintptr]uint16) *ConMapUintptrUint16 {
	if data == nil {
		data = make(map[uintptr]uint16)
	}
	return &ConMapUintptrUint16{M: data}
}

//var nilUint16 uint16

// Get gets the uint16 value for the given uintptr key.
func (cm *ConMapUintptrUint16) Get(k uintptr) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint16 value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrUint16) GetOK(k uintptr) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint16 value for the specified uintptr key.
func (cm *ConMapUintptrUint16) Set(k uintptr, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its uint16
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrUint16) Delete(k uintptr) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint16 value for the given uintptr key.
func (cm *ConMapUintptrUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Uint32=BUILTINS"

// ConMapUintptrUint32 is a concurrent safe wrapper around a
// map[Uintptr]Uint32.
type ConMapUintptrUint32 struct {
	// M is the underlying map[Uintptr]Uint32.
	M map[uintptr]uint32
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrUint32 creates a new concurrent safe map storing uint32 values,
// for uintptr keys.
func NewConMapUintptrUint32() *ConMapUintptrUint32 {
	return ToConMapUintptrUint32(nil)
}

// ToConMapUintptrUint32 creates a new ConMapUintptrUint32 prepopulated
// with the data from the specified map[Uintptr]Uint32.
func ToConMapUintptrUint32(data map[uintptr]uint32) *ConMapUintptrUint32 {
	if data == nil {
		data = make(map[uintptr]uint32)
	}
	return &ConMapUintptrUint32{M: data}
}

//var nilUint32 uint32

// Get gets the uint32 value for the given uintptr key.
func (cm *ConMapUintptrUint32) Get(k uintptr) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint32 value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrUint32) GetOK(k uintptr) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint32 value for the specified uintptr key.
func (cm *ConMapUintptrUint32) Set(k uintptr, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its uint32
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrUint32) Delete(k uintptr) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint32 value for the given uintptr key.
func (cm *ConMapUintptrUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Uint64=BUILTINS"

// ConMapUintptrUint64 is a concurrent safe wrapper around a
// map[Uintptr]Uint64.
type ConMapUintptrUint64 struct {
	// M is the underlying map[Uintptr]Uint64.
	M map[uintptr]uint64
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrUint64 creates a new concurrent safe map storing uint64 values,
// for uintptr keys.
func NewConMapUintptrUint64() *ConMapUintptrUint64 {
	return ToConMapUintptrUint64(nil)
}

// ToConMapUintptrUint64 creates a new ConMapUintptrUint64 prepopulated
// with the data from the specified map[Uintptr]Uint64.
func ToConMapUintptrUint64(data map[uintptr]uint64) *ConMapUintptrUint64 {
	if data == nil {
		data = make(map[uintptr]uint64)
	}
	return &ConMapUintptrUint64{M: data}
}

//var nilUint64 uint64

// Get gets the uint64 value for the given uintptr key.
func (cm *ConMapUintptrUint64) Get(k uintptr) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint64 value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrUint64) GetOK(k uintptr) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint64 value for the specified uintptr key.
func (cm *ConMapUintptrUint64) Set(k uintptr, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its uint64
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrUint64) Delete(k uintptr) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint64 value for the given uintptr key.
func (cm *ConMapUintptrUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Uint8=BUILTINS"

// ConMapUintptrUint8 is a concurrent safe wrapper around a
// map[Uintptr]Uint8.
type ConMapUintptrUint8 struct {
	// M is the underlying map[Uintptr]Uint8.
	M map[uintptr]uint8
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrUint8 creates a new concurrent safe map storing uint8 values,
// for uintptr keys.
func NewConMapUintptrUint8() *ConMapUintptrUint8 {
	return ToConMapUintptrUint8(nil)
}

// ToConMapUintptrUint8 creates a new ConMapUintptrUint8 prepopulated
// with the data from the specified map[Uintptr]Uint8.
func ToConMapUintptrUint8(data map[uintptr]uint8) *ConMapUintptrUint8 {
	if data == nil {
		data = make(map[uintptr]uint8)
	}
	return &ConMapUintptrUint8{M: data}
}

//var nilUint8 uint8

// Get gets the uint8 value for the given uintptr key.
func (cm *ConMapUintptrUint8) Get(k uintptr) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uint8 value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrUint8) GetOK(k uintptr) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uint8 value for the specified uintptr key.
func (cm *ConMapUintptrUint8) Set(k uintptr, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its uint8
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrUint8) Delete(k uintptr) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uint8 value for the given uintptr key.
func (cm *ConMapUintptrUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

//genny get maps/concurrentmap.go "Uintptr=BUILTINS Uintptr=BUILTINS"

// ConMapUintptrUintptr is a concurrent safe wrapper around a
// map[Uintptr]Uintptr.
type ConMapUintptrUintptr struct {
	// M is the underlying map[Uintptr]Uintptr.
	M map[uintptr]uintptr
	// L is the sync.RWMutex used to control access to M.
	L sync.RWMutex
}

// NewConMapUintptrUintptr creates a new concurrent safe map storing uintptr values,
// for uintptr keys.
func NewConMapUintptrUintptr() *ConMapUintptrUintptr {
	return ToConMapUintptrUintptr(nil)
}

// ToConMapUintptrUintptr creates a new ConMapUintptrUintptr prepopulated
// with the data from the specified map[Uintptr]Uintptr.
func ToConMapUintptrUintptr(data map[uintptr]uintptr) *ConMapUintptrUintptr {
	if data == nil {
		data = make(map[uintptr]uintptr)
	}
	return &ConMapUintptrUintptr{M: data}
}

//var nilUintptr uintptr

// Get gets the uintptr value for the given uintptr key.
func (cm *ConMapUintptrUintptr) Get(k uintptr) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}

// GetOK gets the uintptr value for the given uintptr key, and a
// bool indicating whether the key was present or not.
func (cm *ConMapUintptrUintptr) GetOK(k uintptr) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

// Set sets the uintptr value for the specified uintptr key.
func (cm *ConMapUintptrUintptr) Set(k uintptr, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

// Delete removes the specified uintptr key, returning its uintptr
// value and a bool indicating whether the delete occurred or not.
func (cm *ConMapUintptrUintptr) Delete(k uintptr) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

// Get gets the uintptr value for the given uintptr key.
func (cm *ConMapUintptrUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}
