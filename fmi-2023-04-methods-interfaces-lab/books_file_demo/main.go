package main

import (
	"encoding/json"
	"fmt"
	"github.com/iproduct/coursego/fmi-2023-04-methods-interfaces-lab/books"
	"io"
	"log"
	"os"
	"strings"
)

func main() {

	// Open our jsonFile
	jsonFile, err := os.Open("D:/CourseGO/git/coursego/fmi-2023-04-methods-interfaces-lab/data/books.json")
	// if we os.Open returns an error then handle it
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println("Successfully Opened users.json")
	// defer the closing of our jsonFile so that we can parse it later on
	defer jsonFile.Close()

	byteValue, _ := io.ReadAll(jsonFile)

	// Unmarshall JSON using json.Decoder
	decoder := json.NewDecoder(strings.NewReader(string(byteValue)))
	var GoBooks books.AutoGenerated
	err = decoder.Decode(&GoBooks)
	//err = json.Unmarshal(byteValue, &GoBooks)
	if err != nil {
		log.Fatalf("JSON unmarshalling failed: %s", err)
	}
	for i, book := range GoBooks.Items {
		fmt.Printf("%d: %s: %#v: %s\n", i+1, book.VolumeInfo.IndustryIdentifiers[0].Identifier, book.VolumeInfo.Title, book.VolumeInfo.Subtitle)
	}

	outFile, err := os.OpenFile("D:/CourseGO/git/coursego/fmi-2023-04-methods-interfaces-lab/data/books_summary.json", os.O_RDWR|os.O_CREATE, 0755)
	if err != nil {
		log.Fatal(err)
	}
	defer outFile.Close()
	results := make([]map[string]interface{}, 0)
	for _, book := range GoBooks.Items {
		//_, err := outFile.WriteString(fmt.Sprintf("%d: %s: %#v: %s\n", i+1, book.VolumeInfo.IndustryIdentifiers[0].Identifier, book.VolumeInfo.Title, book.VolumeInfo.Subtitle))
		//if err != nil {
		//	log.Fatal(err)
		//}
		results = append(results, map[string]any{"ISBN": book.VolumeInfo.IndustryIdentifiers[0].Identifier, "title": book.VolumeInfo.Title, "subtitle": book.VolumeInfo.Subtitle})
	}
	fmt.Printf("\n%#v", results)

	// encode JSON using json.Encoder
	writer := &strings.Builder{}
	encoder := json.NewEncoder(writer)
	encoder.SetIndent("", "    ")
	err = encoder.Encode(results)
	if _, err = outFile.WriteString(writer.String()); err != nil {
		log.Fatal(err)
	}
}
