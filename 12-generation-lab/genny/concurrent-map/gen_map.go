// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package maps

import "sync"

type ConMapBoolBool struct {
	M map[bool]bool
	L sync.RWMutex
}

func NewConMapBoolBool() *ConMapBoolBool {
	return ToConMapBoolBool(nil)
}

func ToConMapBoolBool(data map[bool]bool) *ConMapBoolBool {
	if data == nil {
		data = make(map[bool]bool)
	}
	return &ConMapBoolBool{M: data}
}

func (cm *ConMapBoolBool) Get(k bool) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolBool) GetOK(k bool) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolBool) Set(k bool, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolBool) Delete(k bool) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolByte struct {
	M map[bool]byte
	L sync.RWMutex
}

func NewConMapBoolByte() *ConMapBoolByte {
	return ToConMapBoolByte(nil)
}

func ToConMapBoolByte(data map[bool]byte) *ConMapBoolByte {
	if data == nil {
		data = make(map[bool]byte)
	}
	return &ConMapBoolByte{M: data}
}

func (cm *ConMapBoolByte) Get(k bool) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolByte) GetOK(k bool) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolByte) Set(k bool, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolByte) Delete(k bool) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolComplex128 struct {
	M map[bool]complex128
	L sync.RWMutex
}

func NewConMapBoolComplex128() *ConMapBoolComplex128 {
	return ToConMapBoolComplex128(nil)
}

func ToConMapBoolComplex128(data map[bool]complex128) *ConMapBoolComplex128 {
	if data == nil {
		data = make(map[bool]complex128)
	}
	return &ConMapBoolComplex128{M: data}
}

func (cm *ConMapBoolComplex128) Get(k bool) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolComplex128) GetOK(k bool) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolComplex128) Set(k bool, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolComplex128) Delete(k bool) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolComplex64 struct {
	M map[bool]complex64
	L sync.RWMutex
}

func NewConMapBoolComplex64() *ConMapBoolComplex64 {
	return ToConMapBoolComplex64(nil)
}

func ToConMapBoolComplex64(data map[bool]complex64) *ConMapBoolComplex64 {
	if data == nil {
		data = make(map[bool]complex64)
	}
	return &ConMapBoolComplex64{M: data}
}

func (cm *ConMapBoolComplex64) Get(k bool) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolComplex64) GetOK(k bool) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolComplex64) Set(k bool, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolComplex64) Delete(k bool) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolError struct {
	M map[bool]error
	L sync.RWMutex
}

func NewConMapBoolError() *ConMapBoolError {
	return ToConMapBoolError(nil)
}

func ToConMapBoolError(data map[bool]error) *ConMapBoolError {
	if data == nil {
		data = make(map[bool]error)
	}
	return &ConMapBoolError{M: data}
}

func (cm *ConMapBoolError) Get(k bool) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolError) GetOK(k bool) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolError) Set(k bool, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolError) Delete(k bool) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolFloat32 struct {
	M map[bool]float32
	L sync.RWMutex
}

func NewConMapBoolFloat32() *ConMapBoolFloat32 {
	return ToConMapBoolFloat32(nil)
}

func ToConMapBoolFloat32(data map[bool]float32) *ConMapBoolFloat32 {
	if data == nil {
		data = make(map[bool]float32)
	}
	return &ConMapBoolFloat32{M: data}
}

func (cm *ConMapBoolFloat32) Get(k bool) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolFloat32) GetOK(k bool) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolFloat32) Set(k bool, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolFloat32) Delete(k bool) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolFloat64 struct {
	M map[bool]float64
	L sync.RWMutex
}

func NewConMapBoolFloat64() *ConMapBoolFloat64 {
	return ToConMapBoolFloat64(nil)
}

func ToConMapBoolFloat64(data map[bool]float64) *ConMapBoolFloat64 {
	if data == nil {
		data = make(map[bool]float64)
	}
	return &ConMapBoolFloat64{M: data}
}

func (cm *ConMapBoolFloat64) Get(k bool) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolFloat64) GetOK(k bool) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolFloat64) Set(k bool, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolFloat64) Delete(k bool) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolInt struct {
	M map[bool]int
	L sync.RWMutex
}

func NewConMapBoolInt() *ConMapBoolInt {
	return ToConMapBoolInt(nil)
}

func ToConMapBoolInt(data map[bool]int) *ConMapBoolInt {
	if data == nil {
		data = make(map[bool]int)
	}
	return &ConMapBoolInt{M: data}
}

func (cm *ConMapBoolInt) Get(k bool) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolInt) GetOK(k bool) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolInt) Set(k bool, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolInt) Delete(k bool) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolInt16 struct {
	M map[bool]int16
	L sync.RWMutex
}

func NewConMapBoolInt16() *ConMapBoolInt16 {
	return ToConMapBoolInt16(nil)
}

func ToConMapBoolInt16(data map[bool]int16) *ConMapBoolInt16 {
	if data == nil {
		data = make(map[bool]int16)
	}
	return &ConMapBoolInt16{M: data}
}

func (cm *ConMapBoolInt16) Get(k bool) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolInt16) GetOK(k bool) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolInt16) Set(k bool, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolInt16) Delete(k bool) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolInt32 struct {
	M map[bool]int32
	L sync.RWMutex
}

func NewConMapBoolInt32() *ConMapBoolInt32 {
	return ToConMapBoolInt32(nil)
}

func ToConMapBoolInt32(data map[bool]int32) *ConMapBoolInt32 {
	if data == nil {
		data = make(map[bool]int32)
	}
	return &ConMapBoolInt32{M: data}
}

func (cm *ConMapBoolInt32) Get(k bool) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolInt32) GetOK(k bool) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolInt32) Set(k bool, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolInt32) Delete(k bool) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolInt64 struct {
	M map[bool]int64
	L sync.RWMutex
}

func NewConMapBoolInt64() *ConMapBoolInt64 {
	return ToConMapBoolInt64(nil)
}

func ToConMapBoolInt64(data map[bool]int64) *ConMapBoolInt64 {
	if data == nil {
		data = make(map[bool]int64)
	}
	return &ConMapBoolInt64{M: data}
}

func (cm *ConMapBoolInt64) Get(k bool) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolInt64) GetOK(k bool) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolInt64) Set(k bool, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolInt64) Delete(k bool) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolInt8 struct {
	M map[bool]int8
	L sync.RWMutex
}

func NewConMapBoolInt8() *ConMapBoolInt8 {
	return ToConMapBoolInt8(nil)
}

func ToConMapBoolInt8(data map[bool]int8) *ConMapBoolInt8 {
	if data == nil {
		data = make(map[bool]int8)
	}
	return &ConMapBoolInt8{M: data}
}

func (cm *ConMapBoolInt8) Get(k bool) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolInt8) GetOK(k bool) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolInt8) Set(k bool, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolInt8) Delete(k bool) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolRune struct {
	M map[bool]rune
	L sync.RWMutex
}

func NewConMapBoolRune() *ConMapBoolRune {
	return ToConMapBoolRune(nil)
}

func ToConMapBoolRune(data map[bool]rune) *ConMapBoolRune {
	if data == nil {
		data = make(map[bool]rune)
	}
	return &ConMapBoolRune{M: data}
}

func (cm *ConMapBoolRune) Get(k bool) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolRune) GetOK(k bool) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolRune) Set(k bool, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolRune) Delete(k bool) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolString struct {
	M map[bool]string
	L sync.RWMutex
}

func NewConMapBoolString() *ConMapBoolString {
	return ToConMapBoolString(nil)
}

func ToConMapBoolString(data map[bool]string) *ConMapBoolString {
	if data == nil {
		data = make(map[bool]string)
	}
	return &ConMapBoolString{M: data}
}

func (cm *ConMapBoolString) Get(k bool) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolString) GetOK(k bool) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolString) Set(k bool, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolString) Delete(k bool) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolUint struct {
	M map[bool]uint
	L sync.RWMutex
}

func NewConMapBoolUint() *ConMapBoolUint {
	return ToConMapBoolUint(nil)
}

func ToConMapBoolUint(data map[bool]uint) *ConMapBoolUint {
	if data == nil {
		data = make(map[bool]uint)
	}
	return &ConMapBoolUint{M: data}
}

func (cm *ConMapBoolUint) Get(k bool) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolUint) GetOK(k bool) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolUint) Set(k bool, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolUint) Delete(k bool) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolUint16 struct {
	M map[bool]uint16
	L sync.RWMutex
}

func NewConMapBoolUint16() *ConMapBoolUint16 {
	return ToConMapBoolUint16(nil)
}

func ToConMapBoolUint16(data map[bool]uint16) *ConMapBoolUint16 {
	if data == nil {
		data = make(map[bool]uint16)
	}
	return &ConMapBoolUint16{M: data}
}

func (cm *ConMapBoolUint16) Get(k bool) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolUint16) GetOK(k bool) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolUint16) Set(k bool, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolUint16) Delete(k bool) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolUint32 struct {
	M map[bool]uint32
	L sync.RWMutex
}

func NewConMapBoolUint32() *ConMapBoolUint32 {
	return ToConMapBoolUint32(nil)
}

func ToConMapBoolUint32(data map[bool]uint32) *ConMapBoolUint32 {
	if data == nil {
		data = make(map[bool]uint32)
	}
	return &ConMapBoolUint32{M: data}
}

func (cm *ConMapBoolUint32) Get(k bool) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolUint32) GetOK(k bool) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolUint32) Set(k bool, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolUint32) Delete(k bool) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolUint64 struct {
	M map[bool]uint64
	L sync.RWMutex
}

func NewConMapBoolUint64() *ConMapBoolUint64 {
	return ToConMapBoolUint64(nil)
}

func ToConMapBoolUint64(data map[bool]uint64) *ConMapBoolUint64 {
	if data == nil {
		data = make(map[bool]uint64)
	}
	return &ConMapBoolUint64{M: data}
}

func (cm *ConMapBoolUint64) Get(k bool) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolUint64) GetOK(k bool) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolUint64) Set(k bool, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolUint64) Delete(k bool) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolUint8 struct {
	M map[bool]uint8
	L sync.RWMutex
}

func NewConMapBoolUint8() *ConMapBoolUint8 {
	return ToConMapBoolUint8(nil)
}

func ToConMapBoolUint8(data map[bool]uint8) *ConMapBoolUint8 {
	if data == nil {
		data = make(map[bool]uint8)
	}
	return &ConMapBoolUint8{M: data}
}

func (cm *ConMapBoolUint8) Get(k bool) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolUint8) GetOK(k bool) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolUint8) Set(k bool, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolUint8) Delete(k bool) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapBoolUintptr struct {
	M map[bool]uintptr
	L sync.RWMutex
}

func NewConMapBoolUintptr() *ConMapBoolUintptr {
	return ToConMapBoolUintptr(nil)
}

func ToConMapBoolUintptr(data map[bool]uintptr) *ConMapBoolUintptr {
	if data == nil {
		data = make(map[bool]uintptr)
	}
	return &ConMapBoolUintptr{M: data}
}

func (cm *ConMapBoolUintptr) Get(k bool) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapBoolUintptr) GetOK(k bool) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapBoolUintptr) Set(k bool, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapBoolUintptr) Delete(k bool) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapBoolUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteBool struct {
	M map[byte]bool
	L sync.RWMutex
}

func NewConMapByteBool() *ConMapByteBool {
	return ToConMapByteBool(nil)
}

func ToConMapByteBool(data map[byte]bool) *ConMapByteBool {
	if data == nil {
		data = make(map[byte]bool)
	}
	return &ConMapByteBool{M: data}
}

func (cm *ConMapByteBool) Get(k byte) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteBool) GetOK(k byte) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteBool) Set(k byte, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteBool) Delete(k byte) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteByte struct {
	M map[byte]byte
	L sync.RWMutex
}

func NewConMapByteByte() *ConMapByteByte {
	return ToConMapByteByte(nil)
}

func ToConMapByteByte(data map[byte]byte) *ConMapByteByte {
	if data == nil {
		data = make(map[byte]byte)
	}
	return &ConMapByteByte{M: data}
}

func (cm *ConMapByteByte) Get(k byte) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteByte) GetOK(k byte) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteByte) Set(k byte, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteByte) Delete(k byte) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteComplex128 struct {
	M map[byte]complex128
	L sync.RWMutex
}

func NewConMapByteComplex128() *ConMapByteComplex128 {
	return ToConMapByteComplex128(nil)
}

func ToConMapByteComplex128(data map[byte]complex128) *ConMapByteComplex128 {
	if data == nil {
		data = make(map[byte]complex128)
	}
	return &ConMapByteComplex128{M: data}
}

func (cm *ConMapByteComplex128) Get(k byte) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteComplex128) GetOK(k byte) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteComplex128) Set(k byte, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteComplex128) Delete(k byte) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteComplex64 struct {
	M map[byte]complex64
	L sync.RWMutex
}

func NewConMapByteComplex64() *ConMapByteComplex64 {
	return ToConMapByteComplex64(nil)
}

func ToConMapByteComplex64(data map[byte]complex64) *ConMapByteComplex64 {
	if data == nil {
		data = make(map[byte]complex64)
	}
	return &ConMapByteComplex64{M: data}
}

func (cm *ConMapByteComplex64) Get(k byte) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteComplex64) GetOK(k byte) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteComplex64) Set(k byte, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteComplex64) Delete(k byte) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteError struct {
	M map[byte]error
	L sync.RWMutex
}

func NewConMapByteError() *ConMapByteError {
	return ToConMapByteError(nil)
}

func ToConMapByteError(data map[byte]error) *ConMapByteError {
	if data == nil {
		data = make(map[byte]error)
	}
	return &ConMapByteError{M: data}
}

func (cm *ConMapByteError) Get(k byte) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteError) GetOK(k byte) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteError) Set(k byte, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteError) Delete(k byte) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteFloat32 struct {
	M map[byte]float32
	L sync.RWMutex
}

func NewConMapByteFloat32() *ConMapByteFloat32 {
	return ToConMapByteFloat32(nil)
}

func ToConMapByteFloat32(data map[byte]float32) *ConMapByteFloat32 {
	if data == nil {
		data = make(map[byte]float32)
	}
	return &ConMapByteFloat32{M: data}
}

func (cm *ConMapByteFloat32) Get(k byte) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteFloat32) GetOK(k byte) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteFloat32) Set(k byte, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteFloat32) Delete(k byte) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteFloat64 struct {
	M map[byte]float64
	L sync.RWMutex
}

func NewConMapByteFloat64() *ConMapByteFloat64 {
	return ToConMapByteFloat64(nil)
}

func ToConMapByteFloat64(data map[byte]float64) *ConMapByteFloat64 {
	if data == nil {
		data = make(map[byte]float64)
	}
	return &ConMapByteFloat64{M: data}
}

func (cm *ConMapByteFloat64) Get(k byte) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteFloat64) GetOK(k byte) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteFloat64) Set(k byte, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteFloat64) Delete(k byte) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteInt struct {
	M map[byte]int
	L sync.RWMutex
}

func NewConMapByteInt() *ConMapByteInt {
	return ToConMapByteInt(nil)
}

func ToConMapByteInt(data map[byte]int) *ConMapByteInt {
	if data == nil {
		data = make(map[byte]int)
	}
	return &ConMapByteInt{M: data}
}

func (cm *ConMapByteInt) Get(k byte) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteInt) GetOK(k byte) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteInt) Set(k byte, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteInt) Delete(k byte) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteInt16 struct {
	M map[byte]int16
	L sync.RWMutex
}

func NewConMapByteInt16() *ConMapByteInt16 {
	return ToConMapByteInt16(nil)
}

func ToConMapByteInt16(data map[byte]int16) *ConMapByteInt16 {
	if data == nil {
		data = make(map[byte]int16)
	}
	return &ConMapByteInt16{M: data}
}

func (cm *ConMapByteInt16) Get(k byte) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteInt16) GetOK(k byte) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteInt16) Set(k byte, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteInt16) Delete(k byte) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteInt32 struct {
	M map[byte]int32
	L sync.RWMutex
}

func NewConMapByteInt32() *ConMapByteInt32 {
	return ToConMapByteInt32(nil)
}

func ToConMapByteInt32(data map[byte]int32) *ConMapByteInt32 {
	if data == nil {
		data = make(map[byte]int32)
	}
	return &ConMapByteInt32{M: data}
}

func (cm *ConMapByteInt32) Get(k byte) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteInt32) GetOK(k byte) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteInt32) Set(k byte, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteInt32) Delete(k byte) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteInt64 struct {
	M map[byte]int64
	L sync.RWMutex
}

func NewConMapByteInt64() *ConMapByteInt64 {
	return ToConMapByteInt64(nil)
}

func ToConMapByteInt64(data map[byte]int64) *ConMapByteInt64 {
	if data == nil {
		data = make(map[byte]int64)
	}
	return &ConMapByteInt64{M: data}
}

func (cm *ConMapByteInt64) Get(k byte) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteInt64) GetOK(k byte) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteInt64) Set(k byte, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteInt64) Delete(k byte) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteInt8 struct {
	M map[byte]int8
	L sync.RWMutex
}

func NewConMapByteInt8() *ConMapByteInt8 {
	return ToConMapByteInt8(nil)
}

func ToConMapByteInt8(data map[byte]int8) *ConMapByteInt8 {
	if data == nil {
		data = make(map[byte]int8)
	}
	return &ConMapByteInt8{M: data}
}

func (cm *ConMapByteInt8) Get(k byte) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteInt8) GetOK(k byte) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteInt8) Set(k byte, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteInt8) Delete(k byte) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteRune struct {
	M map[byte]rune
	L sync.RWMutex
}

func NewConMapByteRune() *ConMapByteRune {
	return ToConMapByteRune(nil)
}

func ToConMapByteRune(data map[byte]rune) *ConMapByteRune {
	if data == nil {
		data = make(map[byte]rune)
	}
	return &ConMapByteRune{M: data}
}

func (cm *ConMapByteRune) Get(k byte) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteRune) GetOK(k byte) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteRune) Set(k byte, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteRune) Delete(k byte) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteString struct {
	M map[byte]string
	L sync.RWMutex
}

func NewConMapByteString() *ConMapByteString {
	return ToConMapByteString(nil)
}

func ToConMapByteString(data map[byte]string) *ConMapByteString {
	if data == nil {
		data = make(map[byte]string)
	}
	return &ConMapByteString{M: data}
}

func (cm *ConMapByteString) Get(k byte) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteString) GetOK(k byte) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteString) Set(k byte, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteString) Delete(k byte) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteUint struct {
	M map[byte]uint
	L sync.RWMutex
}

func NewConMapByteUint() *ConMapByteUint {
	return ToConMapByteUint(nil)
}

func ToConMapByteUint(data map[byte]uint) *ConMapByteUint {
	if data == nil {
		data = make(map[byte]uint)
	}
	return &ConMapByteUint{M: data}
}

func (cm *ConMapByteUint) Get(k byte) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteUint) GetOK(k byte) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteUint) Set(k byte, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteUint) Delete(k byte) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteUint16 struct {
	M map[byte]uint16
	L sync.RWMutex
}

func NewConMapByteUint16() *ConMapByteUint16 {
	return ToConMapByteUint16(nil)
}

func ToConMapByteUint16(data map[byte]uint16) *ConMapByteUint16 {
	if data == nil {
		data = make(map[byte]uint16)
	}
	return &ConMapByteUint16{M: data}
}

func (cm *ConMapByteUint16) Get(k byte) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteUint16) GetOK(k byte) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteUint16) Set(k byte, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteUint16) Delete(k byte) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteUint32 struct {
	M map[byte]uint32
	L sync.RWMutex
}

func NewConMapByteUint32() *ConMapByteUint32 {
	return ToConMapByteUint32(nil)
}

func ToConMapByteUint32(data map[byte]uint32) *ConMapByteUint32 {
	if data == nil {
		data = make(map[byte]uint32)
	}
	return &ConMapByteUint32{M: data}
}

func (cm *ConMapByteUint32) Get(k byte) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteUint32) GetOK(k byte) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteUint32) Set(k byte, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteUint32) Delete(k byte) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteUint64 struct {
	M map[byte]uint64
	L sync.RWMutex
}

func NewConMapByteUint64() *ConMapByteUint64 {
	return ToConMapByteUint64(nil)
}

func ToConMapByteUint64(data map[byte]uint64) *ConMapByteUint64 {
	if data == nil {
		data = make(map[byte]uint64)
	}
	return &ConMapByteUint64{M: data}
}

func (cm *ConMapByteUint64) Get(k byte) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteUint64) GetOK(k byte) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteUint64) Set(k byte, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteUint64) Delete(k byte) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteUint8 struct {
	M map[byte]uint8
	L sync.RWMutex
}

func NewConMapByteUint8() *ConMapByteUint8 {
	return ToConMapByteUint8(nil)
}

func ToConMapByteUint8(data map[byte]uint8) *ConMapByteUint8 {
	if data == nil {
		data = make(map[byte]uint8)
	}
	return &ConMapByteUint8{M: data}
}

func (cm *ConMapByteUint8) Get(k byte) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteUint8) GetOK(k byte) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteUint8) Set(k byte, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteUint8) Delete(k byte) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapByteUintptr struct {
	M map[byte]uintptr
	L sync.RWMutex
}

func NewConMapByteUintptr() *ConMapByteUintptr {
	return ToConMapByteUintptr(nil)
}

func ToConMapByteUintptr(data map[byte]uintptr) *ConMapByteUintptr {
	if data == nil {
		data = make(map[byte]uintptr)
	}
	return &ConMapByteUintptr{M: data}
}

func (cm *ConMapByteUintptr) Get(k byte) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapByteUintptr) GetOK(k byte) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapByteUintptr) Set(k byte, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapByteUintptr) Delete(k byte) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapByteUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Bool struct {
	M map[complex128]bool
	L sync.RWMutex
}

func NewConMapComplex128Bool() *ConMapComplex128Bool {
	return ToConMapComplex128Bool(nil)
}

func ToConMapComplex128Bool(data map[complex128]bool) *ConMapComplex128Bool {
	if data == nil {
		data = make(map[complex128]bool)
	}
	return &ConMapComplex128Bool{M: data}
}

func (cm *ConMapComplex128Bool) Get(k complex128) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Bool) GetOK(k complex128) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Bool) Set(k complex128, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Bool) Delete(k complex128) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Byte struct {
	M map[complex128]byte
	L sync.RWMutex
}

func NewConMapComplex128Byte() *ConMapComplex128Byte {
	return ToConMapComplex128Byte(nil)
}

func ToConMapComplex128Byte(data map[complex128]byte) *ConMapComplex128Byte {
	if data == nil {
		data = make(map[complex128]byte)
	}
	return &ConMapComplex128Byte{M: data}
}

func (cm *ConMapComplex128Byte) Get(k complex128) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Byte) GetOK(k complex128) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Byte) Set(k complex128, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Byte) Delete(k complex128) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Complex128 struct {
	M map[complex128]complex128
	L sync.RWMutex
}

func NewConMapComplex128Complex128() *ConMapComplex128Complex128 {
	return ToConMapComplex128Complex128(nil)
}

func ToConMapComplex128Complex128(data map[complex128]complex128) *ConMapComplex128Complex128 {
	if data == nil {
		data = make(map[complex128]complex128)
	}
	return &ConMapComplex128Complex128{M: data}
}

func (cm *ConMapComplex128Complex128) Get(k complex128) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Complex128) GetOK(k complex128) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Complex128) Set(k complex128, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Complex128) Delete(k complex128) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Complex64 struct {
	M map[complex128]complex64
	L sync.RWMutex
}

func NewConMapComplex128Complex64() *ConMapComplex128Complex64 {
	return ToConMapComplex128Complex64(nil)
}

func ToConMapComplex128Complex64(data map[complex128]complex64) *ConMapComplex128Complex64 {
	if data == nil {
		data = make(map[complex128]complex64)
	}
	return &ConMapComplex128Complex64{M: data}
}

func (cm *ConMapComplex128Complex64) Get(k complex128) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Complex64) GetOK(k complex128) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Complex64) Set(k complex128, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Complex64) Delete(k complex128) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Error struct {
	M map[complex128]error
	L sync.RWMutex
}

func NewConMapComplex128Error() *ConMapComplex128Error {
	return ToConMapComplex128Error(nil)
}

func ToConMapComplex128Error(data map[complex128]error) *ConMapComplex128Error {
	if data == nil {
		data = make(map[complex128]error)
	}
	return &ConMapComplex128Error{M: data}
}

func (cm *ConMapComplex128Error) Get(k complex128) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Error) GetOK(k complex128) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Error) Set(k complex128, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Error) Delete(k complex128) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Float32 struct {
	M map[complex128]float32
	L sync.RWMutex
}

func NewConMapComplex128Float32() *ConMapComplex128Float32 {
	return ToConMapComplex128Float32(nil)
}

func ToConMapComplex128Float32(data map[complex128]float32) *ConMapComplex128Float32 {
	if data == nil {
		data = make(map[complex128]float32)
	}
	return &ConMapComplex128Float32{M: data}
}

func (cm *ConMapComplex128Float32) Get(k complex128) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Float32) GetOK(k complex128) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Float32) Set(k complex128, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Float32) Delete(k complex128) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Float64 struct {
	M map[complex128]float64
	L sync.RWMutex
}

func NewConMapComplex128Float64() *ConMapComplex128Float64 {
	return ToConMapComplex128Float64(nil)
}

func ToConMapComplex128Float64(data map[complex128]float64) *ConMapComplex128Float64 {
	if data == nil {
		data = make(map[complex128]float64)
	}
	return &ConMapComplex128Float64{M: data}
}

func (cm *ConMapComplex128Float64) Get(k complex128) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Float64) GetOK(k complex128) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Float64) Set(k complex128, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Float64) Delete(k complex128) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Int struct {
	M map[complex128]int
	L sync.RWMutex
}

func NewConMapComplex128Int() *ConMapComplex128Int {
	return ToConMapComplex128Int(nil)
}

func ToConMapComplex128Int(data map[complex128]int) *ConMapComplex128Int {
	if data == nil {
		data = make(map[complex128]int)
	}
	return &ConMapComplex128Int{M: data}
}

func (cm *ConMapComplex128Int) Get(k complex128) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Int) GetOK(k complex128) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Int) Set(k complex128, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Int) Delete(k complex128) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Int16 struct {
	M map[complex128]int16
	L sync.RWMutex
}

func NewConMapComplex128Int16() *ConMapComplex128Int16 {
	return ToConMapComplex128Int16(nil)
}

func ToConMapComplex128Int16(data map[complex128]int16) *ConMapComplex128Int16 {
	if data == nil {
		data = make(map[complex128]int16)
	}
	return &ConMapComplex128Int16{M: data}
}

func (cm *ConMapComplex128Int16) Get(k complex128) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Int16) GetOK(k complex128) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Int16) Set(k complex128, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Int16) Delete(k complex128) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Int32 struct {
	M map[complex128]int32
	L sync.RWMutex
}

func NewConMapComplex128Int32() *ConMapComplex128Int32 {
	return ToConMapComplex128Int32(nil)
}

func ToConMapComplex128Int32(data map[complex128]int32) *ConMapComplex128Int32 {
	if data == nil {
		data = make(map[complex128]int32)
	}
	return &ConMapComplex128Int32{M: data}
}

func (cm *ConMapComplex128Int32) Get(k complex128) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Int32) GetOK(k complex128) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Int32) Set(k complex128, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Int32) Delete(k complex128) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Int64 struct {
	M map[complex128]int64
	L sync.RWMutex
}

func NewConMapComplex128Int64() *ConMapComplex128Int64 {
	return ToConMapComplex128Int64(nil)
}

func ToConMapComplex128Int64(data map[complex128]int64) *ConMapComplex128Int64 {
	if data == nil {
		data = make(map[complex128]int64)
	}
	return &ConMapComplex128Int64{M: data}
}

func (cm *ConMapComplex128Int64) Get(k complex128) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Int64) GetOK(k complex128) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Int64) Set(k complex128, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Int64) Delete(k complex128) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Int8 struct {
	M map[complex128]int8
	L sync.RWMutex
}

func NewConMapComplex128Int8() *ConMapComplex128Int8 {
	return ToConMapComplex128Int8(nil)
}

func ToConMapComplex128Int8(data map[complex128]int8) *ConMapComplex128Int8 {
	if data == nil {
		data = make(map[complex128]int8)
	}
	return &ConMapComplex128Int8{M: data}
}

func (cm *ConMapComplex128Int8) Get(k complex128) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Int8) GetOK(k complex128) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Int8) Set(k complex128, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Int8) Delete(k complex128) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Rune struct {
	M map[complex128]rune
	L sync.RWMutex
}

func NewConMapComplex128Rune() *ConMapComplex128Rune {
	return ToConMapComplex128Rune(nil)
}

func ToConMapComplex128Rune(data map[complex128]rune) *ConMapComplex128Rune {
	if data == nil {
		data = make(map[complex128]rune)
	}
	return &ConMapComplex128Rune{M: data}
}

func (cm *ConMapComplex128Rune) Get(k complex128) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Rune) GetOK(k complex128) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Rune) Set(k complex128, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Rune) Delete(k complex128) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128String struct {
	M map[complex128]string
	L sync.RWMutex
}

func NewConMapComplex128String() *ConMapComplex128String {
	return ToConMapComplex128String(nil)
}

func ToConMapComplex128String(data map[complex128]string) *ConMapComplex128String {
	if data == nil {
		data = make(map[complex128]string)
	}
	return &ConMapComplex128String{M: data}
}

func (cm *ConMapComplex128String) Get(k complex128) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128String) GetOK(k complex128) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128String) Set(k complex128, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128String) Delete(k complex128) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Uint struct {
	M map[complex128]uint
	L sync.RWMutex
}

func NewConMapComplex128Uint() *ConMapComplex128Uint {
	return ToConMapComplex128Uint(nil)
}

func ToConMapComplex128Uint(data map[complex128]uint) *ConMapComplex128Uint {
	if data == nil {
		data = make(map[complex128]uint)
	}
	return &ConMapComplex128Uint{M: data}
}

func (cm *ConMapComplex128Uint) Get(k complex128) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Uint) GetOK(k complex128) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Uint) Set(k complex128, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Uint) Delete(k complex128) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Uint16 struct {
	M map[complex128]uint16
	L sync.RWMutex
}

func NewConMapComplex128Uint16() *ConMapComplex128Uint16 {
	return ToConMapComplex128Uint16(nil)
}

func ToConMapComplex128Uint16(data map[complex128]uint16) *ConMapComplex128Uint16 {
	if data == nil {
		data = make(map[complex128]uint16)
	}
	return &ConMapComplex128Uint16{M: data}
}

func (cm *ConMapComplex128Uint16) Get(k complex128) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Uint16) GetOK(k complex128) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Uint16) Set(k complex128, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Uint16) Delete(k complex128) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Uint32 struct {
	M map[complex128]uint32
	L sync.RWMutex
}

func NewConMapComplex128Uint32() *ConMapComplex128Uint32 {
	return ToConMapComplex128Uint32(nil)
}

func ToConMapComplex128Uint32(data map[complex128]uint32) *ConMapComplex128Uint32 {
	if data == nil {
		data = make(map[complex128]uint32)
	}
	return &ConMapComplex128Uint32{M: data}
}

func (cm *ConMapComplex128Uint32) Get(k complex128) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Uint32) GetOK(k complex128) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Uint32) Set(k complex128, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Uint32) Delete(k complex128) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Uint64 struct {
	M map[complex128]uint64
	L sync.RWMutex
}

func NewConMapComplex128Uint64() *ConMapComplex128Uint64 {
	return ToConMapComplex128Uint64(nil)
}

func ToConMapComplex128Uint64(data map[complex128]uint64) *ConMapComplex128Uint64 {
	if data == nil {
		data = make(map[complex128]uint64)
	}
	return &ConMapComplex128Uint64{M: data}
}

func (cm *ConMapComplex128Uint64) Get(k complex128) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Uint64) GetOK(k complex128) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Uint64) Set(k complex128, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Uint64) Delete(k complex128) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Uint8 struct {
	M map[complex128]uint8
	L sync.RWMutex
}

func NewConMapComplex128Uint8() *ConMapComplex128Uint8 {
	return ToConMapComplex128Uint8(nil)
}

func ToConMapComplex128Uint8(data map[complex128]uint8) *ConMapComplex128Uint8 {
	if data == nil {
		data = make(map[complex128]uint8)
	}
	return &ConMapComplex128Uint8{M: data}
}

func (cm *ConMapComplex128Uint8) Get(k complex128) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Uint8) GetOK(k complex128) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Uint8) Set(k complex128, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Uint8) Delete(k complex128) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex128Uintptr struct {
	M map[complex128]uintptr
	L sync.RWMutex
}

func NewConMapComplex128Uintptr() *ConMapComplex128Uintptr {
	return ToConMapComplex128Uintptr(nil)
}

func ToConMapComplex128Uintptr(data map[complex128]uintptr) *ConMapComplex128Uintptr {
	if data == nil {
		data = make(map[complex128]uintptr)
	}
	return &ConMapComplex128Uintptr{M: data}
}

func (cm *ConMapComplex128Uintptr) Get(k complex128) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex128Uintptr) GetOK(k complex128) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex128Uintptr) Set(k complex128, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex128Uintptr) Delete(k complex128) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex128Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Bool struct {
	M map[complex64]bool
	L sync.RWMutex
}

func NewConMapComplex64Bool() *ConMapComplex64Bool {
	return ToConMapComplex64Bool(nil)
}

func ToConMapComplex64Bool(data map[complex64]bool) *ConMapComplex64Bool {
	if data == nil {
		data = make(map[complex64]bool)
	}
	return &ConMapComplex64Bool{M: data}
}

func (cm *ConMapComplex64Bool) Get(k complex64) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Bool) GetOK(k complex64) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Bool) Set(k complex64, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Bool) Delete(k complex64) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Byte struct {
	M map[complex64]byte
	L sync.RWMutex
}

func NewConMapComplex64Byte() *ConMapComplex64Byte {
	return ToConMapComplex64Byte(nil)
}

func ToConMapComplex64Byte(data map[complex64]byte) *ConMapComplex64Byte {
	if data == nil {
		data = make(map[complex64]byte)
	}
	return &ConMapComplex64Byte{M: data}
}

func (cm *ConMapComplex64Byte) Get(k complex64) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Byte) GetOK(k complex64) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Byte) Set(k complex64, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Byte) Delete(k complex64) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Complex128 struct {
	M map[complex64]complex128
	L sync.RWMutex
}

func NewConMapComplex64Complex128() *ConMapComplex64Complex128 {
	return ToConMapComplex64Complex128(nil)
}

func ToConMapComplex64Complex128(data map[complex64]complex128) *ConMapComplex64Complex128 {
	if data == nil {
		data = make(map[complex64]complex128)
	}
	return &ConMapComplex64Complex128{M: data}
}

func (cm *ConMapComplex64Complex128) Get(k complex64) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Complex128) GetOK(k complex64) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Complex128) Set(k complex64, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Complex128) Delete(k complex64) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Complex64 struct {
	M map[complex64]complex64
	L sync.RWMutex
}

func NewConMapComplex64Complex64() *ConMapComplex64Complex64 {
	return ToConMapComplex64Complex64(nil)
}

func ToConMapComplex64Complex64(data map[complex64]complex64) *ConMapComplex64Complex64 {
	if data == nil {
		data = make(map[complex64]complex64)
	}
	return &ConMapComplex64Complex64{M: data}
}

func (cm *ConMapComplex64Complex64) Get(k complex64) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Complex64) GetOK(k complex64) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Complex64) Set(k complex64, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Complex64) Delete(k complex64) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Error struct {
	M map[complex64]error
	L sync.RWMutex
}

func NewConMapComplex64Error() *ConMapComplex64Error {
	return ToConMapComplex64Error(nil)
}

func ToConMapComplex64Error(data map[complex64]error) *ConMapComplex64Error {
	if data == nil {
		data = make(map[complex64]error)
	}
	return &ConMapComplex64Error{M: data}
}

func (cm *ConMapComplex64Error) Get(k complex64) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Error) GetOK(k complex64) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Error) Set(k complex64, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Error) Delete(k complex64) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Float32 struct {
	M map[complex64]float32
	L sync.RWMutex
}

func NewConMapComplex64Float32() *ConMapComplex64Float32 {
	return ToConMapComplex64Float32(nil)
}

func ToConMapComplex64Float32(data map[complex64]float32) *ConMapComplex64Float32 {
	if data == nil {
		data = make(map[complex64]float32)
	}
	return &ConMapComplex64Float32{M: data}
}

func (cm *ConMapComplex64Float32) Get(k complex64) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Float32) GetOK(k complex64) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Float32) Set(k complex64, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Float32) Delete(k complex64) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Float64 struct {
	M map[complex64]float64
	L sync.RWMutex
}

func NewConMapComplex64Float64() *ConMapComplex64Float64 {
	return ToConMapComplex64Float64(nil)
}

func ToConMapComplex64Float64(data map[complex64]float64) *ConMapComplex64Float64 {
	if data == nil {
		data = make(map[complex64]float64)
	}
	return &ConMapComplex64Float64{M: data}
}

func (cm *ConMapComplex64Float64) Get(k complex64) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Float64) GetOK(k complex64) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Float64) Set(k complex64, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Float64) Delete(k complex64) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Int struct {
	M map[complex64]int
	L sync.RWMutex
}

func NewConMapComplex64Int() *ConMapComplex64Int {
	return ToConMapComplex64Int(nil)
}

func ToConMapComplex64Int(data map[complex64]int) *ConMapComplex64Int {
	if data == nil {
		data = make(map[complex64]int)
	}
	return &ConMapComplex64Int{M: data}
}

func (cm *ConMapComplex64Int) Get(k complex64) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Int) GetOK(k complex64) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Int) Set(k complex64, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Int) Delete(k complex64) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Int16 struct {
	M map[complex64]int16
	L sync.RWMutex
}

func NewConMapComplex64Int16() *ConMapComplex64Int16 {
	return ToConMapComplex64Int16(nil)
}

func ToConMapComplex64Int16(data map[complex64]int16) *ConMapComplex64Int16 {
	if data == nil {
		data = make(map[complex64]int16)
	}
	return &ConMapComplex64Int16{M: data}
}

func (cm *ConMapComplex64Int16) Get(k complex64) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Int16) GetOK(k complex64) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Int16) Set(k complex64, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Int16) Delete(k complex64) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Int32 struct {
	M map[complex64]int32
	L sync.RWMutex
}

func NewConMapComplex64Int32() *ConMapComplex64Int32 {
	return ToConMapComplex64Int32(nil)
}

func ToConMapComplex64Int32(data map[complex64]int32) *ConMapComplex64Int32 {
	if data == nil {
		data = make(map[complex64]int32)
	}
	return &ConMapComplex64Int32{M: data}
}

func (cm *ConMapComplex64Int32) Get(k complex64) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Int32) GetOK(k complex64) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Int32) Set(k complex64, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Int32) Delete(k complex64) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Int64 struct {
	M map[complex64]int64
	L sync.RWMutex
}

func NewConMapComplex64Int64() *ConMapComplex64Int64 {
	return ToConMapComplex64Int64(nil)
}

func ToConMapComplex64Int64(data map[complex64]int64) *ConMapComplex64Int64 {
	if data == nil {
		data = make(map[complex64]int64)
	}
	return &ConMapComplex64Int64{M: data}
}

func (cm *ConMapComplex64Int64) Get(k complex64) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Int64) GetOK(k complex64) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Int64) Set(k complex64, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Int64) Delete(k complex64) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Int8 struct {
	M map[complex64]int8
	L sync.RWMutex
}

func NewConMapComplex64Int8() *ConMapComplex64Int8 {
	return ToConMapComplex64Int8(nil)
}

func ToConMapComplex64Int8(data map[complex64]int8) *ConMapComplex64Int8 {
	if data == nil {
		data = make(map[complex64]int8)
	}
	return &ConMapComplex64Int8{M: data}
}

func (cm *ConMapComplex64Int8) Get(k complex64) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Int8) GetOK(k complex64) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Int8) Set(k complex64, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Int8) Delete(k complex64) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Rune struct {
	M map[complex64]rune
	L sync.RWMutex
}

func NewConMapComplex64Rune() *ConMapComplex64Rune {
	return ToConMapComplex64Rune(nil)
}

func ToConMapComplex64Rune(data map[complex64]rune) *ConMapComplex64Rune {
	if data == nil {
		data = make(map[complex64]rune)
	}
	return &ConMapComplex64Rune{M: data}
}

func (cm *ConMapComplex64Rune) Get(k complex64) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Rune) GetOK(k complex64) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Rune) Set(k complex64, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Rune) Delete(k complex64) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64String struct {
	M map[complex64]string
	L sync.RWMutex
}

func NewConMapComplex64String() *ConMapComplex64String {
	return ToConMapComplex64String(nil)
}

func ToConMapComplex64String(data map[complex64]string) *ConMapComplex64String {
	if data == nil {
		data = make(map[complex64]string)
	}
	return &ConMapComplex64String{M: data}
}

func (cm *ConMapComplex64String) Get(k complex64) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64String) GetOK(k complex64) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64String) Set(k complex64, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64String) Delete(k complex64) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Uint struct {
	M map[complex64]uint
	L sync.RWMutex
}

func NewConMapComplex64Uint() *ConMapComplex64Uint {
	return ToConMapComplex64Uint(nil)
}

func ToConMapComplex64Uint(data map[complex64]uint) *ConMapComplex64Uint {
	if data == nil {
		data = make(map[complex64]uint)
	}
	return &ConMapComplex64Uint{M: data}
}

func (cm *ConMapComplex64Uint) Get(k complex64) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Uint) GetOK(k complex64) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Uint) Set(k complex64, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Uint) Delete(k complex64) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Uint16 struct {
	M map[complex64]uint16
	L sync.RWMutex
}

func NewConMapComplex64Uint16() *ConMapComplex64Uint16 {
	return ToConMapComplex64Uint16(nil)
}

func ToConMapComplex64Uint16(data map[complex64]uint16) *ConMapComplex64Uint16 {
	if data == nil {
		data = make(map[complex64]uint16)
	}
	return &ConMapComplex64Uint16{M: data}
}

func (cm *ConMapComplex64Uint16) Get(k complex64) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Uint16) GetOK(k complex64) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Uint16) Set(k complex64, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Uint16) Delete(k complex64) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Uint32 struct {
	M map[complex64]uint32
	L sync.RWMutex
}

func NewConMapComplex64Uint32() *ConMapComplex64Uint32 {
	return ToConMapComplex64Uint32(nil)
}

func ToConMapComplex64Uint32(data map[complex64]uint32) *ConMapComplex64Uint32 {
	if data == nil {
		data = make(map[complex64]uint32)
	}
	return &ConMapComplex64Uint32{M: data}
}

func (cm *ConMapComplex64Uint32) Get(k complex64) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Uint32) GetOK(k complex64) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Uint32) Set(k complex64, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Uint32) Delete(k complex64) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Uint64 struct {
	M map[complex64]uint64
	L sync.RWMutex
}

func NewConMapComplex64Uint64() *ConMapComplex64Uint64 {
	return ToConMapComplex64Uint64(nil)
}

func ToConMapComplex64Uint64(data map[complex64]uint64) *ConMapComplex64Uint64 {
	if data == nil {
		data = make(map[complex64]uint64)
	}
	return &ConMapComplex64Uint64{M: data}
}

func (cm *ConMapComplex64Uint64) Get(k complex64) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Uint64) GetOK(k complex64) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Uint64) Set(k complex64, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Uint64) Delete(k complex64) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Uint8 struct {
	M map[complex64]uint8
	L sync.RWMutex
}

func NewConMapComplex64Uint8() *ConMapComplex64Uint8 {
	return ToConMapComplex64Uint8(nil)
}

func ToConMapComplex64Uint8(data map[complex64]uint8) *ConMapComplex64Uint8 {
	if data == nil {
		data = make(map[complex64]uint8)
	}
	return &ConMapComplex64Uint8{M: data}
}

func (cm *ConMapComplex64Uint8) Get(k complex64) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Uint8) GetOK(k complex64) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Uint8) Set(k complex64, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Uint8) Delete(k complex64) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapComplex64Uintptr struct {
	M map[complex64]uintptr
	L sync.RWMutex
}

func NewConMapComplex64Uintptr() *ConMapComplex64Uintptr {
	return ToConMapComplex64Uintptr(nil)
}

func ToConMapComplex64Uintptr(data map[complex64]uintptr) *ConMapComplex64Uintptr {
	if data == nil {
		data = make(map[complex64]uintptr)
	}
	return &ConMapComplex64Uintptr{M: data}
}

func (cm *ConMapComplex64Uintptr) Get(k complex64) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapComplex64Uintptr) GetOK(k complex64) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapComplex64Uintptr) Set(k complex64, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapComplex64Uintptr) Delete(k complex64) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapComplex64Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorBool struct {
	M map[error]bool
	L sync.RWMutex
}

func NewConMapErrorBool() *ConMapErrorBool {
	return ToConMapErrorBool(nil)
}

func ToConMapErrorBool(data map[error]bool) *ConMapErrorBool {
	if data == nil {
		data = make(map[error]bool)
	}
	return &ConMapErrorBool{M: data}
}

func (cm *ConMapErrorBool) Get(k error) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorBool) GetOK(k error) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorBool) Set(k error, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorBool) Delete(k error) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorByte struct {
	M map[error]byte
	L sync.RWMutex
}

func NewConMapErrorByte() *ConMapErrorByte {
	return ToConMapErrorByte(nil)
}

func ToConMapErrorByte(data map[error]byte) *ConMapErrorByte {
	if data == nil {
		data = make(map[error]byte)
	}
	return &ConMapErrorByte{M: data}
}

func (cm *ConMapErrorByte) Get(k error) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorByte) GetOK(k error) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorByte) Set(k error, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorByte) Delete(k error) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorComplex128 struct {
	M map[error]complex128
	L sync.RWMutex
}

func NewConMapErrorComplex128() *ConMapErrorComplex128 {
	return ToConMapErrorComplex128(nil)
}

func ToConMapErrorComplex128(data map[error]complex128) *ConMapErrorComplex128 {
	if data == nil {
		data = make(map[error]complex128)
	}
	return &ConMapErrorComplex128{M: data}
}

func (cm *ConMapErrorComplex128) Get(k error) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorComplex128) GetOK(k error) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorComplex128) Set(k error, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorComplex128) Delete(k error) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorComplex64 struct {
	M map[error]complex64
	L sync.RWMutex
}

func NewConMapErrorComplex64() *ConMapErrorComplex64 {
	return ToConMapErrorComplex64(nil)
}

func ToConMapErrorComplex64(data map[error]complex64) *ConMapErrorComplex64 {
	if data == nil {
		data = make(map[error]complex64)
	}
	return &ConMapErrorComplex64{M: data}
}

func (cm *ConMapErrorComplex64) Get(k error) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorComplex64) GetOK(k error) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorComplex64) Set(k error, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorComplex64) Delete(k error) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorError struct {
	M map[error]error
	L sync.RWMutex
}

func NewConMapErrorError() *ConMapErrorError {
	return ToConMapErrorError(nil)
}

func ToConMapErrorError(data map[error]error) *ConMapErrorError {
	if data == nil {
		data = make(map[error]error)
	}
	return &ConMapErrorError{M: data}
}

func (cm *ConMapErrorError) Get(k error) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorError) GetOK(k error) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorError) Set(k error, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorError) Delete(k error) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorFloat32 struct {
	M map[error]float32
	L sync.RWMutex
}

func NewConMapErrorFloat32() *ConMapErrorFloat32 {
	return ToConMapErrorFloat32(nil)
}

func ToConMapErrorFloat32(data map[error]float32) *ConMapErrorFloat32 {
	if data == nil {
		data = make(map[error]float32)
	}
	return &ConMapErrorFloat32{M: data}
}

func (cm *ConMapErrorFloat32) Get(k error) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorFloat32) GetOK(k error) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorFloat32) Set(k error, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorFloat32) Delete(k error) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorFloat64 struct {
	M map[error]float64
	L sync.RWMutex
}

func NewConMapErrorFloat64() *ConMapErrorFloat64 {
	return ToConMapErrorFloat64(nil)
}

func ToConMapErrorFloat64(data map[error]float64) *ConMapErrorFloat64 {
	if data == nil {
		data = make(map[error]float64)
	}
	return &ConMapErrorFloat64{M: data}
}

func (cm *ConMapErrorFloat64) Get(k error) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorFloat64) GetOK(k error) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorFloat64) Set(k error, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorFloat64) Delete(k error) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorInt struct {
	M map[error]int
	L sync.RWMutex
}

func NewConMapErrorInt() *ConMapErrorInt {
	return ToConMapErrorInt(nil)
}

func ToConMapErrorInt(data map[error]int) *ConMapErrorInt {
	if data == nil {
		data = make(map[error]int)
	}
	return &ConMapErrorInt{M: data}
}

func (cm *ConMapErrorInt) Get(k error) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorInt) GetOK(k error) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorInt) Set(k error, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorInt) Delete(k error) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorInt16 struct {
	M map[error]int16
	L sync.RWMutex
}

func NewConMapErrorInt16() *ConMapErrorInt16 {
	return ToConMapErrorInt16(nil)
}

func ToConMapErrorInt16(data map[error]int16) *ConMapErrorInt16 {
	if data == nil {
		data = make(map[error]int16)
	}
	return &ConMapErrorInt16{M: data}
}

func (cm *ConMapErrorInt16) Get(k error) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorInt16) GetOK(k error) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorInt16) Set(k error, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorInt16) Delete(k error) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorInt32 struct {
	M map[error]int32
	L sync.RWMutex
}

func NewConMapErrorInt32() *ConMapErrorInt32 {
	return ToConMapErrorInt32(nil)
}

func ToConMapErrorInt32(data map[error]int32) *ConMapErrorInt32 {
	if data == nil {
		data = make(map[error]int32)
	}
	return &ConMapErrorInt32{M: data}
}

func (cm *ConMapErrorInt32) Get(k error) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorInt32) GetOK(k error) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorInt32) Set(k error, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorInt32) Delete(k error) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorInt64 struct {
	M map[error]int64
	L sync.RWMutex
}

func NewConMapErrorInt64() *ConMapErrorInt64 {
	return ToConMapErrorInt64(nil)
}

func ToConMapErrorInt64(data map[error]int64) *ConMapErrorInt64 {
	if data == nil {
		data = make(map[error]int64)
	}
	return &ConMapErrorInt64{M: data}
}

func (cm *ConMapErrorInt64) Get(k error) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorInt64) GetOK(k error) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorInt64) Set(k error, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorInt64) Delete(k error) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorInt8 struct {
	M map[error]int8
	L sync.RWMutex
}

func NewConMapErrorInt8() *ConMapErrorInt8 {
	return ToConMapErrorInt8(nil)
}

func ToConMapErrorInt8(data map[error]int8) *ConMapErrorInt8 {
	if data == nil {
		data = make(map[error]int8)
	}
	return &ConMapErrorInt8{M: data}
}

func (cm *ConMapErrorInt8) Get(k error) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorInt8) GetOK(k error) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorInt8) Set(k error, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorInt8) Delete(k error) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorRune struct {
	M map[error]rune
	L sync.RWMutex
}

func NewConMapErrorRune() *ConMapErrorRune {
	return ToConMapErrorRune(nil)
}

func ToConMapErrorRune(data map[error]rune) *ConMapErrorRune {
	if data == nil {
		data = make(map[error]rune)
	}
	return &ConMapErrorRune{M: data}
}

func (cm *ConMapErrorRune) Get(k error) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorRune) GetOK(k error) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorRune) Set(k error, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorRune) Delete(k error) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorString struct {
	M map[error]string
	L sync.RWMutex
}

func NewConMapErrorString() *ConMapErrorString {
	return ToConMapErrorString(nil)
}

func ToConMapErrorString(data map[error]string) *ConMapErrorString {
	if data == nil {
		data = make(map[error]string)
	}
	return &ConMapErrorString{M: data}
}

func (cm *ConMapErrorString) Get(k error) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorString) GetOK(k error) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorString) Set(k error, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorString) Delete(k error) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorUint struct {
	M map[error]uint
	L sync.RWMutex
}

func NewConMapErrorUint() *ConMapErrorUint {
	return ToConMapErrorUint(nil)
}

func ToConMapErrorUint(data map[error]uint) *ConMapErrorUint {
	if data == nil {
		data = make(map[error]uint)
	}
	return &ConMapErrorUint{M: data}
}

func (cm *ConMapErrorUint) Get(k error) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorUint) GetOK(k error) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorUint) Set(k error, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorUint) Delete(k error) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorUint16 struct {
	M map[error]uint16
	L sync.RWMutex
}

func NewConMapErrorUint16() *ConMapErrorUint16 {
	return ToConMapErrorUint16(nil)
}

func ToConMapErrorUint16(data map[error]uint16) *ConMapErrorUint16 {
	if data == nil {
		data = make(map[error]uint16)
	}
	return &ConMapErrorUint16{M: data}
}

func (cm *ConMapErrorUint16) Get(k error) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorUint16) GetOK(k error) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorUint16) Set(k error, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorUint16) Delete(k error) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorUint32 struct {
	M map[error]uint32
	L sync.RWMutex
}

func NewConMapErrorUint32() *ConMapErrorUint32 {
	return ToConMapErrorUint32(nil)
}

func ToConMapErrorUint32(data map[error]uint32) *ConMapErrorUint32 {
	if data == nil {
		data = make(map[error]uint32)
	}
	return &ConMapErrorUint32{M: data}
}

func (cm *ConMapErrorUint32) Get(k error) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorUint32) GetOK(k error) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorUint32) Set(k error, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorUint32) Delete(k error) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorUint64 struct {
	M map[error]uint64
	L sync.RWMutex
}

func NewConMapErrorUint64() *ConMapErrorUint64 {
	return ToConMapErrorUint64(nil)
}

func ToConMapErrorUint64(data map[error]uint64) *ConMapErrorUint64 {
	if data == nil {
		data = make(map[error]uint64)
	}
	return &ConMapErrorUint64{M: data}
}

func (cm *ConMapErrorUint64) Get(k error) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorUint64) GetOK(k error) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorUint64) Set(k error, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorUint64) Delete(k error) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorUint8 struct {
	M map[error]uint8
	L sync.RWMutex
}

func NewConMapErrorUint8() *ConMapErrorUint8 {
	return ToConMapErrorUint8(nil)
}

func ToConMapErrorUint8(data map[error]uint8) *ConMapErrorUint8 {
	if data == nil {
		data = make(map[error]uint8)
	}
	return &ConMapErrorUint8{M: data}
}

func (cm *ConMapErrorUint8) Get(k error) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorUint8) GetOK(k error) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorUint8) Set(k error, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorUint8) Delete(k error) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapErrorUintptr struct {
	M map[error]uintptr
	L sync.RWMutex
}

func NewConMapErrorUintptr() *ConMapErrorUintptr {
	return ToConMapErrorUintptr(nil)
}

func ToConMapErrorUintptr(data map[error]uintptr) *ConMapErrorUintptr {
	if data == nil {
		data = make(map[error]uintptr)
	}
	return &ConMapErrorUintptr{M: data}
}

func (cm *ConMapErrorUintptr) Get(k error) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapErrorUintptr) GetOK(k error) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapErrorUintptr) Set(k error, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapErrorUintptr) Delete(k error) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapErrorUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Bool struct {
	M map[float32]bool
	L sync.RWMutex
}

func NewConMapFloat32Bool() *ConMapFloat32Bool {
	return ToConMapFloat32Bool(nil)
}

func ToConMapFloat32Bool(data map[float32]bool) *ConMapFloat32Bool {
	if data == nil {
		data = make(map[float32]bool)
	}
	return &ConMapFloat32Bool{M: data}
}

func (cm *ConMapFloat32Bool) Get(k float32) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Bool) GetOK(k float32) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Bool) Set(k float32, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Bool) Delete(k float32) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Byte struct {
	M map[float32]byte
	L sync.RWMutex
}

func NewConMapFloat32Byte() *ConMapFloat32Byte {
	return ToConMapFloat32Byte(nil)
}

func ToConMapFloat32Byte(data map[float32]byte) *ConMapFloat32Byte {
	if data == nil {
		data = make(map[float32]byte)
	}
	return &ConMapFloat32Byte{M: data}
}

func (cm *ConMapFloat32Byte) Get(k float32) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Byte) GetOK(k float32) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Byte) Set(k float32, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Byte) Delete(k float32) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Complex128 struct {
	M map[float32]complex128
	L sync.RWMutex
}

func NewConMapFloat32Complex128() *ConMapFloat32Complex128 {
	return ToConMapFloat32Complex128(nil)
}

func ToConMapFloat32Complex128(data map[float32]complex128) *ConMapFloat32Complex128 {
	if data == nil {
		data = make(map[float32]complex128)
	}
	return &ConMapFloat32Complex128{M: data}
}

func (cm *ConMapFloat32Complex128) Get(k float32) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Complex128) GetOK(k float32) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Complex128) Set(k float32, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Complex128) Delete(k float32) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Complex64 struct {
	M map[float32]complex64
	L sync.RWMutex
}

func NewConMapFloat32Complex64() *ConMapFloat32Complex64 {
	return ToConMapFloat32Complex64(nil)
}

func ToConMapFloat32Complex64(data map[float32]complex64) *ConMapFloat32Complex64 {
	if data == nil {
		data = make(map[float32]complex64)
	}
	return &ConMapFloat32Complex64{M: data}
}

func (cm *ConMapFloat32Complex64) Get(k float32) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Complex64) GetOK(k float32) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Complex64) Set(k float32, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Complex64) Delete(k float32) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Error struct {
	M map[float32]error
	L sync.RWMutex
}

func NewConMapFloat32Error() *ConMapFloat32Error {
	return ToConMapFloat32Error(nil)
}

func ToConMapFloat32Error(data map[float32]error) *ConMapFloat32Error {
	if data == nil {
		data = make(map[float32]error)
	}
	return &ConMapFloat32Error{M: data}
}

func (cm *ConMapFloat32Error) Get(k float32) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Error) GetOK(k float32) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Error) Set(k float32, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Error) Delete(k float32) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Float32 struct {
	M map[float32]float32
	L sync.RWMutex
}

func NewConMapFloat32Float32() *ConMapFloat32Float32 {
	return ToConMapFloat32Float32(nil)
}

func ToConMapFloat32Float32(data map[float32]float32) *ConMapFloat32Float32 {
	if data == nil {
		data = make(map[float32]float32)
	}
	return &ConMapFloat32Float32{M: data}
}

func (cm *ConMapFloat32Float32) Get(k float32) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Float32) GetOK(k float32) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Float32) Set(k float32, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Float32) Delete(k float32) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Float64 struct {
	M map[float32]float64
	L sync.RWMutex
}

func NewConMapFloat32Float64() *ConMapFloat32Float64 {
	return ToConMapFloat32Float64(nil)
}

func ToConMapFloat32Float64(data map[float32]float64) *ConMapFloat32Float64 {
	if data == nil {
		data = make(map[float32]float64)
	}
	return &ConMapFloat32Float64{M: data}
}

func (cm *ConMapFloat32Float64) Get(k float32) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Float64) GetOK(k float32) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Float64) Set(k float32, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Float64) Delete(k float32) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Int struct {
	M map[float32]int
	L sync.RWMutex
}

func NewConMapFloat32Int() *ConMapFloat32Int {
	return ToConMapFloat32Int(nil)
}

func ToConMapFloat32Int(data map[float32]int) *ConMapFloat32Int {
	if data == nil {
		data = make(map[float32]int)
	}
	return &ConMapFloat32Int{M: data}
}

func (cm *ConMapFloat32Int) Get(k float32) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Int) GetOK(k float32) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Int) Set(k float32, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Int) Delete(k float32) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Int16 struct {
	M map[float32]int16
	L sync.RWMutex
}

func NewConMapFloat32Int16() *ConMapFloat32Int16 {
	return ToConMapFloat32Int16(nil)
}

func ToConMapFloat32Int16(data map[float32]int16) *ConMapFloat32Int16 {
	if data == nil {
		data = make(map[float32]int16)
	}
	return &ConMapFloat32Int16{M: data}
}

func (cm *ConMapFloat32Int16) Get(k float32) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Int16) GetOK(k float32) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Int16) Set(k float32, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Int16) Delete(k float32) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Int32 struct {
	M map[float32]int32
	L sync.RWMutex
}

func NewConMapFloat32Int32() *ConMapFloat32Int32 {
	return ToConMapFloat32Int32(nil)
}

func ToConMapFloat32Int32(data map[float32]int32) *ConMapFloat32Int32 {
	if data == nil {
		data = make(map[float32]int32)
	}
	return &ConMapFloat32Int32{M: data}
}

func (cm *ConMapFloat32Int32) Get(k float32) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Int32) GetOK(k float32) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Int32) Set(k float32, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Int32) Delete(k float32) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Int64 struct {
	M map[float32]int64
	L sync.RWMutex
}

func NewConMapFloat32Int64() *ConMapFloat32Int64 {
	return ToConMapFloat32Int64(nil)
}

func ToConMapFloat32Int64(data map[float32]int64) *ConMapFloat32Int64 {
	if data == nil {
		data = make(map[float32]int64)
	}
	return &ConMapFloat32Int64{M: data}
}

func (cm *ConMapFloat32Int64) Get(k float32) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Int64) GetOK(k float32) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Int64) Set(k float32, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Int64) Delete(k float32) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Int8 struct {
	M map[float32]int8
	L sync.RWMutex
}

func NewConMapFloat32Int8() *ConMapFloat32Int8 {
	return ToConMapFloat32Int8(nil)
}

func ToConMapFloat32Int8(data map[float32]int8) *ConMapFloat32Int8 {
	if data == nil {
		data = make(map[float32]int8)
	}
	return &ConMapFloat32Int8{M: data}
}

func (cm *ConMapFloat32Int8) Get(k float32) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Int8) GetOK(k float32) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Int8) Set(k float32, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Int8) Delete(k float32) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Rune struct {
	M map[float32]rune
	L sync.RWMutex
}

func NewConMapFloat32Rune() *ConMapFloat32Rune {
	return ToConMapFloat32Rune(nil)
}

func ToConMapFloat32Rune(data map[float32]rune) *ConMapFloat32Rune {
	if data == nil {
		data = make(map[float32]rune)
	}
	return &ConMapFloat32Rune{M: data}
}

func (cm *ConMapFloat32Rune) Get(k float32) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Rune) GetOK(k float32) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Rune) Set(k float32, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Rune) Delete(k float32) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32String struct {
	M map[float32]string
	L sync.RWMutex
}

func NewConMapFloat32String() *ConMapFloat32String {
	return ToConMapFloat32String(nil)
}

func ToConMapFloat32String(data map[float32]string) *ConMapFloat32String {
	if data == nil {
		data = make(map[float32]string)
	}
	return &ConMapFloat32String{M: data}
}

func (cm *ConMapFloat32String) Get(k float32) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32String) GetOK(k float32) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32String) Set(k float32, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32String) Delete(k float32) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Uint struct {
	M map[float32]uint
	L sync.RWMutex
}

func NewConMapFloat32Uint() *ConMapFloat32Uint {
	return ToConMapFloat32Uint(nil)
}

func ToConMapFloat32Uint(data map[float32]uint) *ConMapFloat32Uint {
	if data == nil {
		data = make(map[float32]uint)
	}
	return &ConMapFloat32Uint{M: data}
}

func (cm *ConMapFloat32Uint) Get(k float32) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Uint) GetOK(k float32) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Uint) Set(k float32, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Uint) Delete(k float32) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Uint16 struct {
	M map[float32]uint16
	L sync.RWMutex
}

func NewConMapFloat32Uint16() *ConMapFloat32Uint16 {
	return ToConMapFloat32Uint16(nil)
}

func ToConMapFloat32Uint16(data map[float32]uint16) *ConMapFloat32Uint16 {
	if data == nil {
		data = make(map[float32]uint16)
	}
	return &ConMapFloat32Uint16{M: data}
}

func (cm *ConMapFloat32Uint16) Get(k float32) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Uint16) GetOK(k float32) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Uint16) Set(k float32, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Uint16) Delete(k float32) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Uint32 struct {
	M map[float32]uint32
	L sync.RWMutex
}

func NewConMapFloat32Uint32() *ConMapFloat32Uint32 {
	return ToConMapFloat32Uint32(nil)
}

func ToConMapFloat32Uint32(data map[float32]uint32) *ConMapFloat32Uint32 {
	if data == nil {
		data = make(map[float32]uint32)
	}
	return &ConMapFloat32Uint32{M: data}
}

func (cm *ConMapFloat32Uint32) Get(k float32) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Uint32) GetOK(k float32) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Uint32) Set(k float32, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Uint32) Delete(k float32) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Uint64 struct {
	M map[float32]uint64
	L sync.RWMutex
}

func NewConMapFloat32Uint64() *ConMapFloat32Uint64 {
	return ToConMapFloat32Uint64(nil)
}

func ToConMapFloat32Uint64(data map[float32]uint64) *ConMapFloat32Uint64 {
	if data == nil {
		data = make(map[float32]uint64)
	}
	return &ConMapFloat32Uint64{M: data}
}

func (cm *ConMapFloat32Uint64) Get(k float32) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Uint64) GetOK(k float32) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Uint64) Set(k float32, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Uint64) Delete(k float32) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Uint8 struct {
	M map[float32]uint8
	L sync.RWMutex
}

func NewConMapFloat32Uint8() *ConMapFloat32Uint8 {
	return ToConMapFloat32Uint8(nil)
}

func ToConMapFloat32Uint8(data map[float32]uint8) *ConMapFloat32Uint8 {
	if data == nil {
		data = make(map[float32]uint8)
	}
	return &ConMapFloat32Uint8{M: data}
}

func (cm *ConMapFloat32Uint8) Get(k float32) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Uint8) GetOK(k float32) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Uint8) Set(k float32, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Uint8) Delete(k float32) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat32Uintptr struct {
	M map[float32]uintptr
	L sync.RWMutex
}

func NewConMapFloat32Uintptr() *ConMapFloat32Uintptr {
	return ToConMapFloat32Uintptr(nil)
}

func ToConMapFloat32Uintptr(data map[float32]uintptr) *ConMapFloat32Uintptr {
	if data == nil {
		data = make(map[float32]uintptr)
	}
	return &ConMapFloat32Uintptr{M: data}
}

func (cm *ConMapFloat32Uintptr) Get(k float32) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat32Uintptr) GetOK(k float32) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat32Uintptr) Set(k float32, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat32Uintptr) Delete(k float32) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat32Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Bool struct {
	M map[float64]bool
	L sync.RWMutex
}

func NewConMapFloat64Bool() *ConMapFloat64Bool {
	return ToConMapFloat64Bool(nil)
}

func ToConMapFloat64Bool(data map[float64]bool) *ConMapFloat64Bool {
	if data == nil {
		data = make(map[float64]bool)
	}
	return &ConMapFloat64Bool{M: data}
}

func (cm *ConMapFloat64Bool) Get(k float64) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Bool) GetOK(k float64) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Bool) Set(k float64, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Bool) Delete(k float64) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Byte struct {
	M map[float64]byte
	L sync.RWMutex
}

func NewConMapFloat64Byte() *ConMapFloat64Byte {
	return ToConMapFloat64Byte(nil)
}

func ToConMapFloat64Byte(data map[float64]byte) *ConMapFloat64Byte {
	if data == nil {
		data = make(map[float64]byte)
	}
	return &ConMapFloat64Byte{M: data}
}

func (cm *ConMapFloat64Byte) Get(k float64) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Byte) GetOK(k float64) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Byte) Set(k float64, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Byte) Delete(k float64) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Complex128 struct {
	M map[float64]complex128
	L sync.RWMutex
}

func NewConMapFloat64Complex128() *ConMapFloat64Complex128 {
	return ToConMapFloat64Complex128(nil)
}

func ToConMapFloat64Complex128(data map[float64]complex128) *ConMapFloat64Complex128 {
	if data == nil {
		data = make(map[float64]complex128)
	}
	return &ConMapFloat64Complex128{M: data}
}

func (cm *ConMapFloat64Complex128) Get(k float64) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Complex128) GetOK(k float64) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Complex128) Set(k float64, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Complex128) Delete(k float64) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Complex64 struct {
	M map[float64]complex64
	L sync.RWMutex
}

func NewConMapFloat64Complex64() *ConMapFloat64Complex64 {
	return ToConMapFloat64Complex64(nil)
}

func ToConMapFloat64Complex64(data map[float64]complex64) *ConMapFloat64Complex64 {
	if data == nil {
		data = make(map[float64]complex64)
	}
	return &ConMapFloat64Complex64{M: data}
}

func (cm *ConMapFloat64Complex64) Get(k float64) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Complex64) GetOK(k float64) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Complex64) Set(k float64, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Complex64) Delete(k float64) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Error struct {
	M map[float64]error
	L sync.RWMutex
}

func NewConMapFloat64Error() *ConMapFloat64Error {
	return ToConMapFloat64Error(nil)
}

func ToConMapFloat64Error(data map[float64]error) *ConMapFloat64Error {
	if data == nil {
		data = make(map[float64]error)
	}
	return &ConMapFloat64Error{M: data}
}

func (cm *ConMapFloat64Error) Get(k float64) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Error) GetOK(k float64) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Error) Set(k float64, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Error) Delete(k float64) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Float32 struct {
	M map[float64]float32
	L sync.RWMutex
}

func NewConMapFloat64Float32() *ConMapFloat64Float32 {
	return ToConMapFloat64Float32(nil)
}

func ToConMapFloat64Float32(data map[float64]float32) *ConMapFloat64Float32 {
	if data == nil {
		data = make(map[float64]float32)
	}
	return &ConMapFloat64Float32{M: data}
}

func (cm *ConMapFloat64Float32) Get(k float64) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Float32) GetOK(k float64) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Float32) Set(k float64, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Float32) Delete(k float64) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Float64 struct {
	M map[float64]float64
	L sync.RWMutex
}

func NewConMapFloat64Float64() *ConMapFloat64Float64 {
	return ToConMapFloat64Float64(nil)
}

func ToConMapFloat64Float64(data map[float64]float64) *ConMapFloat64Float64 {
	if data == nil {
		data = make(map[float64]float64)
	}
	return &ConMapFloat64Float64{M: data}
}

func (cm *ConMapFloat64Float64) Get(k float64) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Float64) GetOK(k float64) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Float64) Set(k float64, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Float64) Delete(k float64) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Int struct {
	M map[float64]int
	L sync.RWMutex
}

func NewConMapFloat64Int() *ConMapFloat64Int {
	return ToConMapFloat64Int(nil)
}

func ToConMapFloat64Int(data map[float64]int) *ConMapFloat64Int {
	if data == nil {
		data = make(map[float64]int)
	}
	return &ConMapFloat64Int{M: data}
}

func (cm *ConMapFloat64Int) Get(k float64) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Int) GetOK(k float64) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Int) Set(k float64, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Int) Delete(k float64) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Int16 struct {
	M map[float64]int16
	L sync.RWMutex
}

func NewConMapFloat64Int16() *ConMapFloat64Int16 {
	return ToConMapFloat64Int16(nil)
}

func ToConMapFloat64Int16(data map[float64]int16) *ConMapFloat64Int16 {
	if data == nil {
		data = make(map[float64]int16)
	}
	return &ConMapFloat64Int16{M: data}
}

func (cm *ConMapFloat64Int16) Get(k float64) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Int16) GetOK(k float64) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Int16) Set(k float64, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Int16) Delete(k float64) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Int32 struct {
	M map[float64]int32
	L sync.RWMutex
}

func NewConMapFloat64Int32() *ConMapFloat64Int32 {
	return ToConMapFloat64Int32(nil)
}

func ToConMapFloat64Int32(data map[float64]int32) *ConMapFloat64Int32 {
	if data == nil {
		data = make(map[float64]int32)
	}
	return &ConMapFloat64Int32{M: data}
}

func (cm *ConMapFloat64Int32) Get(k float64) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Int32) GetOK(k float64) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Int32) Set(k float64, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Int32) Delete(k float64) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Int64 struct {
	M map[float64]int64
	L sync.RWMutex
}

func NewConMapFloat64Int64() *ConMapFloat64Int64 {
	return ToConMapFloat64Int64(nil)
}

func ToConMapFloat64Int64(data map[float64]int64) *ConMapFloat64Int64 {
	if data == nil {
		data = make(map[float64]int64)
	}
	return &ConMapFloat64Int64{M: data}
}

func (cm *ConMapFloat64Int64) Get(k float64) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Int64) GetOK(k float64) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Int64) Set(k float64, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Int64) Delete(k float64) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Int8 struct {
	M map[float64]int8
	L sync.RWMutex
}

func NewConMapFloat64Int8() *ConMapFloat64Int8 {
	return ToConMapFloat64Int8(nil)
}

func ToConMapFloat64Int8(data map[float64]int8) *ConMapFloat64Int8 {
	if data == nil {
		data = make(map[float64]int8)
	}
	return &ConMapFloat64Int8{M: data}
}

func (cm *ConMapFloat64Int8) Get(k float64) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Int8) GetOK(k float64) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Int8) Set(k float64, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Int8) Delete(k float64) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Rune struct {
	M map[float64]rune
	L sync.RWMutex
}

func NewConMapFloat64Rune() *ConMapFloat64Rune {
	return ToConMapFloat64Rune(nil)
}

func ToConMapFloat64Rune(data map[float64]rune) *ConMapFloat64Rune {
	if data == nil {
		data = make(map[float64]rune)
	}
	return &ConMapFloat64Rune{M: data}
}

func (cm *ConMapFloat64Rune) Get(k float64) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Rune) GetOK(k float64) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Rune) Set(k float64, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Rune) Delete(k float64) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64String struct {
	M map[float64]string
	L sync.RWMutex
}

func NewConMapFloat64String() *ConMapFloat64String {
	return ToConMapFloat64String(nil)
}

func ToConMapFloat64String(data map[float64]string) *ConMapFloat64String {
	if data == nil {
		data = make(map[float64]string)
	}
	return &ConMapFloat64String{M: data}
}

func (cm *ConMapFloat64String) Get(k float64) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64String) GetOK(k float64) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64String) Set(k float64, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64String) Delete(k float64) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Uint struct {
	M map[float64]uint
	L sync.RWMutex
}

func NewConMapFloat64Uint() *ConMapFloat64Uint {
	return ToConMapFloat64Uint(nil)
}

func ToConMapFloat64Uint(data map[float64]uint) *ConMapFloat64Uint {
	if data == nil {
		data = make(map[float64]uint)
	}
	return &ConMapFloat64Uint{M: data}
}

func (cm *ConMapFloat64Uint) Get(k float64) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Uint) GetOK(k float64) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Uint) Set(k float64, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Uint) Delete(k float64) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Uint16 struct {
	M map[float64]uint16
	L sync.RWMutex
}

func NewConMapFloat64Uint16() *ConMapFloat64Uint16 {
	return ToConMapFloat64Uint16(nil)
}

func ToConMapFloat64Uint16(data map[float64]uint16) *ConMapFloat64Uint16 {
	if data == nil {
		data = make(map[float64]uint16)
	}
	return &ConMapFloat64Uint16{M: data}
}

func (cm *ConMapFloat64Uint16) Get(k float64) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Uint16) GetOK(k float64) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Uint16) Set(k float64, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Uint16) Delete(k float64) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Uint32 struct {
	M map[float64]uint32
	L sync.RWMutex
}

func NewConMapFloat64Uint32() *ConMapFloat64Uint32 {
	return ToConMapFloat64Uint32(nil)
}

func ToConMapFloat64Uint32(data map[float64]uint32) *ConMapFloat64Uint32 {
	if data == nil {
		data = make(map[float64]uint32)
	}
	return &ConMapFloat64Uint32{M: data}
}

func (cm *ConMapFloat64Uint32) Get(k float64) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Uint32) GetOK(k float64) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Uint32) Set(k float64, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Uint32) Delete(k float64) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Uint64 struct {
	M map[float64]uint64
	L sync.RWMutex
}

func NewConMapFloat64Uint64() *ConMapFloat64Uint64 {
	return ToConMapFloat64Uint64(nil)
}

func ToConMapFloat64Uint64(data map[float64]uint64) *ConMapFloat64Uint64 {
	if data == nil {
		data = make(map[float64]uint64)
	}
	return &ConMapFloat64Uint64{M: data}
}

func (cm *ConMapFloat64Uint64) Get(k float64) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Uint64) GetOK(k float64) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Uint64) Set(k float64, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Uint64) Delete(k float64) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Uint8 struct {
	M map[float64]uint8
	L sync.RWMutex
}

func NewConMapFloat64Uint8() *ConMapFloat64Uint8 {
	return ToConMapFloat64Uint8(nil)
}

func ToConMapFloat64Uint8(data map[float64]uint8) *ConMapFloat64Uint8 {
	if data == nil {
		data = make(map[float64]uint8)
	}
	return &ConMapFloat64Uint8{M: data}
}

func (cm *ConMapFloat64Uint8) Get(k float64) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Uint8) GetOK(k float64) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Uint8) Set(k float64, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Uint8) Delete(k float64) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapFloat64Uintptr struct {
	M map[float64]uintptr
	L sync.RWMutex
}

func NewConMapFloat64Uintptr() *ConMapFloat64Uintptr {
	return ToConMapFloat64Uintptr(nil)
}

func ToConMapFloat64Uintptr(data map[float64]uintptr) *ConMapFloat64Uintptr {
	if data == nil {
		data = make(map[float64]uintptr)
	}
	return &ConMapFloat64Uintptr{M: data}
}

func (cm *ConMapFloat64Uintptr) Get(k float64) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapFloat64Uintptr) GetOK(k float64) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapFloat64Uintptr) Set(k float64, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapFloat64Uintptr) Delete(k float64) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapFloat64Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntBool struct {
	M map[int]bool
	L sync.RWMutex
}

func NewConMapIntBool() *ConMapIntBool {
	return ToConMapIntBool(nil)
}

func ToConMapIntBool(data map[int]bool) *ConMapIntBool {
	if data == nil {
		data = make(map[int]bool)
	}
	return &ConMapIntBool{M: data}
}

func (cm *ConMapIntBool) Get(k int) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntBool) GetOK(k int) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntBool) Set(k int, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntBool) Delete(k int) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntByte struct {
	M map[int]byte
	L sync.RWMutex
}

func NewConMapIntByte() *ConMapIntByte {
	return ToConMapIntByte(nil)
}

func ToConMapIntByte(data map[int]byte) *ConMapIntByte {
	if data == nil {
		data = make(map[int]byte)
	}
	return &ConMapIntByte{M: data}
}

func (cm *ConMapIntByte) Get(k int) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntByte) GetOK(k int) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntByte) Set(k int, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntByte) Delete(k int) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntComplex128 struct {
	M map[int]complex128
	L sync.RWMutex
}

func NewConMapIntComplex128() *ConMapIntComplex128 {
	return ToConMapIntComplex128(nil)
}

func ToConMapIntComplex128(data map[int]complex128) *ConMapIntComplex128 {
	if data == nil {
		data = make(map[int]complex128)
	}
	return &ConMapIntComplex128{M: data}
}

func (cm *ConMapIntComplex128) Get(k int) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntComplex128) GetOK(k int) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntComplex128) Set(k int, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntComplex128) Delete(k int) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntComplex64 struct {
	M map[int]complex64
	L sync.RWMutex
}

func NewConMapIntComplex64() *ConMapIntComplex64 {
	return ToConMapIntComplex64(nil)
}

func ToConMapIntComplex64(data map[int]complex64) *ConMapIntComplex64 {
	if data == nil {
		data = make(map[int]complex64)
	}
	return &ConMapIntComplex64{M: data}
}

func (cm *ConMapIntComplex64) Get(k int) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntComplex64) GetOK(k int) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntComplex64) Set(k int, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntComplex64) Delete(k int) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntError struct {
	M map[int]error
	L sync.RWMutex
}

func NewConMapIntError() *ConMapIntError {
	return ToConMapIntError(nil)
}

func ToConMapIntError(data map[int]error) *ConMapIntError {
	if data == nil {
		data = make(map[int]error)
	}
	return &ConMapIntError{M: data}
}

func (cm *ConMapIntError) Get(k int) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntError) GetOK(k int) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntError) Set(k int, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntError) Delete(k int) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntFloat32 struct {
	M map[int]float32
	L sync.RWMutex
}

func NewConMapIntFloat32() *ConMapIntFloat32 {
	return ToConMapIntFloat32(nil)
}

func ToConMapIntFloat32(data map[int]float32) *ConMapIntFloat32 {
	if data == nil {
		data = make(map[int]float32)
	}
	return &ConMapIntFloat32{M: data}
}

func (cm *ConMapIntFloat32) Get(k int) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntFloat32) GetOK(k int) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntFloat32) Set(k int, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntFloat32) Delete(k int) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntFloat64 struct {
	M map[int]float64
	L sync.RWMutex
}

func NewConMapIntFloat64() *ConMapIntFloat64 {
	return ToConMapIntFloat64(nil)
}

func ToConMapIntFloat64(data map[int]float64) *ConMapIntFloat64 {
	if data == nil {
		data = make(map[int]float64)
	}
	return &ConMapIntFloat64{M: data}
}

func (cm *ConMapIntFloat64) Get(k int) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntFloat64) GetOK(k int) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntFloat64) Set(k int, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntFloat64) Delete(k int) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntInt struct {
	M map[int]int
	L sync.RWMutex
}

func NewConMapIntInt() *ConMapIntInt {
	return ToConMapIntInt(nil)
}

func ToConMapIntInt(data map[int]int) *ConMapIntInt {
	if data == nil {
		data = make(map[int]int)
	}
	return &ConMapIntInt{M: data}
}

func (cm *ConMapIntInt) Get(k int) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntInt) GetOK(k int) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntInt) Set(k int, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntInt) Delete(k int) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntInt16 struct {
	M map[int]int16
	L sync.RWMutex
}

func NewConMapIntInt16() *ConMapIntInt16 {
	return ToConMapIntInt16(nil)
}

func ToConMapIntInt16(data map[int]int16) *ConMapIntInt16 {
	if data == nil {
		data = make(map[int]int16)
	}
	return &ConMapIntInt16{M: data}
}

func (cm *ConMapIntInt16) Get(k int) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntInt16) GetOK(k int) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntInt16) Set(k int, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntInt16) Delete(k int) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntInt32 struct {
	M map[int]int32
	L sync.RWMutex
}

func NewConMapIntInt32() *ConMapIntInt32 {
	return ToConMapIntInt32(nil)
}

func ToConMapIntInt32(data map[int]int32) *ConMapIntInt32 {
	if data == nil {
		data = make(map[int]int32)
	}
	return &ConMapIntInt32{M: data}
}

func (cm *ConMapIntInt32) Get(k int) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntInt32) GetOK(k int) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntInt32) Set(k int, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntInt32) Delete(k int) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntInt64 struct {
	M map[int]int64
	L sync.RWMutex
}

func NewConMapIntInt64() *ConMapIntInt64 {
	return ToConMapIntInt64(nil)
}

func ToConMapIntInt64(data map[int]int64) *ConMapIntInt64 {
	if data == nil {
		data = make(map[int]int64)
	}
	return &ConMapIntInt64{M: data}
}

func (cm *ConMapIntInt64) Get(k int) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntInt64) GetOK(k int) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntInt64) Set(k int, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntInt64) Delete(k int) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntInt8 struct {
	M map[int]int8
	L sync.RWMutex
}

func NewConMapIntInt8() *ConMapIntInt8 {
	return ToConMapIntInt8(nil)
}

func ToConMapIntInt8(data map[int]int8) *ConMapIntInt8 {
	if data == nil {
		data = make(map[int]int8)
	}
	return &ConMapIntInt8{M: data}
}

func (cm *ConMapIntInt8) Get(k int) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntInt8) GetOK(k int) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntInt8) Set(k int, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntInt8) Delete(k int) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntRune struct {
	M map[int]rune
	L sync.RWMutex
}

func NewConMapIntRune() *ConMapIntRune {
	return ToConMapIntRune(nil)
}

func ToConMapIntRune(data map[int]rune) *ConMapIntRune {
	if data == nil {
		data = make(map[int]rune)
	}
	return &ConMapIntRune{M: data}
}

func (cm *ConMapIntRune) Get(k int) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntRune) GetOK(k int) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntRune) Set(k int, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntRune) Delete(k int) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntString struct {
	M map[int]string
	L sync.RWMutex
}

func NewConMapIntString() *ConMapIntString {
	return ToConMapIntString(nil)
}

func ToConMapIntString(data map[int]string) *ConMapIntString {
	if data == nil {
		data = make(map[int]string)
	}
	return &ConMapIntString{M: data}
}

func (cm *ConMapIntString) Get(k int) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntString) GetOK(k int) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntString) Set(k int, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntString) Delete(k int) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntUint struct {
	M map[int]uint
	L sync.RWMutex
}

func NewConMapIntUint() *ConMapIntUint {
	return ToConMapIntUint(nil)
}

func ToConMapIntUint(data map[int]uint) *ConMapIntUint {
	if data == nil {
		data = make(map[int]uint)
	}
	return &ConMapIntUint{M: data}
}

func (cm *ConMapIntUint) Get(k int) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntUint) GetOK(k int) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntUint) Set(k int, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntUint) Delete(k int) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntUint16 struct {
	M map[int]uint16
	L sync.RWMutex
}

func NewConMapIntUint16() *ConMapIntUint16 {
	return ToConMapIntUint16(nil)
}

func ToConMapIntUint16(data map[int]uint16) *ConMapIntUint16 {
	if data == nil {
		data = make(map[int]uint16)
	}
	return &ConMapIntUint16{M: data}
}

func (cm *ConMapIntUint16) Get(k int) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntUint16) GetOK(k int) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntUint16) Set(k int, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntUint16) Delete(k int) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntUint32 struct {
	M map[int]uint32
	L sync.RWMutex
}

func NewConMapIntUint32() *ConMapIntUint32 {
	return ToConMapIntUint32(nil)
}

func ToConMapIntUint32(data map[int]uint32) *ConMapIntUint32 {
	if data == nil {
		data = make(map[int]uint32)
	}
	return &ConMapIntUint32{M: data}
}

func (cm *ConMapIntUint32) Get(k int) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntUint32) GetOK(k int) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntUint32) Set(k int, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntUint32) Delete(k int) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntUint64 struct {
	M map[int]uint64
	L sync.RWMutex
}

func NewConMapIntUint64() *ConMapIntUint64 {
	return ToConMapIntUint64(nil)
}

func ToConMapIntUint64(data map[int]uint64) *ConMapIntUint64 {
	if data == nil {
		data = make(map[int]uint64)
	}
	return &ConMapIntUint64{M: data}
}

func (cm *ConMapIntUint64) Get(k int) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntUint64) GetOK(k int) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntUint64) Set(k int, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntUint64) Delete(k int) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntUint8 struct {
	M map[int]uint8
	L sync.RWMutex
}

func NewConMapIntUint8() *ConMapIntUint8 {
	return ToConMapIntUint8(nil)
}

func ToConMapIntUint8(data map[int]uint8) *ConMapIntUint8 {
	if data == nil {
		data = make(map[int]uint8)
	}
	return &ConMapIntUint8{M: data}
}

func (cm *ConMapIntUint8) Get(k int) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntUint8) GetOK(k int) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntUint8) Set(k int, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntUint8) Delete(k int) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapIntUintptr struct {
	M map[int]uintptr
	L sync.RWMutex
}

func NewConMapIntUintptr() *ConMapIntUintptr {
	return ToConMapIntUintptr(nil)
}

func ToConMapIntUintptr(data map[int]uintptr) *ConMapIntUintptr {
	if data == nil {
		data = make(map[int]uintptr)
	}
	return &ConMapIntUintptr{M: data}
}

func (cm *ConMapIntUintptr) Get(k int) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapIntUintptr) GetOK(k int) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapIntUintptr) Set(k int, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapIntUintptr) Delete(k int) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapIntUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Bool struct {
	M map[int16]bool
	L sync.RWMutex
}

func NewConMapInt16Bool() *ConMapInt16Bool {
	return ToConMapInt16Bool(nil)
}

func ToConMapInt16Bool(data map[int16]bool) *ConMapInt16Bool {
	if data == nil {
		data = make(map[int16]bool)
	}
	return &ConMapInt16Bool{M: data}
}

func (cm *ConMapInt16Bool) Get(k int16) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Bool) GetOK(k int16) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Bool) Set(k int16, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Bool) Delete(k int16) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Byte struct {
	M map[int16]byte
	L sync.RWMutex
}

func NewConMapInt16Byte() *ConMapInt16Byte {
	return ToConMapInt16Byte(nil)
}

func ToConMapInt16Byte(data map[int16]byte) *ConMapInt16Byte {
	if data == nil {
		data = make(map[int16]byte)
	}
	return &ConMapInt16Byte{M: data}
}

func (cm *ConMapInt16Byte) Get(k int16) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Byte) GetOK(k int16) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Byte) Set(k int16, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Byte) Delete(k int16) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Complex128 struct {
	M map[int16]complex128
	L sync.RWMutex
}

func NewConMapInt16Complex128() *ConMapInt16Complex128 {
	return ToConMapInt16Complex128(nil)
}

func ToConMapInt16Complex128(data map[int16]complex128) *ConMapInt16Complex128 {
	if data == nil {
		data = make(map[int16]complex128)
	}
	return &ConMapInt16Complex128{M: data}
}

func (cm *ConMapInt16Complex128) Get(k int16) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Complex128) GetOK(k int16) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Complex128) Set(k int16, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Complex128) Delete(k int16) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Complex64 struct {
	M map[int16]complex64
	L sync.RWMutex
}

func NewConMapInt16Complex64() *ConMapInt16Complex64 {
	return ToConMapInt16Complex64(nil)
}

func ToConMapInt16Complex64(data map[int16]complex64) *ConMapInt16Complex64 {
	if data == nil {
		data = make(map[int16]complex64)
	}
	return &ConMapInt16Complex64{M: data}
}

func (cm *ConMapInt16Complex64) Get(k int16) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Complex64) GetOK(k int16) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Complex64) Set(k int16, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Complex64) Delete(k int16) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Error struct {
	M map[int16]error
	L sync.RWMutex
}

func NewConMapInt16Error() *ConMapInt16Error {
	return ToConMapInt16Error(nil)
}

func ToConMapInt16Error(data map[int16]error) *ConMapInt16Error {
	if data == nil {
		data = make(map[int16]error)
	}
	return &ConMapInt16Error{M: data}
}

func (cm *ConMapInt16Error) Get(k int16) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Error) GetOK(k int16) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Error) Set(k int16, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Error) Delete(k int16) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Float32 struct {
	M map[int16]float32
	L sync.RWMutex
}

func NewConMapInt16Float32() *ConMapInt16Float32 {
	return ToConMapInt16Float32(nil)
}

func ToConMapInt16Float32(data map[int16]float32) *ConMapInt16Float32 {
	if data == nil {
		data = make(map[int16]float32)
	}
	return &ConMapInt16Float32{M: data}
}

func (cm *ConMapInt16Float32) Get(k int16) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Float32) GetOK(k int16) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Float32) Set(k int16, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Float32) Delete(k int16) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Float64 struct {
	M map[int16]float64
	L sync.RWMutex
}

func NewConMapInt16Float64() *ConMapInt16Float64 {
	return ToConMapInt16Float64(nil)
}

func ToConMapInt16Float64(data map[int16]float64) *ConMapInt16Float64 {
	if data == nil {
		data = make(map[int16]float64)
	}
	return &ConMapInt16Float64{M: data}
}

func (cm *ConMapInt16Float64) Get(k int16) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Float64) GetOK(k int16) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Float64) Set(k int16, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Float64) Delete(k int16) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Int struct {
	M map[int16]int
	L sync.RWMutex
}

func NewConMapInt16Int() *ConMapInt16Int {
	return ToConMapInt16Int(nil)
}

func ToConMapInt16Int(data map[int16]int) *ConMapInt16Int {
	if data == nil {
		data = make(map[int16]int)
	}
	return &ConMapInt16Int{M: data}
}

func (cm *ConMapInt16Int) Get(k int16) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Int) GetOK(k int16) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Int) Set(k int16, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Int) Delete(k int16) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Int16 struct {
	M map[int16]int16
	L sync.RWMutex
}

func NewConMapInt16Int16() *ConMapInt16Int16 {
	return ToConMapInt16Int16(nil)
}

func ToConMapInt16Int16(data map[int16]int16) *ConMapInt16Int16 {
	if data == nil {
		data = make(map[int16]int16)
	}
	return &ConMapInt16Int16{M: data}
}

func (cm *ConMapInt16Int16) Get(k int16) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Int16) GetOK(k int16) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Int16) Set(k int16, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Int16) Delete(k int16) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Int32 struct {
	M map[int16]int32
	L sync.RWMutex
}

func NewConMapInt16Int32() *ConMapInt16Int32 {
	return ToConMapInt16Int32(nil)
}

func ToConMapInt16Int32(data map[int16]int32) *ConMapInt16Int32 {
	if data == nil {
		data = make(map[int16]int32)
	}
	return &ConMapInt16Int32{M: data}
}

func (cm *ConMapInt16Int32) Get(k int16) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Int32) GetOK(k int16) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Int32) Set(k int16, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Int32) Delete(k int16) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Int64 struct {
	M map[int16]int64
	L sync.RWMutex
}

func NewConMapInt16Int64() *ConMapInt16Int64 {
	return ToConMapInt16Int64(nil)
}

func ToConMapInt16Int64(data map[int16]int64) *ConMapInt16Int64 {
	if data == nil {
		data = make(map[int16]int64)
	}
	return &ConMapInt16Int64{M: data}
}

func (cm *ConMapInt16Int64) Get(k int16) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Int64) GetOK(k int16) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Int64) Set(k int16, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Int64) Delete(k int16) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Int8 struct {
	M map[int16]int8
	L sync.RWMutex
}

func NewConMapInt16Int8() *ConMapInt16Int8 {
	return ToConMapInt16Int8(nil)
}

func ToConMapInt16Int8(data map[int16]int8) *ConMapInt16Int8 {
	if data == nil {
		data = make(map[int16]int8)
	}
	return &ConMapInt16Int8{M: data}
}

func (cm *ConMapInt16Int8) Get(k int16) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Int8) GetOK(k int16) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Int8) Set(k int16, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Int8) Delete(k int16) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Rune struct {
	M map[int16]rune
	L sync.RWMutex
}

func NewConMapInt16Rune() *ConMapInt16Rune {
	return ToConMapInt16Rune(nil)
}

func ToConMapInt16Rune(data map[int16]rune) *ConMapInt16Rune {
	if data == nil {
		data = make(map[int16]rune)
	}
	return &ConMapInt16Rune{M: data}
}

func (cm *ConMapInt16Rune) Get(k int16) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Rune) GetOK(k int16) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Rune) Set(k int16, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Rune) Delete(k int16) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16String struct {
	M map[int16]string
	L sync.RWMutex
}

func NewConMapInt16String() *ConMapInt16String {
	return ToConMapInt16String(nil)
}

func ToConMapInt16String(data map[int16]string) *ConMapInt16String {
	if data == nil {
		data = make(map[int16]string)
	}
	return &ConMapInt16String{M: data}
}

func (cm *ConMapInt16String) Get(k int16) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16String) GetOK(k int16) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16String) Set(k int16, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16String) Delete(k int16) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Uint struct {
	M map[int16]uint
	L sync.RWMutex
}

func NewConMapInt16Uint() *ConMapInt16Uint {
	return ToConMapInt16Uint(nil)
}

func ToConMapInt16Uint(data map[int16]uint) *ConMapInt16Uint {
	if data == nil {
		data = make(map[int16]uint)
	}
	return &ConMapInt16Uint{M: data}
}

func (cm *ConMapInt16Uint) Get(k int16) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Uint) GetOK(k int16) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Uint) Set(k int16, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Uint) Delete(k int16) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Uint16 struct {
	M map[int16]uint16
	L sync.RWMutex
}

func NewConMapInt16Uint16() *ConMapInt16Uint16 {
	return ToConMapInt16Uint16(nil)
}

func ToConMapInt16Uint16(data map[int16]uint16) *ConMapInt16Uint16 {
	if data == nil {
		data = make(map[int16]uint16)
	}
	return &ConMapInt16Uint16{M: data}
}

func (cm *ConMapInt16Uint16) Get(k int16) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Uint16) GetOK(k int16) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Uint16) Set(k int16, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Uint16) Delete(k int16) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Uint32 struct {
	M map[int16]uint32
	L sync.RWMutex
}

func NewConMapInt16Uint32() *ConMapInt16Uint32 {
	return ToConMapInt16Uint32(nil)
}

func ToConMapInt16Uint32(data map[int16]uint32) *ConMapInt16Uint32 {
	if data == nil {
		data = make(map[int16]uint32)
	}
	return &ConMapInt16Uint32{M: data}
}

func (cm *ConMapInt16Uint32) Get(k int16) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Uint32) GetOK(k int16) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Uint32) Set(k int16, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Uint32) Delete(k int16) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Uint64 struct {
	M map[int16]uint64
	L sync.RWMutex
}

func NewConMapInt16Uint64() *ConMapInt16Uint64 {
	return ToConMapInt16Uint64(nil)
}

func ToConMapInt16Uint64(data map[int16]uint64) *ConMapInt16Uint64 {
	if data == nil {
		data = make(map[int16]uint64)
	}
	return &ConMapInt16Uint64{M: data}
}

func (cm *ConMapInt16Uint64) Get(k int16) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Uint64) GetOK(k int16) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Uint64) Set(k int16, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Uint64) Delete(k int16) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Uint8 struct {
	M map[int16]uint8
	L sync.RWMutex
}

func NewConMapInt16Uint8() *ConMapInt16Uint8 {
	return ToConMapInt16Uint8(nil)
}

func ToConMapInt16Uint8(data map[int16]uint8) *ConMapInt16Uint8 {
	if data == nil {
		data = make(map[int16]uint8)
	}
	return &ConMapInt16Uint8{M: data}
}

func (cm *ConMapInt16Uint8) Get(k int16) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Uint8) GetOK(k int16) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Uint8) Set(k int16, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Uint8) Delete(k int16) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt16Uintptr struct {
	M map[int16]uintptr
	L sync.RWMutex
}

func NewConMapInt16Uintptr() *ConMapInt16Uintptr {
	return ToConMapInt16Uintptr(nil)
}

func ToConMapInt16Uintptr(data map[int16]uintptr) *ConMapInt16Uintptr {
	if data == nil {
		data = make(map[int16]uintptr)
	}
	return &ConMapInt16Uintptr{M: data}
}

func (cm *ConMapInt16Uintptr) Get(k int16) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt16Uintptr) GetOK(k int16) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt16Uintptr) Set(k int16, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt16Uintptr) Delete(k int16) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt16Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Bool struct {
	M map[int32]bool
	L sync.RWMutex
}

func NewConMapInt32Bool() *ConMapInt32Bool {
	return ToConMapInt32Bool(nil)
}

func ToConMapInt32Bool(data map[int32]bool) *ConMapInt32Bool {
	if data == nil {
		data = make(map[int32]bool)
	}
	return &ConMapInt32Bool{M: data}
}

func (cm *ConMapInt32Bool) Get(k int32) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Bool) GetOK(k int32) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Bool) Set(k int32, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Bool) Delete(k int32) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Byte struct {
	M map[int32]byte
	L sync.RWMutex
}

func NewConMapInt32Byte() *ConMapInt32Byte {
	return ToConMapInt32Byte(nil)
}

func ToConMapInt32Byte(data map[int32]byte) *ConMapInt32Byte {
	if data == nil {
		data = make(map[int32]byte)
	}
	return &ConMapInt32Byte{M: data}
}

func (cm *ConMapInt32Byte) Get(k int32) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Byte) GetOK(k int32) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Byte) Set(k int32, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Byte) Delete(k int32) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Complex128 struct {
	M map[int32]complex128
	L sync.RWMutex
}

func NewConMapInt32Complex128() *ConMapInt32Complex128 {
	return ToConMapInt32Complex128(nil)
}

func ToConMapInt32Complex128(data map[int32]complex128) *ConMapInt32Complex128 {
	if data == nil {
		data = make(map[int32]complex128)
	}
	return &ConMapInt32Complex128{M: data}
}

func (cm *ConMapInt32Complex128) Get(k int32) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Complex128) GetOK(k int32) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Complex128) Set(k int32, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Complex128) Delete(k int32) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Complex64 struct {
	M map[int32]complex64
	L sync.RWMutex
}

func NewConMapInt32Complex64() *ConMapInt32Complex64 {
	return ToConMapInt32Complex64(nil)
}

func ToConMapInt32Complex64(data map[int32]complex64) *ConMapInt32Complex64 {
	if data == nil {
		data = make(map[int32]complex64)
	}
	return &ConMapInt32Complex64{M: data}
}

func (cm *ConMapInt32Complex64) Get(k int32) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Complex64) GetOK(k int32) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Complex64) Set(k int32, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Complex64) Delete(k int32) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Error struct {
	M map[int32]error
	L sync.RWMutex
}

func NewConMapInt32Error() *ConMapInt32Error {
	return ToConMapInt32Error(nil)
}

func ToConMapInt32Error(data map[int32]error) *ConMapInt32Error {
	if data == nil {
		data = make(map[int32]error)
	}
	return &ConMapInt32Error{M: data}
}

func (cm *ConMapInt32Error) Get(k int32) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Error) GetOK(k int32) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Error) Set(k int32, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Error) Delete(k int32) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Float32 struct {
	M map[int32]float32
	L sync.RWMutex
}

func NewConMapInt32Float32() *ConMapInt32Float32 {
	return ToConMapInt32Float32(nil)
}

func ToConMapInt32Float32(data map[int32]float32) *ConMapInt32Float32 {
	if data == nil {
		data = make(map[int32]float32)
	}
	return &ConMapInt32Float32{M: data}
}

func (cm *ConMapInt32Float32) Get(k int32) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Float32) GetOK(k int32) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Float32) Set(k int32, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Float32) Delete(k int32) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Float64 struct {
	M map[int32]float64
	L sync.RWMutex
}

func NewConMapInt32Float64() *ConMapInt32Float64 {
	return ToConMapInt32Float64(nil)
}

func ToConMapInt32Float64(data map[int32]float64) *ConMapInt32Float64 {
	if data == nil {
		data = make(map[int32]float64)
	}
	return &ConMapInt32Float64{M: data}
}

func (cm *ConMapInt32Float64) Get(k int32) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Float64) GetOK(k int32) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Float64) Set(k int32, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Float64) Delete(k int32) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Int struct {
	M map[int32]int
	L sync.RWMutex
}

func NewConMapInt32Int() *ConMapInt32Int {
	return ToConMapInt32Int(nil)
}

func ToConMapInt32Int(data map[int32]int) *ConMapInt32Int {
	if data == nil {
		data = make(map[int32]int)
	}
	return &ConMapInt32Int{M: data}
}

func (cm *ConMapInt32Int) Get(k int32) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Int) GetOK(k int32) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Int) Set(k int32, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Int) Delete(k int32) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Int16 struct {
	M map[int32]int16
	L sync.RWMutex
}

func NewConMapInt32Int16() *ConMapInt32Int16 {
	return ToConMapInt32Int16(nil)
}

func ToConMapInt32Int16(data map[int32]int16) *ConMapInt32Int16 {
	if data == nil {
		data = make(map[int32]int16)
	}
	return &ConMapInt32Int16{M: data}
}

func (cm *ConMapInt32Int16) Get(k int32) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Int16) GetOK(k int32) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Int16) Set(k int32, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Int16) Delete(k int32) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Int32 struct {
	M map[int32]int32
	L sync.RWMutex
}

func NewConMapInt32Int32() *ConMapInt32Int32 {
	return ToConMapInt32Int32(nil)
}

func ToConMapInt32Int32(data map[int32]int32) *ConMapInt32Int32 {
	if data == nil {
		data = make(map[int32]int32)
	}
	return &ConMapInt32Int32{M: data}
}

func (cm *ConMapInt32Int32) Get(k int32) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Int32) GetOK(k int32) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Int32) Set(k int32, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Int32) Delete(k int32) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Int64 struct {
	M map[int32]int64
	L sync.RWMutex
}

func NewConMapInt32Int64() *ConMapInt32Int64 {
	return ToConMapInt32Int64(nil)
}

func ToConMapInt32Int64(data map[int32]int64) *ConMapInt32Int64 {
	if data == nil {
		data = make(map[int32]int64)
	}
	return &ConMapInt32Int64{M: data}
}

func (cm *ConMapInt32Int64) Get(k int32) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Int64) GetOK(k int32) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Int64) Set(k int32, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Int64) Delete(k int32) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Int8 struct {
	M map[int32]int8
	L sync.RWMutex
}

func NewConMapInt32Int8() *ConMapInt32Int8 {
	return ToConMapInt32Int8(nil)
}

func ToConMapInt32Int8(data map[int32]int8) *ConMapInt32Int8 {
	if data == nil {
		data = make(map[int32]int8)
	}
	return &ConMapInt32Int8{M: data}
}

func (cm *ConMapInt32Int8) Get(k int32) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Int8) GetOK(k int32) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Int8) Set(k int32, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Int8) Delete(k int32) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Rune struct {
	M map[int32]rune
	L sync.RWMutex
}

func NewConMapInt32Rune() *ConMapInt32Rune {
	return ToConMapInt32Rune(nil)
}

func ToConMapInt32Rune(data map[int32]rune) *ConMapInt32Rune {
	if data == nil {
		data = make(map[int32]rune)
	}
	return &ConMapInt32Rune{M: data}
}

func (cm *ConMapInt32Rune) Get(k int32) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Rune) GetOK(k int32) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Rune) Set(k int32, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Rune) Delete(k int32) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32String struct {
	M map[int32]string
	L sync.RWMutex
}

func NewConMapInt32String() *ConMapInt32String {
	return ToConMapInt32String(nil)
}

func ToConMapInt32String(data map[int32]string) *ConMapInt32String {
	if data == nil {
		data = make(map[int32]string)
	}
	return &ConMapInt32String{M: data}
}

func (cm *ConMapInt32String) Get(k int32) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32String) GetOK(k int32) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32String) Set(k int32, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32String) Delete(k int32) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Uint struct {
	M map[int32]uint
	L sync.RWMutex
}

func NewConMapInt32Uint() *ConMapInt32Uint {
	return ToConMapInt32Uint(nil)
}

func ToConMapInt32Uint(data map[int32]uint) *ConMapInt32Uint {
	if data == nil {
		data = make(map[int32]uint)
	}
	return &ConMapInt32Uint{M: data}
}

func (cm *ConMapInt32Uint) Get(k int32) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Uint) GetOK(k int32) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Uint) Set(k int32, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Uint) Delete(k int32) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Uint16 struct {
	M map[int32]uint16
	L sync.RWMutex
}

func NewConMapInt32Uint16() *ConMapInt32Uint16 {
	return ToConMapInt32Uint16(nil)
}

func ToConMapInt32Uint16(data map[int32]uint16) *ConMapInt32Uint16 {
	if data == nil {
		data = make(map[int32]uint16)
	}
	return &ConMapInt32Uint16{M: data}
}

func (cm *ConMapInt32Uint16) Get(k int32) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Uint16) GetOK(k int32) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Uint16) Set(k int32, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Uint16) Delete(k int32) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Uint32 struct {
	M map[int32]uint32
	L sync.RWMutex
}

func NewConMapInt32Uint32() *ConMapInt32Uint32 {
	return ToConMapInt32Uint32(nil)
}

func ToConMapInt32Uint32(data map[int32]uint32) *ConMapInt32Uint32 {
	if data == nil {
		data = make(map[int32]uint32)
	}
	return &ConMapInt32Uint32{M: data}
}

func (cm *ConMapInt32Uint32) Get(k int32) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Uint32) GetOK(k int32) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Uint32) Set(k int32, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Uint32) Delete(k int32) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Uint64 struct {
	M map[int32]uint64
	L sync.RWMutex
}

func NewConMapInt32Uint64() *ConMapInt32Uint64 {
	return ToConMapInt32Uint64(nil)
}

func ToConMapInt32Uint64(data map[int32]uint64) *ConMapInt32Uint64 {
	if data == nil {
		data = make(map[int32]uint64)
	}
	return &ConMapInt32Uint64{M: data}
}

func (cm *ConMapInt32Uint64) Get(k int32) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Uint64) GetOK(k int32) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Uint64) Set(k int32, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Uint64) Delete(k int32) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Uint8 struct {
	M map[int32]uint8
	L sync.RWMutex
}

func NewConMapInt32Uint8() *ConMapInt32Uint8 {
	return ToConMapInt32Uint8(nil)
}

func ToConMapInt32Uint8(data map[int32]uint8) *ConMapInt32Uint8 {
	if data == nil {
		data = make(map[int32]uint8)
	}
	return &ConMapInt32Uint8{M: data}
}

func (cm *ConMapInt32Uint8) Get(k int32) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Uint8) GetOK(k int32) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Uint8) Set(k int32, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Uint8) Delete(k int32) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt32Uintptr struct {
	M map[int32]uintptr
	L sync.RWMutex
}

func NewConMapInt32Uintptr() *ConMapInt32Uintptr {
	return ToConMapInt32Uintptr(nil)
}

func ToConMapInt32Uintptr(data map[int32]uintptr) *ConMapInt32Uintptr {
	if data == nil {
		data = make(map[int32]uintptr)
	}
	return &ConMapInt32Uintptr{M: data}
}

func (cm *ConMapInt32Uintptr) Get(k int32) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt32Uintptr) GetOK(k int32) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt32Uintptr) Set(k int32, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt32Uintptr) Delete(k int32) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt32Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Bool struct {
	M map[int64]bool
	L sync.RWMutex
}

func NewConMapInt64Bool() *ConMapInt64Bool {
	return ToConMapInt64Bool(nil)
}

func ToConMapInt64Bool(data map[int64]bool) *ConMapInt64Bool {
	if data == nil {
		data = make(map[int64]bool)
	}
	return &ConMapInt64Bool{M: data}
}

func (cm *ConMapInt64Bool) Get(k int64) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Bool) GetOK(k int64) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Bool) Set(k int64, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Bool) Delete(k int64) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Byte struct {
	M map[int64]byte
	L sync.RWMutex
}

func NewConMapInt64Byte() *ConMapInt64Byte {
	return ToConMapInt64Byte(nil)
}

func ToConMapInt64Byte(data map[int64]byte) *ConMapInt64Byte {
	if data == nil {
		data = make(map[int64]byte)
	}
	return &ConMapInt64Byte{M: data}
}

func (cm *ConMapInt64Byte) Get(k int64) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Byte) GetOK(k int64) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Byte) Set(k int64, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Byte) Delete(k int64) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Complex128 struct {
	M map[int64]complex128
	L sync.RWMutex
}

func NewConMapInt64Complex128() *ConMapInt64Complex128 {
	return ToConMapInt64Complex128(nil)
}

func ToConMapInt64Complex128(data map[int64]complex128) *ConMapInt64Complex128 {
	if data == nil {
		data = make(map[int64]complex128)
	}
	return &ConMapInt64Complex128{M: data}
}

func (cm *ConMapInt64Complex128) Get(k int64) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Complex128) GetOK(k int64) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Complex128) Set(k int64, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Complex128) Delete(k int64) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Complex64 struct {
	M map[int64]complex64
	L sync.RWMutex
}

func NewConMapInt64Complex64() *ConMapInt64Complex64 {
	return ToConMapInt64Complex64(nil)
}

func ToConMapInt64Complex64(data map[int64]complex64) *ConMapInt64Complex64 {
	if data == nil {
		data = make(map[int64]complex64)
	}
	return &ConMapInt64Complex64{M: data}
}

func (cm *ConMapInt64Complex64) Get(k int64) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Complex64) GetOK(k int64) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Complex64) Set(k int64, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Complex64) Delete(k int64) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Error struct {
	M map[int64]error
	L sync.RWMutex
}

func NewConMapInt64Error() *ConMapInt64Error {
	return ToConMapInt64Error(nil)
}

func ToConMapInt64Error(data map[int64]error) *ConMapInt64Error {
	if data == nil {
		data = make(map[int64]error)
	}
	return &ConMapInt64Error{M: data}
}

func (cm *ConMapInt64Error) Get(k int64) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Error) GetOK(k int64) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Error) Set(k int64, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Error) Delete(k int64) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Float32 struct {
	M map[int64]float32
	L sync.RWMutex
}

func NewConMapInt64Float32() *ConMapInt64Float32 {
	return ToConMapInt64Float32(nil)
}

func ToConMapInt64Float32(data map[int64]float32) *ConMapInt64Float32 {
	if data == nil {
		data = make(map[int64]float32)
	}
	return &ConMapInt64Float32{M: data}
}

func (cm *ConMapInt64Float32) Get(k int64) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Float32) GetOK(k int64) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Float32) Set(k int64, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Float32) Delete(k int64) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Float64 struct {
	M map[int64]float64
	L sync.RWMutex
}

func NewConMapInt64Float64() *ConMapInt64Float64 {
	return ToConMapInt64Float64(nil)
}

func ToConMapInt64Float64(data map[int64]float64) *ConMapInt64Float64 {
	if data == nil {
		data = make(map[int64]float64)
	}
	return &ConMapInt64Float64{M: data}
}

func (cm *ConMapInt64Float64) Get(k int64) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Float64) GetOK(k int64) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Float64) Set(k int64, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Float64) Delete(k int64) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Int struct {
	M map[int64]int
	L sync.RWMutex
}

func NewConMapInt64Int() *ConMapInt64Int {
	return ToConMapInt64Int(nil)
}

func ToConMapInt64Int(data map[int64]int) *ConMapInt64Int {
	if data == nil {
		data = make(map[int64]int)
	}
	return &ConMapInt64Int{M: data}
}

func (cm *ConMapInt64Int) Get(k int64) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Int) GetOK(k int64) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Int) Set(k int64, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Int) Delete(k int64) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Int16 struct {
	M map[int64]int16
	L sync.RWMutex
}

func NewConMapInt64Int16() *ConMapInt64Int16 {
	return ToConMapInt64Int16(nil)
}

func ToConMapInt64Int16(data map[int64]int16) *ConMapInt64Int16 {
	if data == nil {
		data = make(map[int64]int16)
	}
	return &ConMapInt64Int16{M: data}
}

func (cm *ConMapInt64Int16) Get(k int64) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Int16) GetOK(k int64) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Int16) Set(k int64, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Int16) Delete(k int64) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Int32 struct {
	M map[int64]int32
	L sync.RWMutex
}

func NewConMapInt64Int32() *ConMapInt64Int32 {
	return ToConMapInt64Int32(nil)
}

func ToConMapInt64Int32(data map[int64]int32) *ConMapInt64Int32 {
	if data == nil {
		data = make(map[int64]int32)
	}
	return &ConMapInt64Int32{M: data}
}

func (cm *ConMapInt64Int32) Get(k int64) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Int32) GetOK(k int64) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Int32) Set(k int64, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Int32) Delete(k int64) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Int64 struct {
	M map[int64]int64
	L sync.RWMutex
}

func NewConMapInt64Int64() *ConMapInt64Int64 {
	return ToConMapInt64Int64(nil)
}

func ToConMapInt64Int64(data map[int64]int64) *ConMapInt64Int64 {
	if data == nil {
		data = make(map[int64]int64)
	}
	return &ConMapInt64Int64{M: data}
}

func (cm *ConMapInt64Int64) Get(k int64) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Int64) GetOK(k int64) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Int64) Set(k int64, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Int64) Delete(k int64) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Int8 struct {
	M map[int64]int8
	L sync.RWMutex
}

func NewConMapInt64Int8() *ConMapInt64Int8 {
	return ToConMapInt64Int8(nil)
}

func ToConMapInt64Int8(data map[int64]int8) *ConMapInt64Int8 {
	if data == nil {
		data = make(map[int64]int8)
	}
	return &ConMapInt64Int8{M: data}
}

func (cm *ConMapInt64Int8) Get(k int64) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Int8) GetOK(k int64) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Int8) Set(k int64, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Int8) Delete(k int64) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Rune struct {
	M map[int64]rune
	L sync.RWMutex
}

func NewConMapInt64Rune() *ConMapInt64Rune {
	return ToConMapInt64Rune(nil)
}

func ToConMapInt64Rune(data map[int64]rune) *ConMapInt64Rune {
	if data == nil {
		data = make(map[int64]rune)
	}
	return &ConMapInt64Rune{M: data}
}

func (cm *ConMapInt64Rune) Get(k int64) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Rune) GetOK(k int64) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Rune) Set(k int64, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Rune) Delete(k int64) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64String struct {
	M map[int64]string
	L sync.RWMutex
}

func NewConMapInt64String() *ConMapInt64String {
	return ToConMapInt64String(nil)
}

func ToConMapInt64String(data map[int64]string) *ConMapInt64String {
	if data == nil {
		data = make(map[int64]string)
	}
	return &ConMapInt64String{M: data}
}

func (cm *ConMapInt64String) Get(k int64) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64String) GetOK(k int64) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64String) Set(k int64, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64String) Delete(k int64) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Uint struct {
	M map[int64]uint
	L sync.RWMutex
}

func NewConMapInt64Uint() *ConMapInt64Uint {
	return ToConMapInt64Uint(nil)
}

func ToConMapInt64Uint(data map[int64]uint) *ConMapInt64Uint {
	if data == nil {
		data = make(map[int64]uint)
	}
	return &ConMapInt64Uint{M: data}
}

func (cm *ConMapInt64Uint) Get(k int64) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Uint) GetOK(k int64) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Uint) Set(k int64, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Uint) Delete(k int64) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Uint16 struct {
	M map[int64]uint16
	L sync.RWMutex
}

func NewConMapInt64Uint16() *ConMapInt64Uint16 {
	return ToConMapInt64Uint16(nil)
}

func ToConMapInt64Uint16(data map[int64]uint16) *ConMapInt64Uint16 {
	if data == nil {
		data = make(map[int64]uint16)
	}
	return &ConMapInt64Uint16{M: data}
}

func (cm *ConMapInt64Uint16) Get(k int64) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Uint16) GetOK(k int64) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Uint16) Set(k int64, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Uint16) Delete(k int64) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Uint32 struct {
	M map[int64]uint32
	L sync.RWMutex
}

func NewConMapInt64Uint32() *ConMapInt64Uint32 {
	return ToConMapInt64Uint32(nil)
}

func ToConMapInt64Uint32(data map[int64]uint32) *ConMapInt64Uint32 {
	if data == nil {
		data = make(map[int64]uint32)
	}
	return &ConMapInt64Uint32{M: data}
}

func (cm *ConMapInt64Uint32) Get(k int64) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Uint32) GetOK(k int64) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Uint32) Set(k int64, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Uint32) Delete(k int64) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Uint64 struct {
	M map[int64]uint64
	L sync.RWMutex
}

func NewConMapInt64Uint64() *ConMapInt64Uint64 {
	return ToConMapInt64Uint64(nil)
}

func ToConMapInt64Uint64(data map[int64]uint64) *ConMapInt64Uint64 {
	if data == nil {
		data = make(map[int64]uint64)
	}
	return &ConMapInt64Uint64{M: data}
}

func (cm *ConMapInt64Uint64) Get(k int64) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Uint64) GetOK(k int64) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Uint64) Set(k int64, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Uint64) Delete(k int64) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Uint8 struct {
	M map[int64]uint8
	L sync.RWMutex
}

func NewConMapInt64Uint8() *ConMapInt64Uint8 {
	return ToConMapInt64Uint8(nil)
}

func ToConMapInt64Uint8(data map[int64]uint8) *ConMapInt64Uint8 {
	if data == nil {
		data = make(map[int64]uint8)
	}
	return &ConMapInt64Uint8{M: data}
}

func (cm *ConMapInt64Uint8) Get(k int64) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Uint8) GetOK(k int64) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Uint8) Set(k int64, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Uint8) Delete(k int64) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt64Uintptr struct {
	M map[int64]uintptr
	L sync.RWMutex
}

func NewConMapInt64Uintptr() *ConMapInt64Uintptr {
	return ToConMapInt64Uintptr(nil)
}

func ToConMapInt64Uintptr(data map[int64]uintptr) *ConMapInt64Uintptr {
	if data == nil {
		data = make(map[int64]uintptr)
	}
	return &ConMapInt64Uintptr{M: data}
}

func (cm *ConMapInt64Uintptr) Get(k int64) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt64Uintptr) GetOK(k int64) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt64Uintptr) Set(k int64, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt64Uintptr) Delete(k int64) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt64Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Bool struct {
	M map[int8]bool
	L sync.RWMutex
}

func NewConMapInt8Bool() *ConMapInt8Bool {
	return ToConMapInt8Bool(nil)
}

func ToConMapInt8Bool(data map[int8]bool) *ConMapInt8Bool {
	if data == nil {
		data = make(map[int8]bool)
	}
	return &ConMapInt8Bool{M: data}
}

func (cm *ConMapInt8Bool) Get(k int8) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Bool) GetOK(k int8) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Bool) Set(k int8, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Bool) Delete(k int8) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Byte struct {
	M map[int8]byte
	L sync.RWMutex
}

func NewConMapInt8Byte() *ConMapInt8Byte {
	return ToConMapInt8Byte(nil)
}

func ToConMapInt8Byte(data map[int8]byte) *ConMapInt8Byte {
	if data == nil {
		data = make(map[int8]byte)
	}
	return &ConMapInt8Byte{M: data}
}

func (cm *ConMapInt8Byte) Get(k int8) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Byte) GetOK(k int8) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Byte) Set(k int8, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Byte) Delete(k int8) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Complex128 struct {
	M map[int8]complex128
	L sync.RWMutex
}

func NewConMapInt8Complex128() *ConMapInt8Complex128 {
	return ToConMapInt8Complex128(nil)
}

func ToConMapInt8Complex128(data map[int8]complex128) *ConMapInt8Complex128 {
	if data == nil {
		data = make(map[int8]complex128)
	}
	return &ConMapInt8Complex128{M: data}
}

func (cm *ConMapInt8Complex128) Get(k int8) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Complex128) GetOK(k int8) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Complex128) Set(k int8, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Complex128) Delete(k int8) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Complex64 struct {
	M map[int8]complex64
	L sync.RWMutex
}

func NewConMapInt8Complex64() *ConMapInt8Complex64 {
	return ToConMapInt8Complex64(nil)
}

func ToConMapInt8Complex64(data map[int8]complex64) *ConMapInt8Complex64 {
	if data == nil {
		data = make(map[int8]complex64)
	}
	return &ConMapInt8Complex64{M: data}
}

func (cm *ConMapInt8Complex64) Get(k int8) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Complex64) GetOK(k int8) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Complex64) Set(k int8, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Complex64) Delete(k int8) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Error struct {
	M map[int8]error
	L sync.RWMutex
}

func NewConMapInt8Error() *ConMapInt8Error {
	return ToConMapInt8Error(nil)
}

func ToConMapInt8Error(data map[int8]error) *ConMapInt8Error {
	if data == nil {
		data = make(map[int8]error)
	}
	return &ConMapInt8Error{M: data}
}

func (cm *ConMapInt8Error) Get(k int8) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Error) GetOK(k int8) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Error) Set(k int8, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Error) Delete(k int8) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Float32 struct {
	M map[int8]float32
	L sync.RWMutex
}

func NewConMapInt8Float32() *ConMapInt8Float32 {
	return ToConMapInt8Float32(nil)
}

func ToConMapInt8Float32(data map[int8]float32) *ConMapInt8Float32 {
	if data == nil {
		data = make(map[int8]float32)
	}
	return &ConMapInt8Float32{M: data}
}

func (cm *ConMapInt8Float32) Get(k int8) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Float32) GetOK(k int8) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Float32) Set(k int8, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Float32) Delete(k int8) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Float64 struct {
	M map[int8]float64
	L sync.RWMutex
}

func NewConMapInt8Float64() *ConMapInt8Float64 {
	return ToConMapInt8Float64(nil)
}

func ToConMapInt8Float64(data map[int8]float64) *ConMapInt8Float64 {
	if data == nil {
		data = make(map[int8]float64)
	}
	return &ConMapInt8Float64{M: data}
}

func (cm *ConMapInt8Float64) Get(k int8) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Float64) GetOK(k int8) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Float64) Set(k int8, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Float64) Delete(k int8) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Int struct {
	M map[int8]int
	L sync.RWMutex
}

func NewConMapInt8Int() *ConMapInt8Int {
	return ToConMapInt8Int(nil)
}

func ToConMapInt8Int(data map[int8]int) *ConMapInt8Int {
	if data == nil {
		data = make(map[int8]int)
	}
	return &ConMapInt8Int{M: data}
}

func (cm *ConMapInt8Int) Get(k int8) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Int) GetOK(k int8) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Int) Set(k int8, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Int) Delete(k int8) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Int16 struct {
	M map[int8]int16
	L sync.RWMutex
}

func NewConMapInt8Int16() *ConMapInt8Int16 {
	return ToConMapInt8Int16(nil)
}

func ToConMapInt8Int16(data map[int8]int16) *ConMapInt8Int16 {
	if data == nil {
		data = make(map[int8]int16)
	}
	return &ConMapInt8Int16{M: data}
}

func (cm *ConMapInt8Int16) Get(k int8) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Int16) GetOK(k int8) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Int16) Set(k int8, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Int16) Delete(k int8) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Int32 struct {
	M map[int8]int32
	L sync.RWMutex
}

func NewConMapInt8Int32() *ConMapInt8Int32 {
	return ToConMapInt8Int32(nil)
}

func ToConMapInt8Int32(data map[int8]int32) *ConMapInt8Int32 {
	if data == nil {
		data = make(map[int8]int32)
	}
	return &ConMapInt8Int32{M: data}
}

func (cm *ConMapInt8Int32) Get(k int8) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Int32) GetOK(k int8) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Int32) Set(k int8, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Int32) Delete(k int8) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Int64 struct {
	M map[int8]int64
	L sync.RWMutex
}

func NewConMapInt8Int64() *ConMapInt8Int64 {
	return ToConMapInt8Int64(nil)
}

func ToConMapInt8Int64(data map[int8]int64) *ConMapInt8Int64 {
	if data == nil {
		data = make(map[int8]int64)
	}
	return &ConMapInt8Int64{M: data}
}

func (cm *ConMapInt8Int64) Get(k int8) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Int64) GetOK(k int8) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Int64) Set(k int8, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Int64) Delete(k int8) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Int8 struct {
	M map[int8]int8
	L sync.RWMutex
}

func NewConMapInt8Int8() *ConMapInt8Int8 {
	return ToConMapInt8Int8(nil)
}

func ToConMapInt8Int8(data map[int8]int8) *ConMapInt8Int8 {
	if data == nil {
		data = make(map[int8]int8)
	}
	return &ConMapInt8Int8{M: data}
}

func (cm *ConMapInt8Int8) Get(k int8) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Int8) GetOK(k int8) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Int8) Set(k int8, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Int8) Delete(k int8) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Rune struct {
	M map[int8]rune
	L sync.RWMutex
}

func NewConMapInt8Rune() *ConMapInt8Rune {
	return ToConMapInt8Rune(nil)
}

func ToConMapInt8Rune(data map[int8]rune) *ConMapInt8Rune {
	if data == nil {
		data = make(map[int8]rune)
	}
	return &ConMapInt8Rune{M: data}
}

func (cm *ConMapInt8Rune) Get(k int8) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Rune) GetOK(k int8) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Rune) Set(k int8, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Rune) Delete(k int8) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8String struct {
	M map[int8]string
	L sync.RWMutex
}

func NewConMapInt8String() *ConMapInt8String {
	return ToConMapInt8String(nil)
}

func ToConMapInt8String(data map[int8]string) *ConMapInt8String {
	if data == nil {
		data = make(map[int8]string)
	}
	return &ConMapInt8String{M: data}
}

func (cm *ConMapInt8String) Get(k int8) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8String) GetOK(k int8) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8String) Set(k int8, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8String) Delete(k int8) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Uint struct {
	M map[int8]uint
	L sync.RWMutex
}

func NewConMapInt8Uint() *ConMapInt8Uint {
	return ToConMapInt8Uint(nil)
}

func ToConMapInt8Uint(data map[int8]uint) *ConMapInt8Uint {
	if data == nil {
		data = make(map[int8]uint)
	}
	return &ConMapInt8Uint{M: data}
}

func (cm *ConMapInt8Uint) Get(k int8) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Uint) GetOK(k int8) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Uint) Set(k int8, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Uint) Delete(k int8) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Uint16 struct {
	M map[int8]uint16
	L sync.RWMutex
}

func NewConMapInt8Uint16() *ConMapInt8Uint16 {
	return ToConMapInt8Uint16(nil)
}

func ToConMapInt8Uint16(data map[int8]uint16) *ConMapInt8Uint16 {
	if data == nil {
		data = make(map[int8]uint16)
	}
	return &ConMapInt8Uint16{M: data}
}

func (cm *ConMapInt8Uint16) Get(k int8) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Uint16) GetOK(k int8) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Uint16) Set(k int8, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Uint16) Delete(k int8) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Uint32 struct {
	M map[int8]uint32
	L sync.RWMutex
}

func NewConMapInt8Uint32() *ConMapInt8Uint32 {
	return ToConMapInt8Uint32(nil)
}

func ToConMapInt8Uint32(data map[int8]uint32) *ConMapInt8Uint32 {
	if data == nil {
		data = make(map[int8]uint32)
	}
	return &ConMapInt8Uint32{M: data}
}

func (cm *ConMapInt8Uint32) Get(k int8) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Uint32) GetOK(k int8) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Uint32) Set(k int8, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Uint32) Delete(k int8) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Uint64 struct {
	M map[int8]uint64
	L sync.RWMutex
}

func NewConMapInt8Uint64() *ConMapInt8Uint64 {
	return ToConMapInt8Uint64(nil)
}

func ToConMapInt8Uint64(data map[int8]uint64) *ConMapInt8Uint64 {
	if data == nil {
		data = make(map[int8]uint64)
	}
	return &ConMapInt8Uint64{M: data}
}

func (cm *ConMapInt8Uint64) Get(k int8) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Uint64) GetOK(k int8) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Uint64) Set(k int8, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Uint64) Delete(k int8) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Uint8 struct {
	M map[int8]uint8
	L sync.RWMutex
}

func NewConMapInt8Uint8() *ConMapInt8Uint8 {
	return ToConMapInt8Uint8(nil)
}

func ToConMapInt8Uint8(data map[int8]uint8) *ConMapInt8Uint8 {
	if data == nil {
		data = make(map[int8]uint8)
	}
	return &ConMapInt8Uint8{M: data}
}

func (cm *ConMapInt8Uint8) Get(k int8) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Uint8) GetOK(k int8) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Uint8) Set(k int8, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Uint8) Delete(k int8) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapInt8Uintptr struct {
	M map[int8]uintptr
	L sync.RWMutex
}

func NewConMapInt8Uintptr() *ConMapInt8Uintptr {
	return ToConMapInt8Uintptr(nil)
}

func ToConMapInt8Uintptr(data map[int8]uintptr) *ConMapInt8Uintptr {
	if data == nil {
		data = make(map[int8]uintptr)
	}
	return &ConMapInt8Uintptr{M: data}
}

func (cm *ConMapInt8Uintptr) Get(k int8) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapInt8Uintptr) GetOK(k int8) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapInt8Uintptr) Set(k int8, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapInt8Uintptr) Delete(k int8) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapInt8Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneBool struct {
	M map[rune]bool
	L sync.RWMutex
}

func NewConMapRuneBool() *ConMapRuneBool {
	return ToConMapRuneBool(nil)
}

func ToConMapRuneBool(data map[rune]bool) *ConMapRuneBool {
	if data == nil {
		data = make(map[rune]bool)
	}
	return &ConMapRuneBool{M: data}
}

func (cm *ConMapRuneBool) Get(k rune) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneBool) GetOK(k rune) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneBool) Set(k rune, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneBool) Delete(k rune) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneByte struct {
	M map[rune]byte
	L sync.RWMutex
}

func NewConMapRuneByte() *ConMapRuneByte {
	return ToConMapRuneByte(nil)
}

func ToConMapRuneByte(data map[rune]byte) *ConMapRuneByte {
	if data == nil {
		data = make(map[rune]byte)
	}
	return &ConMapRuneByte{M: data}
}

func (cm *ConMapRuneByte) Get(k rune) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneByte) GetOK(k rune) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneByte) Set(k rune, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneByte) Delete(k rune) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneComplex128 struct {
	M map[rune]complex128
	L sync.RWMutex
}

func NewConMapRuneComplex128() *ConMapRuneComplex128 {
	return ToConMapRuneComplex128(nil)
}

func ToConMapRuneComplex128(data map[rune]complex128) *ConMapRuneComplex128 {
	if data == nil {
		data = make(map[rune]complex128)
	}
	return &ConMapRuneComplex128{M: data}
}

func (cm *ConMapRuneComplex128) Get(k rune) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneComplex128) GetOK(k rune) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneComplex128) Set(k rune, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneComplex128) Delete(k rune) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneComplex64 struct {
	M map[rune]complex64
	L sync.RWMutex
}

func NewConMapRuneComplex64() *ConMapRuneComplex64 {
	return ToConMapRuneComplex64(nil)
}

func ToConMapRuneComplex64(data map[rune]complex64) *ConMapRuneComplex64 {
	if data == nil {
		data = make(map[rune]complex64)
	}
	return &ConMapRuneComplex64{M: data}
}

func (cm *ConMapRuneComplex64) Get(k rune) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneComplex64) GetOK(k rune) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneComplex64) Set(k rune, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneComplex64) Delete(k rune) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneError struct {
	M map[rune]error
	L sync.RWMutex
}

func NewConMapRuneError() *ConMapRuneError {
	return ToConMapRuneError(nil)
}

func ToConMapRuneError(data map[rune]error) *ConMapRuneError {
	if data == nil {
		data = make(map[rune]error)
	}
	return &ConMapRuneError{M: data}
}

func (cm *ConMapRuneError) Get(k rune) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneError) GetOK(k rune) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneError) Set(k rune, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneError) Delete(k rune) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneFloat32 struct {
	M map[rune]float32
	L sync.RWMutex
}

func NewConMapRuneFloat32() *ConMapRuneFloat32 {
	return ToConMapRuneFloat32(nil)
}

func ToConMapRuneFloat32(data map[rune]float32) *ConMapRuneFloat32 {
	if data == nil {
		data = make(map[rune]float32)
	}
	return &ConMapRuneFloat32{M: data}
}

func (cm *ConMapRuneFloat32) Get(k rune) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneFloat32) GetOK(k rune) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneFloat32) Set(k rune, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneFloat32) Delete(k rune) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneFloat64 struct {
	M map[rune]float64
	L sync.RWMutex
}

func NewConMapRuneFloat64() *ConMapRuneFloat64 {
	return ToConMapRuneFloat64(nil)
}

func ToConMapRuneFloat64(data map[rune]float64) *ConMapRuneFloat64 {
	if data == nil {
		data = make(map[rune]float64)
	}
	return &ConMapRuneFloat64{M: data}
}

func (cm *ConMapRuneFloat64) Get(k rune) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneFloat64) GetOK(k rune) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneFloat64) Set(k rune, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneFloat64) Delete(k rune) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneInt struct {
	M map[rune]int
	L sync.RWMutex
}

func NewConMapRuneInt() *ConMapRuneInt {
	return ToConMapRuneInt(nil)
}

func ToConMapRuneInt(data map[rune]int) *ConMapRuneInt {
	if data == nil {
		data = make(map[rune]int)
	}
	return &ConMapRuneInt{M: data}
}

func (cm *ConMapRuneInt) Get(k rune) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneInt) GetOK(k rune) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneInt) Set(k rune, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneInt) Delete(k rune) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneInt16 struct {
	M map[rune]int16
	L sync.RWMutex
}

func NewConMapRuneInt16() *ConMapRuneInt16 {
	return ToConMapRuneInt16(nil)
}

func ToConMapRuneInt16(data map[rune]int16) *ConMapRuneInt16 {
	if data == nil {
		data = make(map[rune]int16)
	}
	return &ConMapRuneInt16{M: data}
}

func (cm *ConMapRuneInt16) Get(k rune) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneInt16) GetOK(k rune) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneInt16) Set(k rune, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneInt16) Delete(k rune) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneInt32 struct {
	M map[rune]int32
	L sync.RWMutex
}

func NewConMapRuneInt32() *ConMapRuneInt32 {
	return ToConMapRuneInt32(nil)
}

func ToConMapRuneInt32(data map[rune]int32) *ConMapRuneInt32 {
	if data == nil {
		data = make(map[rune]int32)
	}
	return &ConMapRuneInt32{M: data}
}

func (cm *ConMapRuneInt32) Get(k rune) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneInt32) GetOK(k rune) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneInt32) Set(k rune, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneInt32) Delete(k rune) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneInt64 struct {
	M map[rune]int64
	L sync.RWMutex
}

func NewConMapRuneInt64() *ConMapRuneInt64 {
	return ToConMapRuneInt64(nil)
}

func ToConMapRuneInt64(data map[rune]int64) *ConMapRuneInt64 {
	if data == nil {
		data = make(map[rune]int64)
	}
	return &ConMapRuneInt64{M: data}
}

func (cm *ConMapRuneInt64) Get(k rune) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneInt64) GetOK(k rune) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneInt64) Set(k rune, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneInt64) Delete(k rune) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneInt8 struct {
	M map[rune]int8
	L sync.RWMutex
}

func NewConMapRuneInt8() *ConMapRuneInt8 {
	return ToConMapRuneInt8(nil)
}

func ToConMapRuneInt8(data map[rune]int8) *ConMapRuneInt8 {
	if data == nil {
		data = make(map[rune]int8)
	}
	return &ConMapRuneInt8{M: data}
}

func (cm *ConMapRuneInt8) Get(k rune) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneInt8) GetOK(k rune) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneInt8) Set(k rune, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneInt8) Delete(k rune) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneRune struct {
	M map[rune]rune
	L sync.RWMutex
}

func NewConMapRuneRune() *ConMapRuneRune {
	return ToConMapRuneRune(nil)
}

func ToConMapRuneRune(data map[rune]rune) *ConMapRuneRune {
	if data == nil {
		data = make(map[rune]rune)
	}
	return &ConMapRuneRune{M: data}
}

func (cm *ConMapRuneRune) Get(k rune) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneRune) GetOK(k rune) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneRune) Set(k rune, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneRune) Delete(k rune) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneString struct {
	M map[rune]string
	L sync.RWMutex
}

func NewConMapRuneString() *ConMapRuneString {
	return ToConMapRuneString(nil)
}

func ToConMapRuneString(data map[rune]string) *ConMapRuneString {
	if data == nil {
		data = make(map[rune]string)
	}
	return &ConMapRuneString{M: data}
}

func (cm *ConMapRuneString) Get(k rune) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneString) GetOK(k rune) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneString) Set(k rune, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneString) Delete(k rune) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneUint struct {
	M map[rune]uint
	L sync.RWMutex
}

func NewConMapRuneUint() *ConMapRuneUint {
	return ToConMapRuneUint(nil)
}

func ToConMapRuneUint(data map[rune]uint) *ConMapRuneUint {
	if data == nil {
		data = make(map[rune]uint)
	}
	return &ConMapRuneUint{M: data}
}

func (cm *ConMapRuneUint) Get(k rune) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneUint) GetOK(k rune) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneUint) Set(k rune, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneUint) Delete(k rune) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneUint16 struct {
	M map[rune]uint16
	L sync.RWMutex
}

func NewConMapRuneUint16() *ConMapRuneUint16 {
	return ToConMapRuneUint16(nil)
}

func ToConMapRuneUint16(data map[rune]uint16) *ConMapRuneUint16 {
	if data == nil {
		data = make(map[rune]uint16)
	}
	return &ConMapRuneUint16{M: data}
}

func (cm *ConMapRuneUint16) Get(k rune) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneUint16) GetOK(k rune) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneUint16) Set(k rune, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneUint16) Delete(k rune) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneUint32 struct {
	M map[rune]uint32
	L sync.RWMutex
}

func NewConMapRuneUint32() *ConMapRuneUint32 {
	return ToConMapRuneUint32(nil)
}

func ToConMapRuneUint32(data map[rune]uint32) *ConMapRuneUint32 {
	if data == nil {
		data = make(map[rune]uint32)
	}
	return &ConMapRuneUint32{M: data}
}

func (cm *ConMapRuneUint32) Get(k rune) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneUint32) GetOK(k rune) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneUint32) Set(k rune, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneUint32) Delete(k rune) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneUint64 struct {
	M map[rune]uint64
	L sync.RWMutex
}

func NewConMapRuneUint64() *ConMapRuneUint64 {
	return ToConMapRuneUint64(nil)
}

func ToConMapRuneUint64(data map[rune]uint64) *ConMapRuneUint64 {
	if data == nil {
		data = make(map[rune]uint64)
	}
	return &ConMapRuneUint64{M: data}
}

func (cm *ConMapRuneUint64) Get(k rune) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneUint64) GetOK(k rune) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneUint64) Set(k rune, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneUint64) Delete(k rune) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneUint8 struct {
	M map[rune]uint8
	L sync.RWMutex
}

func NewConMapRuneUint8() *ConMapRuneUint8 {
	return ToConMapRuneUint8(nil)
}

func ToConMapRuneUint8(data map[rune]uint8) *ConMapRuneUint8 {
	if data == nil {
		data = make(map[rune]uint8)
	}
	return &ConMapRuneUint8{M: data}
}

func (cm *ConMapRuneUint8) Get(k rune) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneUint8) GetOK(k rune) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneUint8) Set(k rune, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneUint8) Delete(k rune) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapRuneUintptr struct {
	M map[rune]uintptr
	L sync.RWMutex
}

func NewConMapRuneUintptr() *ConMapRuneUintptr {
	return ToConMapRuneUintptr(nil)
}

func ToConMapRuneUintptr(data map[rune]uintptr) *ConMapRuneUintptr {
	if data == nil {
		data = make(map[rune]uintptr)
	}
	return &ConMapRuneUintptr{M: data}
}

func (cm *ConMapRuneUintptr) Get(k rune) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapRuneUintptr) GetOK(k rune) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapRuneUintptr) Set(k rune, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapRuneUintptr) Delete(k rune) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapRuneUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringBool struct {
	M map[string]bool
	L sync.RWMutex
}

func NewConMapStringBool() *ConMapStringBool {
	return ToConMapStringBool(nil)
}

func ToConMapStringBool(data map[string]bool) *ConMapStringBool {
	if data == nil {
		data = make(map[string]bool)
	}
	return &ConMapStringBool{M: data}
}

func (cm *ConMapStringBool) Get(k string) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringBool) GetOK(k string) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringBool) Set(k string, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringBool) Delete(k string) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringByte struct {
	M map[string]byte
	L sync.RWMutex
}

func NewConMapStringByte() *ConMapStringByte {
	return ToConMapStringByte(nil)
}

func ToConMapStringByte(data map[string]byte) *ConMapStringByte {
	if data == nil {
		data = make(map[string]byte)
	}
	return &ConMapStringByte{M: data}
}

func (cm *ConMapStringByte) Get(k string) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringByte) GetOK(k string) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringByte) Set(k string, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringByte) Delete(k string) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringComplex128 struct {
	M map[string]complex128
	L sync.RWMutex
}

func NewConMapStringComplex128() *ConMapStringComplex128 {
	return ToConMapStringComplex128(nil)
}

func ToConMapStringComplex128(data map[string]complex128) *ConMapStringComplex128 {
	if data == nil {
		data = make(map[string]complex128)
	}
	return &ConMapStringComplex128{M: data}
}

func (cm *ConMapStringComplex128) Get(k string) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringComplex128) GetOK(k string) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringComplex128) Set(k string, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringComplex128) Delete(k string) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringComplex64 struct {
	M map[string]complex64
	L sync.RWMutex
}

func NewConMapStringComplex64() *ConMapStringComplex64 {
	return ToConMapStringComplex64(nil)
}

func ToConMapStringComplex64(data map[string]complex64) *ConMapStringComplex64 {
	if data == nil {
		data = make(map[string]complex64)
	}
	return &ConMapStringComplex64{M: data}
}

func (cm *ConMapStringComplex64) Get(k string) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringComplex64) GetOK(k string) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringComplex64) Set(k string, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringComplex64) Delete(k string) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringError struct {
	M map[string]error
	L sync.RWMutex
}

func NewConMapStringError() *ConMapStringError {
	return ToConMapStringError(nil)
}

func ToConMapStringError(data map[string]error) *ConMapStringError {
	if data == nil {
		data = make(map[string]error)
	}
	return &ConMapStringError{M: data}
}

func (cm *ConMapStringError) Get(k string) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringError) GetOK(k string) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringError) Set(k string, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringError) Delete(k string) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringFloat32 struct {
	M map[string]float32
	L sync.RWMutex
}

func NewConMapStringFloat32() *ConMapStringFloat32 {
	return ToConMapStringFloat32(nil)
}

func ToConMapStringFloat32(data map[string]float32) *ConMapStringFloat32 {
	if data == nil {
		data = make(map[string]float32)
	}
	return &ConMapStringFloat32{M: data}
}

func (cm *ConMapStringFloat32) Get(k string) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringFloat32) GetOK(k string) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringFloat32) Set(k string, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringFloat32) Delete(k string) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringFloat64 struct {
	M map[string]float64
	L sync.RWMutex
}

func NewConMapStringFloat64() *ConMapStringFloat64 {
	return ToConMapStringFloat64(nil)
}

func ToConMapStringFloat64(data map[string]float64) *ConMapStringFloat64 {
	if data == nil {
		data = make(map[string]float64)
	}
	return &ConMapStringFloat64{M: data}
}

func (cm *ConMapStringFloat64) Get(k string) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringFloat64) GetOK(k string) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringFloat64) Set(k string, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringFloat64) Delete(k string) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringInt struct {
	M map[string]int
	L sync.RWMutex
}

func NewConMapStringInt() *ConMapStringInt {
	return ToConMapStringInt(nil)
}

func ToConMapStringInt(data map[string]int) *ConMapStringInt {
	if data == nil {
		data = make(map[string]int)
	}
	return &ConMapStringInt{M: data}
}

func (cm *ConMapStringInt) Get(k string) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringInt) GetOK(k string) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringInt) Set(k string, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringInt) Delete(k string) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringInt16 struct {
	M map[string]int16
	L sync.RWMutex
}

func NewConMapStringInt16() *ConMapStringInt16 {
	return ToConMapStringInt16(nil)
}

func ToConMapStringInt16(data map[string]int16) *ConMapStringInt16 {
	if data == nil {
		data = make(map[string]int16)
	}
	return &ConMapStringInt16{M: data}
}

func (cm *ConMapStringInt16) Get(k string) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringInt16) GetOK(k string) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringInt16) Set(k string, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringInt16) Delete(k string) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringInt32 struct {
	M map[string]int32
	L sync.RWMutex
}

func NewConMapStringInt32() *ConMapStringInt32 {
	return ToConMapStringInt32(nil)
}

func ToConMapStringInt32(data map[string]int32) *ConMapStringInt32 {
	if data == nil {
		data = make(map[string]int32)
	}
	return &ConMapStringInt32{M: data}
}

func (cm *ConMapStringInt32) Get(k string) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringInt32) GetOK(k string) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringInt32) Set(k string, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringInt32) Delete(k string) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringInt64 struct {
	M map[string]int64
	L sync.RWMutex
}

func NewConMapStringInt64() *ConMapStringInt64 {
	return ToConMapStringInt64(nil)
}

func ToConMapStringInt64(data map[string]int64) *ConMapStringInt64 {
	if data == nil {
		data = make(map[string]int64)
	}
	return &ConMapStringInt64{M: data}
}

func (cm *ConMapStringInt64) Get(k string) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringInt64) GetOK(k string) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringInt64) Set(k string, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringInt64) Delete(k string) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringInt8 struct {
	M map[string]int8
	L sync.RWMutex
}

func NewConMapStringInt8() *ConMapStringInt8 {
	return ToConMapStringInt8(nil)
}

func ToConMapStringInt8(data map[string]int8) *ConMapStringInt8 {
	if data == nil {
		data = make(map[string]int8)
	}
	return &ConMapStringInt8{M: data}
}

func (cm *ConMapStringInt8) Get(k string) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringInt8) GetOK(k string) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringInt8) Set(k string, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringInt8) Delete(k string) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringRune struct {
	M map[string]rune
	L sync.RWMutex
}

func NewConMapStringRune() *ConMapStringRune {
	return ToConMapStringRune(nil)
}

func ToConMapStringRune(data map[string]rune) *ConMapStringRune {
	if data == nil {
		data = make(map[string]rune)
	}
	return &ConMapStringRune{M: data}
}

func (cm *ConMapStringRune) Get(k string) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringRune) GetOK(k string) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringRune) Set(k string, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringRune) Delete(k string) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringString struct {
	M map[string]string
	L sync.RWMutex
}

func NewConMapStringString() *ConMapStringString {
	return ToConMapStringString(nil)
}

func ToConMapStringString(data map[string]string) *ConMapStringString {
	if data == nil {
		data = make(map[string]string)
	}
	return &ConMapStringString{M: data}
}

func (cm *ConMapStringString) Get(k string) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringString) GetOK(k string) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringString) Set(k string, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringString) Delete(k string) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringUint struct {
	M map[string]uint
	L sync.RWMutex
}

func NewConMapStringUint() *ConMapStringUint {
	return ToConMapStringUint(nil)
}

func ToConMapStringUint(data map[string]uint) *ConMapStringUint {
	if data == nil {
		data = make(map[string]uint)
	}
	return &ConMapStringUint{M: data}
}

func (cm *ConMapStringUint) Get(k string) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringUint) GetOK(k string) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringUint) Set(k string, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringUint) Delete(k string) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringUint16 struct {
	M map[string]uint16
	L sync.RWMutex
}

func NewConMapStringUint16() *ConMapStringUint16 {
	return ToConMapStringUint16(nil)
}

func ToConMapStringUint16(data map[string]uint16) *ConMapStringUint16 {
	if data == nil {
		data = make(map[string]uint16)
	}
	return &ConMapStringUint16{M: data}
}

func (cm *ConMapStringUint16) Get(k string) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringUint16) GetOK(k string) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringUint16) Set(k string, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringUint16) Delete(k string) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringUint32 struct {
	M map[string]uint32
	L sync.RWMutex
}

func NewConMapStringUint32() *ConMapStringUint32 {
	return ToConMapStringUint32(nil)
}

func ToConMapStringUint32(data map[string]uint32) *ConMapStringUint32 {
	if data == nil {
		data = make(map[string]uint32)
	}
	return &ConMapStringUint32{M: data}
}

func (cm *ConMapStringUint32) Get(k string) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringUint32) GetOK(k string) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringUint32) Set(k string, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringUint32) Delete(k string) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringUint64 struct {
	M map[string]uint64
	L sync.RWMutex
}

func NewConMapStringUint64() *ConMapStringUint64 {
	return ToConMapStringUint64(nil)
}

func ToConMapStringUint64(data map[string]uint64) *ConMapStringUint64 {
	if data == nil {
		data = make(map[string]uint64)
	}
	return &ConMapStringUint64{M: data}
}

func (cm *ConMapStringUint64) Get(k string) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringUint64) GetOK(k string) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringUint64) Set(k string, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringUint64) Delete(k string) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringUint8 struct {
	M map[string]uint8
	L sync.RWMutex
}

func NewConMapStringUint8() *ConMapStringUint8 {
	return ToConMapStringUint8(nil)
}

func ToConMapStringUint8(data map[string]uint8) *ConMapStringUint8 {
	if data == nil {
		data = make(map[string]uint8)
	}
	return &ConMapStringUint8{M: data}
}

func (cm *ConMapStringUint8) Get(k string) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringUint8) GetOK(k string) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringUint8) Set(k string, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringUint8) Delete(k string) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapStringUintptr struct {
	M map[string]uintptr
	L sync.RWMutex
}

func NewConMapStringUintptr() *ConMapStringUintptr {
	return ToConMapStringUintptr(nil)
}

func ToConMapStringUintptr(data map[string]uintptr) *ConMapStringUintptr {
	if data == nil {
		data = make(map[string]uintptr)
	}
	return &ConMapStringUintptr{M: data}
}

func (cm *ConMapStringUintptr) Get(k string) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapStringUintptr) GetOK(k string) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapStringUintptr) Set(k string, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapStringUintptr) Delete(k string) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapStringUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintBool struct {
	M map[uint]bool
	L sync.RWMutex
}

func NewConMapUintBool() *ConMapUintBool {
	return ToConMapUintBool(nil)
}

func ToConMapUintBool(data map[uint]bool) *ConMapUintBool {
	if data == nil {
		data = make(map[uint]bool)
	}
	return &ConMapUintBool{M: data}
}

func (cm *ConMapUintBool) Get(k uint) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintBool) GetOK(k uint) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintBool) Set(k uint, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintBool) Delete(k uint) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintByte struct {
	M map[uint]byte
	L sync.RWMutex
}

func NewConMapUintByte() *ConMapUintByte {
	return ToConMapUintByte(nil)
}

func ToConMapUintByte(data map[uint]byte) *ConMapUintByte {
	if data == nil {
		data = make(map[uint]byte)
	}
	return &ConMapUintByte{M: data}
}

func (cm *ConMapUintByte) Get(k uint) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintByte) GetOK(k uint) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintByte) Set(k uint, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintByte) Delete(k uint) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintComplex128 struct {
	M map[uint]complex128
	L sync.RWMutex
}

func NewConMapUintComplex128() *ConMapUintComplex128 {
	return ToConMapUintComplex128(nil)
}

func ToConMapUintComplex128(data map[uint]complex128) *ConMapUintComplex128 {
	if data == nil {
		data = make(map[uint]complex128)
	}
	return &ConMapUintComplex128{M: data}
}

func (cm *ConMapUintComplex128) Get(k uint) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintComplex128) GetOK(k uint) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintComplex128) Set(k uint, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintComplex128) Delete(k uint) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintComplex64 struct {
	M map[uint]complex64
	L sync.RWMutex
}

func NewConMapUintComplex64() *ConMapUintComplex64 {
	return ToConMapUintComplex64(nil)
}

func ToConMapUintComplex64(data map[uint]complex64) *ConMapUintComplex64 {
	if data == nil {
		data = make(map[uint]complex64)
	}
	return &ConMapUintComplex64{M: data}
}

func (cm *ConMapUintComplex64) Get(k uint) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintComplex64) GetOK(k uint) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintComplex64) Set(k uint, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintComplex64) Delete(k uint) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintError struct {
	M map[uint]error
	L sync.RWMutex
}

func NewConMapUintError() *ConMapUintError {
	return ToConMapUintError(nil)
}

func ToConMapUintError(data map[uint]error) *ConMapUintError {
	if data == nil {
		data = make(map[uint]error)
	}
	return &ConMapUintError{M: data}
}

func (cm *ConMapUintError) Get(k uint) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintError) GetOK(k uint) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintError) Set(k uint, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintError) Delete(k uint) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintFloat32 struct {
	M map[uint]float32
	L sync.RWMutex
}

func NewConMapUintFloat32() *ConMapUintFloat32 {
	return ToConMapUintFloat32(nil)
}

func ToConMapUintFloat32(data map[uint]float32) *ConMapUintFloat32 {
	if data == nil {
		data = make(map[uint]float32)
	}
	return &ConMapUintFloat32{M: data}
}

func (cm *ConMapUintFloat32) Get(k uint) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintFloat32) GetOK(k uint) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintFloat32) Set(k uint, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintFloat32) Delete(k uint) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintFloat64 struct {
	M map[uint]float64
	L sync.RWMutex
}

func NewConMapUintFloat64() *ConMapUintFloat64 {
	return ToConMapUintFloat64(nil)
}

func ToConMapUintFloat64(data map[uint]float64) *ConMapUintFloat64 {
	if data == nil {
		data = make(map[uint]float64)
	}
	return &ConMapUintFloat64{M: data}
}

func (cm *ConMapUintFloat64) Get(k uint) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintFloat64) GetOK(k uint) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintFloat64) Set(k uint, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintFloat64) Delete(k uint) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintInt struct {
	M map[uint]int
	L sync.RWMutex
}

func NewConMapUintInt() *ConMapUintInt {
	return ToConMapUintInt(nil)
}

func ToConMapUintInt(data map[uint]int) *ConMapUintInt {
	if data == nil {
		data = make(map[uint]int)
	}
	return &ConMapUintInt{M: data}
}

func (cm *ConMapUintInt) Get(k uint) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintInt) GetOK(k uint) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintInt) Set(k uint, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintInt) Delete(k uint) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintInt16 struct {
	M map[uint]int16
	L sync.RWMutex
}

func NewConMapUintInt16() *ConMapUintInt16 {
	return ToConMapUintInt16(nil)
}

func ToConMapUintInt16(data map[uint]int16) *ConMapUintInt16 {
	if data == nil {
		data = make(map[uint]int16)
	}
	return &ConMapUintInt16{M: data}
}

func (cm *ConMapUintInt16) Get(k uint) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintInt16) GetOK(k uint) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintInt16) Set(k uint, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintInt16) Delete(k uint) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintInt32 struct {
	M map[uint]int32
	L sync.RWMutex
}

func NewConMapUintInt32() *ConMapUintInt32 {
	return ToConMapUintInt32(nil)
}

func ToConMapUintInt32(data map[uint]int32) *ConMapUintInt32 {
	if data == nil {
		data = make(map[uint]int32)
	}
	return &ConMapUintInt32{M: data}
}

func (cm *ConMapUintInt32) Get(k uint) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintInt32) GetOK(k uint) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintInt32) Set(k uint, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintInt32) Delete(k uint) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintInt64 struct {
	M map[uint]int64
	L sync.RWMutex
}

func NewConMapUintInt64() *ConMapUintInt64 {
	return ToConMapUintInt64(nil)
}

func ToConMapUintInt64(data map[uint]int64) *ConMapUintInt64 {
	if data == nil {
		data = make(map[uint]int64)
	}
	return &ConMapUintInt64{M: data}
}

func (cm *ConMapUintInt64) Get(k uint) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintInt64) GetOK(k uint) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintInt64) Set(k uint, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintInt64) Delete(k uint) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintInt8 struct {
	M map[uint]int8
	L sync.RWMutex
}

func NewConMapUintInt8() *ConMapUintInt8 {
	return ToConMapUintInt8(nil)
}

func ToConMapUintInt8(data map[uint]int8) *ConMapUintInt8 {
	if data == nil {
		data = make(map[uint]int8)
	}
	return &ConMapUintInt8{M: data}
}

func (cm *ConMapUintInt8) Get(k uint) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintInt8) GetOK(k uint) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintInt8) Set(k uint, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintInt8) Delete(k uint) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintRune struct {
	M map[uint]rune
	L sync.RWMutex
}

func NewConMapUintRune() *ConMapUintRune {
	return ToConMapUintRune(nil)
}

func ToConMapUintRune(data map[uint]rune) *ConMapUintRune {
	if data == nil {
		data = make(map[uint]rune)
	}
	return &ConMapUintRune{M: data}
}

func (cm *ConMapUintRune) Get(k uint) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintRune) GetOK(k uint) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintRune) Set(k uint, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintRune) Delete(k uint) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintString struct {
	M map[uint]string
	L sync.RWMutex
}

func NewConMapUintString() *ConMapUintString {
	return ToConMapUintString(nil)
}

func ToConMapUintString(data map[uint]string) *ConMapUintString {
	if data == nil {
		data = make(map[uint]string)
	}
	return &ConMapUintString{M: data}
}

func (cm *ConMapUintString) Get(k uint) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintString) GetOK(k uint) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintString) Set(k uint, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintString) Delete(k uint) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintUint struct {
	M map[uint]uint
	L sync.RWMutex
}

func NewConMapUintUint() *ConMapUintUint {
	return ToConMapUintUint(nil)
}

func ToConMapUintUint(data map[uint]uint) *ConMapUintUint {
	if data == nil {
		data = make(map[uint]uint)
	}
	return &ConMapUintUint{M: data}
}

func (cm *ConMapUintUint) Get(k uint) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintUint) GetOK(k uint) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintUint) Set(k uint, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintUint) Delete(k uint) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintUint16 struct {
	M map[uint]uint16
	L sync.RWMutex
}

func NewConMapUintUint16() *ConMapUintUint16 {
	return ToConMapUintUint16(nil)
}

func ToConMapUintUint16(data map[uint]uint16) *ConMapUintUint16 {
	if data == nil {
		data = make(map[uint]uint16)
	}
	return &ConMapUintUint16{M: data}
}

func (cm *ConMapUintUint16) Get(k uint) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintUint16) GetOK(k uint) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintUint16) Set(k uint, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintUint16) Delete(k uint) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintUint32 struct {
	M map[uint]uint32
	L sync.RWMutex
}

func NewConMapUintUint32() *ConMapUintUint32 {
	return ToConMapUintUint32(nil)
}

func ToConMapUintUint32(data map[uint]uint32) *ConMapUintUint32 {
	if data == nil {
		data = make(map[uint]uint32)
	}
	return &ConMapUintUint32{M: data}
}

func (cm *ConMapUintUint32) Get(k uint) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintUint32) GetOK(k uint) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintUint32) Set(k uint, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintUint32) Delete(k uint) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintUint64 struct {
	M map[uint]uint64
	L sync.RWMutex
}

func NewConMapUintUint64() *ConMapUintUint64 {
	return ToConMapUintUint64(nil)
}

func ToConMapUintUint64(data map[uint]uint64) *ConMapUintUint64 {
	if data == nil {
		data = make(map[uint]uint64)
	}
	return &ConMapUintUint64{M: data}
}

func (cm *ConMapUintUint64) Get(k uint) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintUint64) GetOK(k uint) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintUint64) Set(k uint, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintUint64) Delete(k uint) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintUint8 struct {
	M map[uint]uint8
	L sync.RWMutex
}

func NewConMapUintUint8() *ConMapUintUint8 {
	return ToConMapUintUint8(nil)
}

func ToConMapUintUint8(data map[uint]uint8) *ConMapUintUint8 {
	if data == nil {
		data = make(map[uint]uint8)
	}
	return &ConMapUintUint8{M: data}
}

func (cm *ConMapUintUint8) Get(k uint) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintUint8) GetOK(k uint) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintUint8) Set(k uint, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintUint8) Delete(k uint) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintUintptr struct {
	M map[uint]uintptr
	L sync.RWMutex
}

func NewConMapUintUintptr() *ConMapUintUintptr {
	return ToConMapUintUintptr(nil)
}

func ToConMapUintUintptr(data map[uint]uintptr) *ConMapUintUintptr {
	if data == nil {
		data = make(map[uint]uintptr)
	}
	return &ConMapUintUintptr{M: data}
}

func (cm *ConMapUintUintptr) Get(k uint) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintUintptr) GetOK(k uint) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintUintptr) Set(k uint, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintUintptr) Delete(k uint) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Bool struct {
	M map[uint16]bool
	L sync.RWMutex
}

func NewConMapUint16Bool() *ConMapUint16Bool {
	return ToConMapUint16Bool(nil)
}

func ToConMapUint16Bool(data map[uint16]bool) *ConMapUint16Bool {
	if data == nil {
		data = make(map[uint16]bool)
	}
	return &ConMapUint16Bool{M: data}
}

func (cm *ConMapUint16Bool) Get(k uint16) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Bool) GetOK(k uint16) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Bool) Set(k uint16, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Bool) Delete(k uint16) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Byte struct {
	M map[uint16]byte
	L sync.RWMutex
}

func NewConMapUint16Byte() *ConMapUint16Byte {
	return ToConMapUint16Byte(nil)
}

func ToConMapUint16Byte(data map[uint16]byte) *ConMapUint16Byte {
	if data == nil {
		data = make(map[uint16]byte)
	}
	return &ConMapUint16Byte{M: data}
}

func (cm *ConMapUint16Byte) Get(k uint16) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Byte) GetOK(k uint16) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Byte) Set(k uint16, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Byte) Delete(k uint16) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Complex128 struct {
	M map[uint16]complex128
	L sync.RWMutex
}

func NewConMapUint16Complex128() *ConMapUint16Complex128 {
	return ToConMapUint16Complex128(nil)
}

func ToConMapUint16Complex128(data map[uint16]complex128) *ConMapUint16Complex128 {
	if data == nil {
		data = make(map[uint16]complex128)
	}
	return &ConMapUint16Complex128{M: data}
}

func (cm *ConMapUint16Complex128) Get(k uint16) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Complex128) GetOK(k uint16) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Complex128) Set(k uint16, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Complex128) Delete(k uint16) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Complex64 struct {
	M map[uint16]complex64
	L sync.RWMutex
}

func NewConMapUint16Complex64() *ConMapUint16Complex64 {
	return ToConMapUint16Complex64(nil)
}

func ToConMapUint16Complex64(data map[uint16]complex64) *ConMapUint16Complex64 {
	if data == nil {
		data = make(map[uint16]complex64)
	}
	return &ConMapUint16Complex64{M: data}
}

func (cm *ConMapUint16Complex64) Get(k uint16) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Complex64) GetOK(k uint16) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Complex64) Set(k uint16, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Complex64) Delete(k uint16) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Error struct {
	M map[uint16]error
	L sync.RWMutex
}

func NewConMapUint16Error() *ConMapUint16Error {
	return ToConMapUint16Error(nil)
}

func ToConMapUint16Error(data map[uint16]error) *ConMapUint16Error {
	if data == nil {
		data = make(map[uint16]error)
	}
	return &ConMapUint16Error{M: data}
}

func (cm *ConMapUint16Error) Get(k uint16) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Error) GetOK(k uint16) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Error) Set(k uint16, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Error) Delete(k uint16) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Float32 struct {
	M map[uint16]float32
	L sync.RWMutex
}

func NewConMapUint16Float32() *ConMapUint16Float32 {
	return ToConMapUint16Float32(nil)
}

func ToConMapUint16Float32(data map[uint16]float32) *ConMapUint16Float32 {
	if data == nil {
		data = make(map[uint16]float32)
	}
	return &ConMapUint16Float32{M: data}
}

func (cm *ConMapUint16Float32) Get(k uint16) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Float32) GetOK(k uint16) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Float32) Set(k uint16, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Float32) Delete(k uint16) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Float64 struct {
	M map[uint16]float64
	L sync.RWMutex
}

func NewConMapUint16Float64() *ConMapUint16Float64 {
	return ToConMapUint16Float64(nil)
}

func ToConMapUint16Float64(data map[uint16]float64) *ConMapUint16Float64 {
	if data == nil {
		data = make(map[uint16]float64)
	}
	return &ConMapUint16Float64{M: data}
}

func (cm *ConMapUint16Float64) Get(k uint16) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Float64) GetOK(k uint16) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Float64) Set(k uint16, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Float64) Delete(k uint16) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Int struct {
	M map[uint16]int
	L sync.RWMutex
}

func NewConMapUint16Int() *ConMapUint16Int {
	return ToConMapUint16Int(nil)
}

func ToConMapUint16Int(data map[uint16]int) *ConMapUint16Int {
	if data == nil {
		data = make(map[uint16]int)
	}
	return &ConMapUint16Int{M: data}
}

func (cm *ConMapUint16Int) Get(k uint16) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Int) GetOK(k uint16) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Int) Set(k uint16, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Int) Delete(k uint16) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Int16 struct {
	M map[uint16]int16
	L sync.RWMutex
}

func NewConMapUint16Int16() *ConMapUint16Int16 {
	return ToConMapUint16Int16(nil)
}

func ToConMapUint16Int16(data map[uint16]int16) *ConMapUint16Int16 {
	if data == nil {
		data = make(map[uint16]int16)
	}
	return &ConMapUint16Int16{M: data}
}

func (cm *ConMapUint16Int16) Get(k uint16) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Int16) GetOK(k uint16) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Int16) Set(k uint16, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Int16) Delete(k uint16) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Int32 struct {
	M map[uint16]int32
	L sync.RWMutex
}

func NewConMapUint16Int32() *ConMapUint16Int32 {
	return ToConMapUint16Int32(nil)
}

func ToConMapUint16Int32(data map[uint16]int32) *ConMapUint16Int32 {
	if data == nil {
		data = make(map[uint16]int32)
	}
	return &ConMapUint16Int32{M: data}
}

func (cm *ConMapUint16Int32) Get(k uint16) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Int32) GetOK(k uint16) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Int32) Set(k uint16, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Int32) Delete(k uint16) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Int64 struct {
	M map[uint16]int64
	L sync.RWMutex
}

func NewConMapUint16Int64() *ConMapUint16Int64 {
	return ToConMapUint16Int64(nil)
}

func ToConMapUint16Int64(data map[uint16]int64) *ConMapUint16Int64 {
	if data == nil {
		data = make(map[uint16]int64)
	}
	return &ConMapUint16Int64{M: data}
}

func (cm *ConMapUint16Int64) Get(k uint16) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Int64) GetOK(k uint16) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Int64) Set(k uint16, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Int64) Delete(k uint16) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Int8 struct {
	M map[uint16]int8
	L sync.RWMutex
}

func NewConMapUint16Int8() *ConMapUint16Int8 {
	return ToConMapUint16Int8(nil)
}

func ToConMapUint16Int8(data map[uint16]int8) *ConMapUint16Int8 {
	if data == nil {
		data = make(map[uint16]int8)
	}
	return &ConMapUint16Int8{M: data}
}

func (cm *ConMapUint16Int8) Get(k uint16) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Int8) GetOK(k uint16) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Int8) Set(k uint16, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Int8) Delete(k uint16) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Rune struct {
	M map[uint16]rune
	L sync.RWMutex
}

func NewConMapUint16Rune() *ConMapUint16Rune {
	return ToConMapUint16Rune(nil)
}

func ToConMapUint16Rune(data map[uint16]rune) *ConMapUint16Rune {
	if data == nil {
		data = make(map[uint16]rune)
	}
	return &ConMapUint16Rune{M: data}
}

func (cm *ConMapUint16Rune) Get(k uint16) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Rune) GetOK(k uint16) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Rune) Set(k uint16, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Rune) Delete(k uint16) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16String struct {
	M map[uint16]string
	L sync.RWMutex
}

func NewConMapUint16String() *ConMapUint16String {
	return ToConMapUint16String(nil)
}

func ToConMapUint16String(data map[uint16]string) *ConMapUint16String {
	if data == nil {
		data = make(map[uint16]string)
	}
	return &ConMapUint16String{M: data}
}

func (cm *ConMapUint16String) Get(k uint16) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16String) GetOK(k uint16) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16String) Set(k uint16, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16String) Delete(k uint16) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Uint struct {
	M map[uint16]uint
	L sync.RWMutex
}

func NewConMapUint16Uint() *ConMapUint16Uint {
	return ToConMapUint16Uint(nil)
}

func ToConMapUint16Uint(data map[uint16]uint) *ConMapUint16Uint {
	if data == nil {
		data = make(map[uint16]uint)
	}
	return &ConMapUint16Uint{M: data}
}

func (cm *ConMapUint16Uint) Get(k uint16) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Uint) GetOK(k uint16) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Uint) Set(k uint16, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Uint) Delete(k uint16) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Uint16 struct {
	M map[uint16]uint16
	L sync.RWMutex
}

func NewConMapUint16Uint16() *ConMapUint16Uint16 {
	return ToConMapUint16Uint16(nil)
}

func ToConMapUint16Uint16(data map[uint16]uint16) *ConMapUint16Uint16 {
	if data == nil {
		data = make(map[uint16]uint16)
	}
	return &ConMapUint16Uint16{M: data}
}

func (cm *ConMapUint16Uint16) Get(k uint16) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Uint16) GetOK(k uint16) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Uint16) Set(k uint16, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Uint16) Delete(k uint16) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Uint32 struct {
	M map[uint16]uint32
	L sync.RWMutex
}

func NewConMapUint16Uint32() *ConMapUint16Uint32 {
	return ToConMapUint16Uint32(nil)
}

func ToConMapUint16Uint32(data map[uint16]uint32) *ConMapUint16Uint32 {
	if data == nil {
		data = make(map[uint16]uint32)
	}
	return &ConMapUint16Uint32{M: data}
}

func (cm *ConMapUint16Uint32) Get(k uint16) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Uint32) GetOK(k uint16) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Uint32) Set(k uint16, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Uint32) Delete(k uint16) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Uint64 struct {
	M map[uint16]uint64
	L sync.RWMutex
}

func NewConMapUint16Uint64() *ConMapUint16Uint64 {
	return ToConMapUint16Uint64(nil)
}

func ToConMapUint16Uint64(data map[uint16]uint64) *ConMapUint16Uint64 {
	if data == nil {
		data = make(map[uint16]uint64)
	}
	return &ConMapUint16Uint64{M: data}
}

func (cm *ConMapUint16Uint64) Get(k uint16) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Uint64) GetOK(k uint16) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Uint64) Set(k uint16, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Uint64) Delete(k uint16) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Uint8 struct {
	M map[uint16]uint8
	L sync.RWMutex
}

func NewConMapUint16Uint8() *ConMapUint16Uint8 {
	return ToConMapUint16Uint8(nil)
}

func ToConMapUint16Uint8(data map[uint16]uint8) *ConMapUint16Uint8 {
	if data == nil {
		data = make(map[uint16]uint8)
	}
	return &ConMapUint16Uint8{M: data}
}

func (cm *ConMapUint16Uint8) Get(k uint16) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Uint8) GetOK(k uint16) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Uint8) Set(k uint16, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Uint8) Delete(k uint16) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint16Uintptr struct {
	M map[uint16]uintptr
	L sync.RWMutex
}

func NewConMapUint16Uintptr() *ConMapUint16Uintptr {
	return ToConMapUint16Uintptr(nil)
}

func ToConMapUint16Uintptr(data map[uint16]uintptr) *ConMapUint16Uintptr {
	if data == nil {
		data = make(map[uint16]uintptr)
	}
	return &ConMapUint16Uintptr{M: data}
}

func (cm *ConMapUint16Uintptr) Get(k uint16) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint16Uintptr) GetOK(k uint16) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint16Uintptr) Set(k uint16, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint16Uintptr) Delete(k uint16) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint16Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Bool struct {
	M map[uint32]bool
	L sync.RWMutex
}

func NewConMapUint32Bool() *ConMapUint32Bool {
	return ToConMapUint32Bool(nil)
}

func ToConMapUint32Bool(data map[uint32]bool) *ConMapUint32Bool {
	if data == nil {
		data = make(map[uint32]bool)
	}
	return &ConMapUint32Bool{M: data}
}

func (cm *ConMapUint32Bool) Get(k uint32) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Bool) GetOK(k uint32) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Bool) Set(k uint32, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Bool) Delete(k uint32) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Byte struct {
	M map[uint32]byte
	L sync.RWMutex
}

func NewConMapUint32Byte() *ConMapUint32Byte {
	return ToConMapUint32Byte(nil)
}

func ToConMapUint32Byte(data map[uint32]byte) *ConMapUint32Byte {
	if data == nil {
		data = make(map[uint32]byte)
	}
	return &ConMapUint32Byte{M: data}
}

func (cm *ConMapUint32Byte) Get(k uint32) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Byte) GetOK(k uint32) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Byte) Set(k uint32, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Byte) Delete(k uint32) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Complex128 struct {
	M map[uint32]complex128
	L sync.RWMutex
}

func NewConMapUint32Complex128() *ConMapUint32Complex128 {
	return ToConMapUint32Complex128(nil)
}

func ToConMapUint32Complex128(data map[uint32]complex128) *ConMapUint32Complex128 {
	if data == nil {
		data = make(map[uint32]complex128)
	}
	return &ConMapUint32Complex128{M: data}
}

func (cm *ConMapUint32Complex128) Get(k uint32) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Complex128) GetOK(k uint32) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Complex128) Set(k uint32, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Complex128) Delete(k uint32) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Complex64 struct {
	M map[uint32]complex64
	L sync.RWMutex
}

func NewConMapUint32Complex64() *ConMapUint32Complex64 {
	return ToConMapUint32Complex64(nil)
}

func ToConMapUint32Complex64(data map[uint32]complex64) *ConMapUint32Complex64 {
	if data == nil {
		data = make(map[uint32]complex64)
	}
	return &ConMapUint32Complex64{M: data}
}

func (cm *ConMapUint32Complex64) Get(k uint32) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Complex64) GetOK(k uint32) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Complex64) Set(k uint32, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Complex64) Delete(k uint32) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Error struct {
	M map[uint32]error
	L sync.RWMutex
}

func NewConMapUint32Error() *ConMapUint32Error {
	return ToConMapUint32Error(nil)
}

func ToConMapUint32Error(data map[uint32]error) *ConMapUint32Error {
	if data == nil {
		data = make(map[uint32]error)
	}
	return &ConMapUint32Error{M: data}
}

func (cm *ConMapUint32Error) Get(k uint32) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Error) GetOK(k uint32) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Error) Set(k uint32, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Error) Delete(k uint32) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Float32 struct {
	M map[uint32]float32
	L sync.RWMutex
}

func NewConMapUint32Float32() *ConMapUint32Float32 {
	return ToConMapUint32Float32(nil)
}

func ToConMapUint32Float32(data map[uint32]float32) *ConMapUint32Float32 {
	if data == nil {
		data = make(map[uint32]float32)
	}
	return &ConMapUint32Float32{M: data}
}

func (cm *ConMapUint32Float32) Get(k uint32) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Float32) GetOK(k uint32) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Float32) Set(k uint32, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Float32) Delete(k uint32) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Float64 struct {
	M map[uint32]float64
	L sync.RWMutex
}

func NewConMapUint32Float64() *ConMapUint32Float64 {
	return ToConMapUint32Float64(nil)
}

func ToConMapUint32Float64(data map[uint32]float64) *ConMapUint32Float64 {
	if data == nil {
		data = make(map[uint32]float64)
	}
	return &ConMapUint32Float64{M: data}
}

func (cm *ConMapUint32Float64) Get(k uint32) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Float64) GetOK(k uint32) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Float64) Set(k uint32, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Float64) Delete(k uint32) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Int struct {
	M map[uint32]int
	L sync.RWMutex
}

func NewConMapUint32Int() *ConMapUint32Int {
	return ToConMapUint32Int(nil)
}

func ToConMapUint32Int(data map[uint32]int) *ConMapUint32Int {
	if data == nil {
		data = make(map[uint32]int)
	}
	return &ConMapUint32Int{M: data}
}

func (cm *ConMapUint32Int) Get(k uint32) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Int) GetOK(k uint32) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Int) Set(k uint32, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Int) Delete(k uint32) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Int16 struct {
	M map[uint32]int16
	L sync.RWMutex
}

func NewConMapUint32Int16() *ConMapUint32Int16 {
	return ToConMapUint32Int16(nil)
}

func ToConMapUint32Int16(data map[uint32]int16) *ConMapUint32Int16 {
	if data == nil {
		data = make(map[uint32]int16)
	}
	return &ConMapUint32Int16{M: data}
}

func (cm *ConMapUint32Int16) Get(k uint32) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Int16) GetOK(k uint32) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Int16) Set(k uint32, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Int16) Delete(k uint32) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Int32 struct {
	M map[uint32]int32
	L sync.RWMutex
}

func NewConMapUint32Int32() *ConMapUint32Int32 {
	return ToConMapUint32Int32(nil)
}

func ToConMapUint32Int32(data map[uint32]int32) *ConMapUint32Int32 {
	if data == nil {
		data = make(map[uint32]int32)
	}
	return &ConMapUint32Int32{M: data}
}

func (cm *ConMapUint32Int32) Get(k uint32) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Int32) GetOK(k uint32) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Int32) Set(k uint32, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Int32) Delete(k uint32) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Int64 struct {
	M map[uint32]int64
	L sync.RWMutex
}

func NewConMapUint32Int64() *ConMapUint32Int64 {
	return ToConMapUint32Int64(nil)
}

func ToConMapUint32Int64(data map[uint32]int64) *ConMapUint32Int64 {
	if data == nil {
		data = make(map[uint32]int64)
	}
	return &ConMapUint32Int64{M: data}
}

func (cm *ConMapUint32Int64) Get(k uint32) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Int64) GetOK(k uint32) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Int64) Set(k uint32, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Int64) Delete(k uint32) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Int8 struct {
	M map[uint32]int8
	L sync.RWMutex
}

func NewConMapUint32Int8() *ConMapUint32Int8 {
	return ToConMapUint32Int8(nil)
}

func ToConMapUint32Int8(data map[uint32]int8) *ConMapUint32Int8 {
	if data == nil {
		data = make(map[uint32]int8)
	}
	return &ConMapUint32Int8{M: data}
}

func (cm *ConMapUint32Int8) Get(k uint32) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Int8) GetOK(k uint32) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Int8) Set(k uint32, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Int8) Delete(k uint32) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Rune struct {
	M map[uint32]rune
	L sync.RWMutex
}

func NewConMapUint32Rune() *ConMapUint32Rune {
	return ToConMapUint32Rune(nil)
}

func ToConMapUint32Rune(data map[uint32]rune) *ConMapUint32Rune {
	if data == nil {
		data = make(map[uint32]rune)
	}
	return &ConMapUint32Rune{M: data}
}

func (cm *ConMapUint32Rune) Get(k uint32) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Rune) GetOK(k uint32) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Rune) Set(k uint32, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Rune) Delete(k uint32) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32String struct {
	M map[uint32]string
	L sync.RWMutex
}

func NewConMapUint32String() *ConMapUint32String {
	return ToConMapUint32String(nil)
}

func ToConMapUint32String(data map[uint32]string) *ConMapUint32String {
	if data == nil {
		data = make(map[uint32]string)
	}
	return &ConMapUint32String{M: data}
}

func (cm *ConMapUint32String) Get(k uint32) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32String) GetOK(k uint32) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32String) Set(k uint32, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32String) Delete(k uint32) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Uint struct {
	M map[uint32]uint
	L sync.RWMutex
}

func NewConMapUint32Uint() *ConMapUint32Uint {
	return ToConMapUint32Uint(nil)
}

func ToConMapUint32Uint(data map[uint32]uint) *ConMapUint32Uint {
	if data == nil {
		data = make(map[uint32]uint)
	}
	return &ConMapUint32Uint{M: data}
}

func (cm *ConMapUint32Uint) Get(k uint32) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Uint) GetOK(k uint32) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Uint) Set(k uint32, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Uint) Delete(k uint32) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Uint16 struct {
	M map[uint32]uint16
	L sync.RWMutex
}

func NewConMapUint32Uint16() *ConMapUint32Uint16 {
	return ToConMapUint32Uint16(nil)
}

func ToConMapUint32Uint16(data map[uint32]uint16) *ConMapUint32Uint16 {
	if data == nil {
		data = make(map[uint32]uint16)
	}
	return &ConMapUint32Uint16{M: data}
}

func (cm *ConMapUint32Uint16) Get(k uint32) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Uint16) GetOK(k uint32) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Uint16) Set(k uint32, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Uint16) Delete(k uint32) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Uint32 struct {
	M map[uint32]uint32
	L sync.RWMutex
}

func NewConMapUint32Uint32() *ConMapUint32Uint32 {
	return ToConMapUint32Uint32(nil)
}

func ToConMapUint32Uint32(data map[uint32]uint32) *ConMapUint32Uint32 {
	if data == nil {
		data = make(map[uint32]uint32)
	}
	return &ConMapUint32Uint32{M: data}
}

func (cm *ConMapUint32Uint32) Get(k uint32) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Uint32) GetOK(k uint32) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Uint32) Set(k uint32, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Uint32) Delete(k uint32) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Uint64 struct {
	M map[uint32]uint64
	L sync.RWMutex
}

func NewConMapUint32Uint64() *ConMapUint32Uint64 {
	return ToConMapUint32Uint64(nil)
}

func ToConMapUint32Uint64(data map[uint32]uint64) *ConMapUint32Uint64 {
	if data == nil {
		data = make(map[uint32]uint64)
	}
	return &ConMapUint32Uint64{M: data}
}

func (cm *ConMapUint32Uint64) Get(k uint32) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Uint64) GetOK(k uint32) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Uint64) Set(k uint32, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Uint64) Delete(k uint32) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Uint8 struct {
	M map[uint32]uint8
	L sync.RWMutex
}

func NewConMapUint32Uint8() *ConMapUint32Uint8 {
	return ToConMapUint32Uint8(nil)
}

func ToConMapUint32Uint8(data map[uint32]uint8) *ConMapUint32Uint8 {
	if data == nil {
		data = make(map[uint32]uint8)
	}
	return &ConMapUint32Uint8{M: data}
}

func (cm *ConMapUint32Uint8) Get(k uint32) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Uint8) GetOK(k uint32) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Uint8) Set(k uint32, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Uint8) Delete(k uint32) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint32Uintptr struct {
	M map[uint32]uintptr
	L sync.RWMutex
}

func NewConMapUint32Uintptr() *ConMapUint32Uintptr {
	return ToConMapUint32Uintptr(nil)
}

func ToConMapUint32Uintptr(data map[uint32]uintptr) *ConMapUint32Uintptr {
	if data == nil {
		data = make(map[uint32]uintptr)
	}
	return &ConMapUint32Uintptr{M: data}
}

func (cm *ConMapUint32Uintptr) Get(k uint32) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint32Uintptr) GetOK(k uint32) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint32Uintptr) Set(k uint32, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint32Uintptr) Delete(k uint32) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint32Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Bool struct {
	M map[uint64]bool
	L sync.RWMutex
}

func NewConMapUint64Bool() *ConMapUint64Bool {
	return ToConMapUint64Bool(nil)
}

func ToConMapUint64Bool(data map[uint64]bool) *ConMapUint64Bool {
	if data == nil {
		data = make(map[uint64]bool)
	}
	return &ConMapUint64Bool{M: data}
}

func (cm *ConMapUint64Bool) Get(k uint64) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Bool) GetOK(k uint64) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Bool) Set(k uint64, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Bool) Delete(k uint64) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Byte struct {
	M map[uint64]byte
	L sync.RWMutex
}

func NewConMapUint64Byte() *ConMapUint64Byte {
	return ToConMapUint64Byte(nil)
}

func ToConMapUint64Byte(data map[uint64]byte) *ConMapUint64Byte {
	if data == nil {
		data = make(map[uint64]byte)
	}
	return &ConMapUint64Byte{M: data}
}

func (cm *ConMapUint64Byte) Get(k uint64) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Byte) GetOK(k uint64) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Byte) Set(k uint64, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Byte) Delete(k uint64) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Complex128 struct {
	M map[uint64]complex128
	L sync.RWMutex
}

func NewConMapUint64Complex128() *ConMapUint64Complex128 {
	return ToConMapUint64Complex128(nil)
}

func ToConMapUint64Complex128(data map[uint64]complex128) *ConMapUint64Complex128 {
	if data == nil {
		data = make(map[uint64]complex128)
	}
	return &ConMapUint64Complex128{M: data}
}

func (cm *ConMapUint64Complex128) Get(k uint64) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Complex128) GetOK(k uint64) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Complex128) Set(k uint64, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Complex128) Delete(k uint64) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Complex64 struct {
	M map[uint64]complex64
	L sync.RWMutex
}

func NewConMapUint64Complex64() *ConMapUint64Complex64 {
	return ToConMapUint64Complex64(nil)
}

func ToConMapUint64Complex64(data map[uint64]complex64) *ConMapUint64Complex64 {
	if data == nil {
		data = make(map[uint64]complex64)
	}
	return &ConMapUint64Complex64{M: data}
}

func (cm *ConMapUint64Complex64) Get(k uint64) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Complex64) GetOK(k uint64) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Complex64) Set(k uint64, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Complex64) Delete(k uint64) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Error struct {
	M map[uint64]error
	L sync.RWMutex
}

func NewConMapUint64Error() *ConMapUint64Error {
	return ToConMapUint64Error(nil)
}

func ToConMapUint64Error(data map[uint64]error) *ConMapUint64Error {
	if data == nil {
		data = make(map[uint64]error)
	}
	return &ConMapUint64Error{M: data}
}

func (cm *ConMapUint64Error) Get(k uint64) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Error) GetOK(k uint64) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Error) Set(k uint64, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Error) Delete(k uint64) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Float32 struct {
	M map[uint64]float32
	L sync.RWMutex
}

func NewConMapUint64Float32() *ConMapUint64Float32 {
	return ToConMapUint64Float32(nil)
}

func ToConMapUint64Float32(data map[uint64]float32) *ConMapUint64Float32 {
	if data == nil {
		data = make(map[uint64]float32)
	}
	return &ConMapUint64Float32{M: data}
}

func (cm *ConMapUint64Float32) Get(k uint64) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Float32) GetOK(k uint64) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Float32) Set(k uint64, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Float32) Delete(k uint64) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Float64 struct {
	M map[uint64]float64
	L sync.RWMutex
}

func NewConMapUint64Float64() *ConMapUint64Float64 {
	return ToConMapUint64Float64(nil)
}

func ToConMapUint64Float64(data map[uint64]float64) *ConMapUint64Float64 {
	if data == nil {
		data = make(map[uint64]float64)
	}
	return &ConMapUint64Float64{M: data}
}

func (cm *ConMapUint64Float64) Get(k uint64) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Float64) GetOK(k uint64) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Float64) Set(k uint64, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Float64) Delete(k uint64) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Int struct {
	M map[uint64]int
	L sync.RWMutex
}

func NewConMapUint64Int() *ConMapUint64Int {
	return ToConMapUint64Int(nil)
}

func ToConMapUint64Int(data map[uint64]int) *ConMapUint64Int {
	if data == nil {
		data = make(map[uint64]int)
	}
	return &ConMapUint64Int{M: data}
}

func (cm *ConMapUint64Int) Get(k uint64) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Int) GetOK(k uint64) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Int) Set(k uint64, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Int) Delete(k uint64) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Int16 struct {
	M map[uint64]int16
	L sync.RWMutex
}

func NewConMapUint64Int16() *ConMapUint64Int16 {
	return ToConMapUint64Int16(nil)
}

func ToConMapUint64Int16(data map[uint64]int16) *ConMapUint64Int16 {
	if data == nil {
		data = make(map[uint64]int16)
	}
	return &ConMapUint64Int16{M: data}
}

func (cm *ConMapUint64Int16) Get(k uint64) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Int16) GetOK(k uint64) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Int16) Set(k uint64, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Int16) Delete(k uint64) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Int32 struct {
	M map[uint64]int32
	L sync.RWMutex
}

func NewConMapUint64Int32() *ConMapUint64Int32 {
	return ToConMapUint64Int32(nil)
}

func ToConMapUint64Int32(data map[uint64]int32) *ConMapUint64Int32 {
	if data == nil {
		data = make(map[uint64]int32)
	}
	return &ConMapUint64Int32{M: data}
}

func (cm *ConMapUint64Int32) Get(k uint64) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Int32) GetOK(k uint64) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Int32) Set(k uint64, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Int32) Delete(k uint64) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Int64 struct {
	M map[uint64]int64
	L sync.RWMutex
}

func NewConMapUint64Int64() *ConMapUint64Int64 {
	return ToConMapUint64Int64(nil)
}

func ToConMapUint64Int64(data map[uint64]int64) *ConMapUint64Int64 {
	if data == nil {
		data = make(map[uint64]int64)
	}
	return &ConMapUint64Int64{M: data}
}

func (cm *ConMapUint64Int64) Get(k uint64) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Int64) GetOK(k uint64) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Int64) Set(k uint64, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Int64) Delete(k uint64) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Int8 struct {
	M map[uint64]int8
	L sync.RWMutex
}

func NewConMapUint64Int8() *ConMapUint64Int8 {
	return ToConMapUint64Int8(nil)
}

func ToConMapUint64Int8(data map[uint64]int8) *ConMapUint64Int8 {
	if data == nil {
		data = make(map[uint64]int8)
	}
	return &ConMapUint64Int8{M: data}
}

func (cm *ConMapUint64Int8) Get(k uint64) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Int8) GetOK(k uint64) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Int8) Set(k uint64, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Int8) Delete(k uint64) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Rune struct {
	M map[uint64]rune
	L sync.RWMutex
}

func NewConMapUint64Rune() *ConMapUint64Rune {
	return ToConMapUint64Rune(nil)
}

func ToConMapUint64Rune(data map[uint64]rune) *ConMapUint64Rune {
	if data == nil {
		data = make(map[uint64]rune)
	}
	return &ConMapUint64Rune{M: data}
}

func (cm *ConMapUint64Rune) Get(k uint64) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Rune) GetOK(k uint64) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Rune) Set(k uint64, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Rune) Delete(k uint64) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64String struct {
	M map[uint64]string
	L sync.RWMutex
}

func NewConMapUint64String() *ConMapUint64String {
	return ToConMapUint64String(nil)
}

func ToConMapUint64String(data map[uint64]string) *ConMapUint64String {
	if data == nil {
		data = make(map[uint64]string)
	}
	return &ConMapUint64String{M: data}
}

func (cm *ConMapUint64String) Get(k uint64) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64String) GetOK(k uint64) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64String) Set(k uint64, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64String) Delete(k uint64) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Uint struct {
	M map[uint64]uint
	L sync.RWMutex
}

func NewConMapUint64Uint() *ConMapUint64Uint {
	return ToConMapUint64Uint(nil)
}

func ToConMapUint64Uint(data map[uint64]uint) *ConMapUint64Uint {
	if data == nil {
		data = make(map[uint64]uint)
	}
	return &ConMapUint64Uint{M: data}
}

func (cm *ConMapUint64Uint) Get(k uint64) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Uint) GetOK(k uint64) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Uint) Set(k uint64, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Uint) Delete(k uint64) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Uint16 struct {
	M map[uint64]uint16
	L sync.RWMutex
}

func NewConMapUint64Uint16() *ConMapUint64Uint16 {
	return ToConMapUint64Uint16(nil)
}

func ToConMapUint64Uint16(data map[uint64]uint16) *ConMapUint64Uint16 {
	if data == nil {
		data = make(map[uint64]uint16)
	}
	return &ConMapUint64Uint16{M: data}
}

func (cm *ConMapUint64Uint16) Get(k uint64) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Uint16) GetOK(k uint64) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Uint16) Set(k uint64, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Uint16) Delete(k uint64) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Uint32 struct {
	M map[uint64]uint32
	L sync.RWMutex
}

func NewConMapUint64Uint32() *ConMapUint64Uint32 {
	return ToConMapUint64Uint32(nil)
}

func ToConMapUint64Uint32(data map[uint64]uint32) *ConMapUint64Uint32 {
	if data == nil {
		data = make(map[uint64]uint32)
	}
	return &ConMapUint64Uint32{M: data}
}

func (cm *ConMapUint64Uint32) Get(k uint64) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Uint32) GetOK(k uint64) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Uint32) Set(k uint64, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Uint32) Delete(k uint64) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Uint64 struct {
	M map[uint64]uint64
	L sync.RWMutex
}

func NewConMapUint64Uint64() *ConMapUint64Uint64 {
	return ToConMapUint64Uint64(nil)
}

func ToConMapUint64Uint64(data map[uint64]uint64) *ConMapUint64Uint64 {
	if data == nil {
		data = make(map[uint64]uint64)
	}
	return &ConMapUint64Uint64{M: data}
}

func (cm *ConMapUint64Uint64) Get(k uint64) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Uint64) GetOK(k uint64) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Uint64) Set(k uint64, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Uint64) Delete(k uint64) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Uint8 struct {
	M map[uint64]uint8
	L sync.RWMutex
}

func NewConMapUint64Uint8() *ConMapUint64Uint8 {
	return ToConMapUint64Uint8(nil)
}

func ToConMapUint64Uint8(data map[uint64]uint8) *ConMapUint64Uint8 {
	if data == nil {
		data = make(map[uint64]uint8)
	}
	return &ConMapUint64Uint8{M: data}
}

func (cm *ConMapUint64Uint8) Get(k uint64) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Uint8) GetOK(k uint64) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Uint8) Set(k uint64, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Uint8) Delete(k uint64) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint64Uintptr struct {
	M map[uint64]uintptr
	L sync.RWMutex
}

func NewConMapUint64Uintptr() *ConMapUint64Uintptr {
	return ToConMapUint64Uintptr(nil)
}

func ToConMapUint64Uintptr(data map[uint64]uintptr) *ConMapUint64Uintptr {
	if data == nil {
		data = make(map[uint64]uintptr)
	}
	return &ConMapUint64Uintptr{M: data}
}

func (cm *ConMapUint64Uintptr) Get(k uint64) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint64Uintptr) GetOK(k uint64) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint64Uintptr) Set(k uint64, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint64Uintptr) Delete(k uint64) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint64Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Bool struct {
	M map[uint8]bool
	L sync.RWMutex
}

func NewConMapUint8Bool() *ConMapUint8Bool {
	return ToConMapUint8Bool(nil)
}

func ToConMapUint8Bool(data map[uint8]bool) *ConMapUint8Bool {
	if data == nil {
		data = make(map[uint8]bool)
	}
	return &ConMapUint8Bool{M: data}
}

func (cm *ConMapUint8Bool) Get(k uint8) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Bool) GetOK(k uint8) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Bool) Set(k uint8, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Bool) Delete(k uint8) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Bool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Byte struct {
	M map[uint8]byte
	L sync.RWMutex
}

func NewConMapUint8Byte() *ConMapUint8Byte {
	return ToConMapUint8Byte(nil)
}

func ToConMapUint8Byte(data map[uint8]byte) *ConMapUint8Byte {
	if data == nil {
		data = make(map[uint8]byte)
	}
	return &ConMapUint8Byte{M: data}
}

func (cm *ConMapUint8Byte) Get(k uint8) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Byte) GetOK(k uint8) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Byte) Set(k uint8, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Byte) Delete(k uint8) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Byte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Complex128 struct {
	M map[uint8]complex128
	L sync.RWMutex
}

func NewConMapUint8Complex128() *ConMapUint8Complex128 {
	return ToConMapUint8Complex128(nil)
}

func ToConMapUint8Complex128(data map[uint8]complex128) *ConMapUint8Complex128 {
	if data == nil {
		data = make(map[uint8]complex128)
	}
	return &ConMapUint8Complex128{M: data}
}

func (cm *ConMapUint8Complex128) Get(k uint8) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Complex128) GetOK(k uint8) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Complex128) Set(k uint8, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Complex128) Delete(k uint8) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Complex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Complex64 struct {
	M map[uint8]complex64
	L sync.RWMutex
}

func NewConMapUint8Complex64() *ConMapUint8Complex64 {
	return ToConMapUint8Complex64(nil)
}

func ToConMapUint8Complex64(data map[uint8]complex64) *ConMapUint8Complex64 {
	if data == nil {
		data = make(map[uint8]complex64)
	}
	return &ConMapUint8Complex64{M: data}
}

func (cm *ConMapUint8Complex64) Get(k uint8) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Complex64) GetOK(k uint8) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Complex64) Set(k uint8, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Complex64) Delete(k uint8) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Complex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Error struct {
	M map[uint8]error
	L sync.RWMutex
}

func NewConMapUint8Error() *ConMapUint8Error {
	return ToConMapUint8Error(nil)
}

func ToConMapUint8Error(data map[uint8]error) *ConMapUint8Error {
	if data == nil {
		data = make(map[uint8]error)
	}
	return &ConMapUint8Error{M: data}
}

func (cm *ConMapUint8Error) Get(k uint8) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Error) GetOK(k uint8) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Error) Set(k uint8, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Error) Delete(k uint8) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Error) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Float32 struct {
	M map[uint8]float32
	L sync.RWMutex
}

func NewConMapUint8Float32() *ConMapUint8Float32 {
	return ToConMapUint8Float32(nil)
}

func ToConMapUint8Float32(data map[uint8]float32) *ConMapUint8Float32 {
	if data == nil {
		data = make(map[uint8]float32)
	}
	return &ConMapUint8Float32{M: data}
}

func (cm *ConMapUint8Float32) Get(k uint8) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Float32) GetOK(k uint8) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Float32) Set(k uint8, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Float32) Delete(k uint8) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Float32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Float64 struct {
	M map[uint8]float64
	L sync.RWMutex
}

func NewConMapUint8Float64() *ConMapUint8Float64 {
	return ToConMapUint8Float64(nil)
}

func ToConMapUint8Float64(data map[uint8]float64) *ConMapUint8Float64 {
	if data == nil {
		data = make(map[uint8]float64)
	}
	return &ConMapUint8Float64{M: data}
}

func (cm *ConMapUint8Float64) Get(k uint8) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Float64) GetOK(k uint8) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Float64) Set(k uint8, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Float64) Delete(k uint8) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Float64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Int struct {
	M map[uint8]int
	L sync.RWMutex
}

func NewConMapUint8Int() *ConMapUint8Int {
	return ToConMapUint8Int(nil)
}

func ToConMapUint8Int(data map[uint8]int) *ConMapUint8Int {
	if data == nil {
		data = make(map[uint8]int)
	}
	return &ConMapUint8Int{M: data}
}

func (cm *ConMapUint8Int) Get(k uint8) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Int) GetOK(k uint8) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Int) Set(k uint8, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Int) Delete(k uint8) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Int) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Int16 struct {
	M map[uint8]int16
	L sync.RWMutex
}

func NewConMapUint8Int16() *ConMapUint8Int16 {
	return ToConMapUint8Int16(nil)
}

func ToConMapUint8Int16(data map[uint8]int16) *ConMapUint8Int16 {
	if data == nil {
		data = make(map[uint8]int16)
	}
	return &ConMapUint8Int16{M: data}
}

func (cm *ConMapUint8Int16) Get(k uint8) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Int16) GetOK(k uint8) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Int16) Set(k uint8, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Int16) Delete(k uint8) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Int16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Int32 struct {
	M map[uint8]int32
	L sync.RWMutex
}

func NewConMapUint8Int32() *ConMapUint8Int32 {
	return ToConMapUint8Int32(nil)
}

func ToConMapUint8Int32(data map[uint8]int32) *ConMapUint8Int32 {
	if data == nil {
		data = make(map[uint8]int32)
	}
	return &ConMapUint8Int32{M: data}
}

func (cm *ConMapUint8Int32) Get(k uint8) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Int32) GetOK(k uint8) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Int32) Set(k uint8, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Int32) Delete(k uint8) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Int32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Int64 struct {
	M map[uint8]int64
	L sync.RWMutex
}

func NewConMapUint8Int64() *ConMapUint8Int64 {
	return ToConMapUint8Int64(nil)
}

func ToConMapUint8Int64(data map[uint8]int64) *ConMapUint8Int64 {
	if data == nil {
		data = make(map[uint8]int64)
	}
	return &ConMapUint8Int64{M: data}
}

func (cm *ConMapUint8Int64) Get(k uint8) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Int64) GetOK(k uint8) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Int64) Set(k uint8, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Int64) Delete(k uint8) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Int64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Int8 struct {
	M map[uint8]int8
	L sync.RWMutex
}

func NewConMapUint8Int8() *ConMapUint8Int8 {
	return ToConMapUint8Int8(nil)
}

func ToConMapUint8Int8(data map[uint8]int8) *ConMapUint8Int8 {
	if data == nil {
		data = make(map[uint8]int8)
	}
	return &ConMapUint8Int8{M: data}
}

func (cm *ConMapUint8Int8) Get(k uint8) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Int8) GetOK(k uint8) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Int8) Set(k uint8, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Int8) Delete(k uint8) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Int8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Rune struct {
	M map[uint8]rune
	L sync.RWMutex
}

func NewConMapUint8Rune() *ConMapUint8Rune {
	return ToConMapUint8Rune(nil)
}

func ToConMapUint8Rune(data map[uint8]rune) *ConMapUint8Rune {
	if data == nil {
		data = make(map[uint8]rune)
	}
	return &ConMapUint8Rune{M: data}
}

func (cm *ConMapUint8Rune) Get(k uint8) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Rune) GetOK(k uint8) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Rune) Set(k uint8, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Rune) Delete(k uint8) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Rune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8String struct {
	M map[uint8]string
	L sync.RWMutex
}

func NewConMapUint8String() *ConMapUint8String {
	return ToConMapUint8String(nil)
}

func ToConMapUint8String(data map[uint8]string) *ConMapUint8String {
	if data == nil {
		data = make(map[uint8]string)
	}
	return &ConMapUint8String{M: data}
}

func (cm *ConMapUint8String) Get(k uint8) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8String) GetOK(k uint8) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8String) Set(k uint8, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8String) Delete(k uint8) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8String) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Uint struct {
	M map[uint8]uint
	L sync.RWMutex
}

func NewConMapUint8Uint() *ConMapUint8Uint {
	return ToConMapUint8Uint(nil)
}

func ToConMapUint8Uint(data map[uint8]uint) *ConMapUint8Uint {
	if data == nil {
		data = make(map[uint8]uint)
	}
	return &ConMapUint8Uint{M: data}
}

func (cm *ConMapUint8Uint) Get(k uint8) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Uint) GetOK(k uint8) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Uint) Set(k uint8, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Uint) Delete(k uint8) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Uint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Uint16 struct {
	M map[uint8]uint16
	L sync.RWMutex
}

func NewConMapUint8Uint16() *ConMapUint8Uint16 {
	return ToConMapUint8Uint16(nil)
}

func ToConMapUint8Uint16(data map[uint8]uint16) *ConMapUint8Uint16 {
	if data == nil {
		data = make(map[uint8]uint16)
	}
	return &ConMapUint8Uint16{M: data}
}

func (cm *ConMapUint8Uint16) Get(k uint8) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Uint16) GetOK(k uint8) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Uint16) Set(k uint8, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Uint16) Delete(k uint8) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Uint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Uint32 struct {
	M map[uint8]uint32
	L sync.RWMutex
}

func NewConMapUint8Uint32() *ConMapUint8Uint32 {
	return ToConMapUint8Uint32(nil)
}

func ToConMapUint8Uint32(data map[uint8]uint32) *ConMapUint8Uint32 {
	if data == nil {
		data = make(map[uint8]uint32)
	}
	return &ConMapUint8Uint32{M: data}
}

func (cm *ConMapUint8Uint32) Get(k uint8) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Uint32) GetOK(k uint8) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Uint32) Set(k uint8, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Uint32) Delete(k uint8) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Uint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Uint64 struct {
	M map[uint8]uint64
	L sync.RWMutex
}

func NewConMapUint8Uint64() *ConMapUint8Uint64 {
	return ToConMapUint8Uint64(nil)
}

func ToConMapUint8Uint64(data map[uint8]uint64) *ConMapUint8Uint64 {
	if data == nil {
		data = make(map[uint8]uint64)
	}
	return &ConMapUint8Uint64{M: data}
}

func (cm *ConMapUint8Uint64) Get(k uint8) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Uint64) GetOK(k uint8) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Uint64) Set(k uint8, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Uint64) Delete(k uint8) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Uint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Uint8 struct {
	M map[uint8]uint8
	L sync.RWMutex
}

func NewConMapUint8Uint8() *ConMapUint8Uint8 {
	return ToConMapUint8Uint8(nil)
}

func ToConMapUint8Uint8(data map[uint8]uint8) *ConMapUint8Uint8 {
	if data == nil {
		data = make(map[uint8]uint8)
	}
	return &ConMapUint8Uint8{M: data}
}

func (cm *ConMapUint8Uint8) Get(k uint8) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Uint8) GetOK(k uint8) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Uint8) Set(k uint8, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Uint8) Delete(k uint8) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Uint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUint8Uintptr struct {
	M map[uint8]uintptr
	L sync.RWMutex
}

func NewConMapUint8Uintptr() *ConMapUint8Uintptr {
	return ToConMapUint8Uintptr(nil)
}

func ToConMapUint8Uintptr(data map[uint8]uintptr) *ConMapUint8Uintptr {
	if data == nil {
		data = make(map[uint8]uintptr)
	}
	return &ConMapUint8Uintptr{M: data}
}

func (cm *ConMapUint8Uintptr) Get(k uint8) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUint8Uintptr) GetOK(k uint8) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUint8Uintptr) Set(k uint8, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUint8Uintptr) Delete(k uint8) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUint8Uintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrBool struct {
	M map[uintptr]bool
	L sync.RWMutex
}

func NewConMapUintptrBool() *ConMapUintptrBool {
	return ToConMapUintptrBool(nil)
}

func ToConMapUintptrBool(data map[uintptr]bool) *ConMapUintptrBool {
	if data == nil {
		data = make(map[uintptr]bool)
	}
	return &ConMapUintptrBool{M: data}
}

func (cm *ConMapUintptrBool) Get(k uintptr) bool {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrBool) GetOK(k uintptr) (bool, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrBool) Set(k uintptr, v bool) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrBool) Delete(k uintptr) (bool, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrBool) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrByte struct {
	M map[uintptr]byte
	L sync.RWMutex
}

func NewConMapUintptrByte() *ConMapUintptrByte {
	return ToConMapUintptrByte(nil)
}

func ToConMapUintptrByte(data map[uintptr]byte) *ConMapUintptrByte {
	if data == nil {
		data = make(map[uintptr]byte)
	}
	return &ConMapUintptrByte{M: data}
}

func (cm *ConMapUintptrByte) Get(k uintptr) byte {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrByte) GetOK(k uintptr) (byte, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrByte) Set(k uintptr, v byte) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrByte) Delete(k uintptr) (byte, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrByte) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrComplex128 struct {
	M map[uintptr]complex128
	L sync.RWMutex
}

func NewConMapUintptrComplex128() *ConMapUintptrComplex128 {
	return ToConMapUintptrComplex128(nil)
}

func ToConMapUintptrComplex128(data map[uintptr]complex128) *ConMapUintptrComplex128 {
	if data == nil {
		data = make(map[uintptr]complex128)
	}
	return &ConMapUintptrComplex128{M: data}
}

func (cm *ConMapUintptrComplex128) Get(k uintptr) complex128 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrComplex128) GetOK(k uintptr) (complex128, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrComplex128) Set(k uintptr, v complex128) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrComplex128) Delete(k uintptr) (complex128, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrComplex128) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrComplex64 struct {
	M map[uintptr]complex64
	L sync.RWMutex
}

func NewConMapUintptrComplex64() *ConMapUintptrComplex64 {
	return ToConMapUintptrComplex64(nil)
}

func ToConMapUintptrComplex64(data map[uintptr]complex64) *ConMapUintptrComplex64 {
	if data == nil {
		data = make(map[uintptr]complex64)
	}
	return &ConMapUintptrComplex64{M: data}
}

func (cm *ConMapUintptrComplex64) Get(k uintptr) complex64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrComplex64) GetOK(k uintptr) (complex64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrComplex64) Set(k uintptr, v complex64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrComplex64) Delete(k uintptr) (complex64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrComplex64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrError struct {
	M map[uintptr]error
	L sync.RWMutex
}

func NewConMapUintptrError() *ConMapUintptrError {
	return ToConMapUintptrError(nil)
}

func ToConMapUintptrError(data map[uintptr]error) *ConMapUintptrError {
	if data == nil {
		data = make(map[uintptr]error)
	}
	return &ConMapUintptrError{M: data}
}

func (cm *ConMapUintptrError) Get(k uintptr) error {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrError) GetOK(k uintptr) (error, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrError) Set(k uintptr, v error) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrError) Delete(k uintptr) (error, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrError) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrFloat32 struct {
	M map[uintptr]float32
	L sync.RWMutex
}

func NewConMapUintptrFloat32() *ConMapUintptrFloat32 {
	return ToConMapUintptrFloat32(nil)
}

func ToConMapUintptrFloat32(data map[uintptr]float32) *ConMapUintptrFloat32 {
	if data == nil {
		data = make(map[uintptr]float32)
	}
	return &ConMapUintptrFloat32{M: data}
}

func (cm *ConMapUintptrFloat32) Get(k uintptr) float32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrFloat32) GetOK(k uintptr) (float32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrFloat32) Set(k uintptr, v float32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrFloat32) Delete(k uintptr) (float32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrFloat32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrFloat64 struct {
	M map[uintptr]float64
	L sync.RWMutex
}

func NewConMapUintptrFloat64() *ConMapUintptrFloat64 {
	return ToConMapUintptrFloat64(nil)
}

func ToConMapUintptrFloat64(data map[uintptr]float64) *ConMapUintptrFloat64 {
	if data == nil {
		data = make(map[uintptr]float64)
	}
	return &ConMapUintptrFloat64{M: data}
}

func (cm *ConMapUintptrFloat64) Get(k uintptr) float64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrFloat64) GetOK(k uintptr) (float64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrFloat64) Set(k uintptr, v float64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrFloat64) Delete(k uintptr) (float64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrFloat64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrInt struct {
	M map[uintptr]int
	L sync.RWMutex
}

func NewConMapUintptrInt() *ConMapUintptrInt {
	return ToConMapUintptrInt(nil)
}

func ToConMapUintptrInt(data map[uintptr]int) *ConMapUintptrInt {
	if data == nil {
		data = make(map[uintptr]int)
	}
	return &ConMapUintptrInt{M: data}
}

func (cm *ConMapUintptrInt) Get(k uintptr) int {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrInt) GetOK(k uintptr) (int, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrInt) Set(k uintptr, v int) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrInt) Delete(k uintptr) (int, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrInt) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrInt16 struct {
	M map[uintptr]int16
	L sync.RWMutex
}

func NewConMapUintptrInt16() *ConMapUintptrInt16 {
	return ToConMapUintptrInt16(nil)
}

func ToConMapUintptrInt16(data map[uintptr]int16) *ConMapUintptrInt16 {
	if data == nil {
		data = make(map[uintptr]int16)
	}
	return &ConMapUintptrInt16{M: data}
}

func (cm *ConMapUintptrInt16) Get(k uintptr) int16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrInt16) GetOK(k uintptr) (int16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrInt16) Set(k uintptr, v int16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrInt16) Delete(k uintptr) (int16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrInt16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrInt32 struct {
	M map[uintptr]int32
	L sync.RWMutex
}

func NewConMapUintptrInt32() *ConMapUintptrInt32 {
	return ToConMapUintptrInt32(nil)
}

func ToConMapUintptrInt32(data map[uintptr]int32) *ConMapUintptrInt32 {
	if data == nil {
		data = make(map[uintptr]int32)
	}
	return &ConMapUintptrInt32{M: data}
}

func (cm *ConMapUintptrInt32) Get(k uintptr) int32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrInt32) GetOK(k uintptr) (int32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrInt32) Set(k uintptr, v int32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrInt32) Delete(k uintptr) (int32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrInt32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrInt64 struct {
	M map[uintptr]int64
	L sync.RWMutex
}

func NewConMapUintptrInt64() *ConMapUintptrInt64 {
	return ToConMapUintptrInt64(nil)
}

func ToConMapUintptrInt64(data map[uintptr]int64) *ConMapUintptrInt64 {
	if data == nil {
		data = make(map[uintptr]int64)
	}
	return &ConMapUintptrInt64{M: data}
}

func (cm *ConMapUintptrInt64) Get(k uintptr) int64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrInt64) GetOK(k uintptr) (int64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrInt64) Set(k uintptr, v int64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrInt64) Delete(k uintptr) (int64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrInt64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrInt8 struct {
	M map[uintptr]int8
	L sync.RWMutex
}

func NewConMapUintptrInt8() *ConMapUintptrInt8 {
	return ToConMapUintptrInt8(nil)
}

func ToConMapUintptrInt8(data map[uintptr]int8) *ConMapUintptrInt8 {
	if data == nil {
		data = make(map[uintptr]int8)
	}
	return &ConMapUintptrInt8{M: data}
}

func (cm *ConMapUintptrInt8) Get(k uintptr) int8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrInt8) GetOK(k uintptr) (int8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrInt8) Set(k uintptr, v int8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrInt8) Delete(k uintptr) (int8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrInt8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrRune struct {
	M map[uintptr]rune
	L sync.RWMutex
}

func NewConMapUintptrRune() *ConMapUintptrRune {
	return ToConMapUintptrRune(nil)
}

func ToConMapUintptrRune(data map[uintptr]rune) *ConMapUintptrRune {
	if data == nil {
		data = make(map[uintptr]rune)
	}
	return &ConMapUintptrRune{M: data}
}

func (cm *ConMapUintptrRune) Get(k uintptr) rune {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrRune) GetOK(k uintptr) (rune, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrRune) Set(k uintptr, v rune) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrRune) Delete(k uintptr) (rune, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrRune) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrString struct {
	M map[uintptr]string
	L sync.RWMutex
}

func NewConMapUintptrString() *ConMapUintptrString {
	return ToConMapUintptrString(nil)
}

func ToConMapUintptrString(data map[uintptr]string) *ConMapUintptrString {
	if data == nil {
		data = make(map[uintptr]string)
	}
	return &ConMapUintptrString{M: data}
}

func (cm *ConMapUintptrString) Get(k uintptr) string {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrString) GetOK(k uintptr) (string, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrString) Set(k uintptr, v string) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrString) Delete(k uintptr) (string, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrString) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrUint struct {
	M map[uintptr]uint
	L sync.RWMutex
}

func NewConMapUintptrUint() *ConMapUintptrUint {
	return ToConMapUintptrUint(nil)
}

func ToConMapUintptrUint(data map[uintptr]uint) *ConMapUintptrUint {
	if data == nil {
		data = make(map[uintptr]uint)
	}
	return &ConMapUintptrUint{M: data}
}

func (cm *ConMapUintptrUint) Get(k uintptr) uint {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrUint) GetOK(k uintptr) (uint, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrUint) Set(k uintptr, v uint) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrUint) Delete(k uintptr) (uint, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrUint) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrUint16 struct {
	M map[uintptr]uint16
	L sync.RWMutex
}

func NewConMapUintptrUint16() *ConMapUintptrUint16 {
	return ToConMapUintptrUint16(nil)
}

func ToConMapUintptrUint16(data map[uintptr]uint16) *ConMapUintptrUint16 {
	if data == nil {
		data = make(map[uintptr]uint16)
	}
	return &ConMapUintptrUint16{M: data}
}

func (cm *ConMapUintptrUint16) Get(k uintptr) uint16 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrUint16) GetOK(k uintptr) (uint16, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrUint16) Set(k uintptr, v uint16) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrUint16) Delete(k uintptr) (uint16, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrUint16) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrUint32 struct {
	M map[uintptr]uint32
	L sync.RWMutex
}

func NewConMapUintptrUint32() *ConMapUintptrUint32 {
	return ToConMapUintptrUint32(nil)
}

func ToConMapUintptrUint32(data map[uintptr]uint32) *ConMapUintptrUint32 {
	if data == nil {
		data = make(map[uintptr]uint32)
	}
	return &ConMapUintptrUint32{M: data}
}

func (cm *ConMapUintptrUint32) Get(k uintptr) uint32 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrUint32) GetOK(k uintptr) (uint32, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrUint32) Set(k uintptr, v uint32) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrUint32) Delete(k uintptr) (uint32, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrUint32) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrUint64 struct {
	M map[uintptr]uint64
	L sync.RWMutex
}

func NewConMapUintptrUint64() *ConMapUintptrUint64 {
	return ToConMapUintptrUint64(nil)
}

func ToConMapUintptrUint64(data map[uintptr]uint64) *ConMapUintptrUint64 {
	if data == nil {
		data = make(map[uintptr]uint64)
	}
	return &ConMapUintptrUint64{M: data}
}

func (cm *ConMapUintptrUint64) Get(k uintptr) uint64 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrUint64) GetOK(k uintptr) (uint64, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrUint64) Set(k uintptr, v uint64) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrUint64) Delete(k uintptr) (uint64, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrUint64) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrUint8 struct {
	M map[uintptr]uint8
	L sync.RWMutex
}

func NewConMapUintptrUint8() *ConMapUintptrUint8 {
	return ToConMapUintptrUint8(nil)
}

func ToConMapUintptrUint8(data map[uintptr]uint8) *ConMapUintptrUint8 {
	if data == nil {
		data = make(map[uintptr]uint8)
	}
	return &ConMapUintptrUint8{M: data}
}

func (cm *ConMapUintptrUint8) Get(k uintptr) uint8 {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrUint8) GetOK(k uintptr) (uint8, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrUint8) Set(k uintptr, v uint8) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrUint8) Delete(k uintptr) (uint8, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrUint8) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}

type ConMapUintptrUintptr struct {
	M map[uintptr]uintptr
	L sync.RWMutex
}

func NewConMapUintptrUintptr() *ConMapUintptrUintptr {
	return ToConMapUintptrUintptr(nil)
}

func ToConMapUintptrUintptr(data map[uintptr]uintptr) *ConMapUintptrUintptr {
	if data == nil {
		data = make(map[uintptr]uintptr)
	}
	return &ConMapUintptrUintptr{M: data}
}

func (cm *ConMapUintptrUintptr) Get(k uintptr) uintptr {
	cm.L.RLock()
	v := cm.M[k]
	cm.L.RUnlock()
	return v
}
func (cm *ConMapUintptrUintptr) GetOK(k uintptr) (uintptr, bool) {
	cm.L.RLock()
	v, ok := cm.M[k]
	cm.L.RUnlock()
	return v, ok
}

func (cm *ConMapUintptrUintptr) Set(k uintptr, v uintptr) {
	cm.L.Lock()
	cm.M[k] = v
	cm.L.Unlock()
}

func (cm *ConMapUintptrUintptr) Delete(k uintptr) (uintptr, bool) {
	cm.L.Lock()
	v, ok := cm.M[k]
	if ok {
		delete(cm.M, k)
	}
	cm.L.Unlock()
	return v, ok
}

func (cm *ConMapUintptrUintptr) Len() int {
	cm.L.RLock()
	l := len(cm.M)
	cm.L.RUnlock()
	return l
}
